<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis笔记 | keep Study</title><meta name="author" content="小张,2260391948@qq.com"><meta name="copyright" content="小张"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis笔记">
<meta property="og:url" content="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2022/12/24/Redis%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="keep Study">
<meta property="og:description" content="Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/img/cover.png">
<meta property="article:published_time" content="2022-12-24T02:29:58.000Z">
<meta property="article:modified_time" content="2023-10-12T12:10:51.539Z">
<meta property="article:author" content="小张">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/img/cover.png"><link rel="shortcut icon" href="/./img/favicon.png"><link rel="canonical" href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2022/12/24/Redis%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"该文章创建于","messageNext":"天前,请以最新的文章为准"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-12 20:10:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><link href="https://cdn.bootcdn.net/ajax/libs/toastr.js/2.1.4/toastr.min.css" rel="stylesheet"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4185042_s9i9e08l3w.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/global.css"><link rel="stylesheet" href="/css/style.css"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/xlenco/JS-X@main/pace.js/pace.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-iconzhengli-"></i><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-LINKS"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-aixin"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/cover.png')"><nav id="nav"><span id="blog-info"><a href="/" title="keep Study"><span class="site-name">keep Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="iconfont icon-sousuo"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-iconzhengli-"></i><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-LINKS"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-aixin"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-24T02:29:58.000Z" title="发表于 2022-12-24 10:29:58">2022-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T12:10:51.539Z" title="更新于 2023-10-12 20:10:51">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、redis入门"><a href="#一、redis入门" class="headerlink" title="一、redis入门"></a>一、redis入门</h2><h3 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h3><p>是什么？</p>
<ul>
<li>基于内存的K/V存储中间件</li>
<li>NoSQL键值对数据库</li>
</ul>
<p>redis不仅是数据库，他还可以做消息队列</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661837971044-8d4a7ce9-a2da-4d15-bf7b-a5e38d5009b0.png?x-oss-process=image%2Fresize%2Cw_700%2Climit_0#averageHue=%23f5eeee&amp;from=url&amp;id=uwr5K&amp;originHeight=303&amp;originWidth=700&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>关系型SQL和NoSQL的对比<br />其中应用场景：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661838712523-ef4a9938-379e-4633-90cd-04fedfa53af4.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f3f1f1&amp;from=url&amp;id=PgkG4&amp;originHeight=367&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="Redis特征"><a href="#Redis特征" class="headerlink" title="Redis特征"></a>Redis特征</h3><ol>
<li>支持各种数据类型</li>
<li>单线程，每个命令的执行具备原子性,中途不会执行其他命令</li>
<li>高性能，低延迟</li>
<li>支持数据持久化</li>
<li>支持主从、分片集群</li>
<li>支持多语言客户端</li>
</ol>
<h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><p>Redis的命令根据数据结构分为多个组<br />1）redis 命令集 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a><br />2）redis-cli help 命令查看，help[command]可以查看某个具体命令，help@xxx可以查看某个分组下的命令</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661860409628-60998ca7-81bc-427b-84ec-25ca927cacc7.png?x-oss-process=image%2Fresize%2Cw_618%2Climit_0#averageHue=%23152737&amp;from=url&amp;id=u5l36&amp;originHeight=330&amp;originWidth=618&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul>
<li>set key value</li>
<li>get key</li>
<li>key pattern 模糊搜索多个Key</li>
<li>del key…</li>
<li>exists key 判断key是否存在</li>
<li>expire key 设置过期时间</li>
<li>ttl key 查询剩余存活时间，未设置过期时间则为-1</li>
</ul>
<h3 id="Redis-基本数据类型"><a href="#Redis-基本数据类型" class="headerlink" title="Redis 基本数据类型"></a>Redis 基本数据类型</h3><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>支持存储字符串、数字、浮点数<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661862706289-0d131c29-9848-41e9-89a9-4dd0e07d78ca.png#averageHue=%23cbcbc9&amp;from=url&amp;id=ZawBP&amp;originHeight=310&amp;originWidth=1420&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />单key的value最大不能超过512M<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661861550219-c870a6c5-c3b8-45c2-a98c-d40ee9da54cc.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f2f2f2&amp;from=url&amp;id=PlH8O&amp;originHeight=465&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>实际使用时，通常用冒号连接多个次来拼接key，比如【项目名】:【业务名】:【类名】:【id】<br />在使用GUI时，会自动根据冒号来划分层级，浏览更方便</p>
<h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><p>值是一个Hash结构(类似于java的HashMap)<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661862400679-42bd43d3-c014-4bef-84c6-cfda891a1e10.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23cececc&amp;from=url&amp;id=yXI2g&amp;originHeight=299&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>常用命令:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661862672521-cda7532d-f7df-45f8-afcd-05d711768631.png?x-oss-process=image%2Fresize%2Cw_760%2Climit_0#averageHue=%23f3f3f3&amp;from=url&amp;id=VOweh&amp;originHeight=442&amp;originWidth=760&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>理解为Java的LinkList 双向链表，特点是有序、插入删除快、但查询性能一般：<br />常见命令如下:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661863091505-4e936f4b-4bd9-4725-a3fe-3af79521b3b5.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f6f6f6&amp;from=url&amp;id=GsMpk&amp;originHeight=391&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h4><p>集合：类似于java的HashSet，特点是单set内集合不能重复，查找性能高<br />常见命令如下:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661863589046-7495e388-5607-4a74-8579-70110e2bcabf.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f1f0ef&amp;from=url&amp;id=uWNNe&amp;originHeight=354&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h4><p>有序集合，在set的基础上给每个元素多存了一个分数，类似于value类型为整形的Hashmap<br />特点：有序、查询性能高、适合于排行榜、统计TopN<br />常用命令:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661864069819-a212e48e-6847-402f-9c8b-c49da2035fd5.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f1f1f1&amp;from=url&amp;id=sZxwX&amp;originHeight=396&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="Redis-客户端"><a href="#Redis-客户端" class="headerlink" title="Redis 客户端"></a>Redis 客户端</h3><h4 id="主流客户端"><a href="#主流客户端" class="headerlink" title="主流客户端"></a>主流客户端</h4><p>可以在官网查看所有客户的以及推荐的客户端:<a target="_blank" rel="noopener" href="https://redis.io/docs/clients">https://redis.io/docs/clients</a><br />对于Java主要以下几种：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661864923846-67ea2b28-c325-4086-af4a-bbc3edd04de4.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fef9f8&amp;from=url&amp;id=CZnv4&amp;originHeight=612&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />其中jedis的命令和原生redis命令行命令一致，学习成本最低（线程不安全，需要搭配连接池使用），letture和spring兼容型最好（spring Data Redis默认集成），基于netty性能最高，Redisson提供了和java集合一致的分布式集合，适用于更复杂的业务场景</p>
<h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><p>spring Data 封装了一系列数据访问操作，spring Data Redis则是封装了Jedis 、 Lettuce 两个Redis 客户端的操作，提供了统一的Redis Template 来操作Redis。<br />RedisTemplate 针对不同的Redis数据结构提供了不同的API，划分更明确：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661871634006-05f40eaf-65ce-4995-8f50-dc4e05294aaf.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23e6e6e3&amp;from=url&amp;id=C5nBx&amp;originHeight=249&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>注意：在使用spring Data Redis中使用Lettuce 线程池的话，要额外引入apache commons-pool2 依赖。</p>
<h4 id="RedisTemplate-序列化"><a href="#RedisTemplate-序列化" class="headerlink" title="RedisTemplate 序列化"></a>RedisTemplate 序列化</h4><p>RedisTemplate 默认使用JDK原生序列化器，可读性差、内存占用大、因此可以使用以下两种方式改变序列化机制：</p>
<ol>
<li>自定义RedisTemplate，指定key和value的序列化器</li>
<li>使用自带的StringRedisTemplate，key和value使用默认的String序列化器，仅支持写入String类型的key和value，因此需要将对象序列化为String来写入redis，从redis读取时也要反序列化。</li>
</ol>
<h3 id="共享Session（单点登录）"><a href="#共享Session（单点登录）" class="headerlink" title="共享Session（单点登录）"></a>共享Session（单点登录）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>为什么要共享session？<br />防止多个后端服务器存储不一致，导致用户访问时出现未登录的情况</p>
<p>如何实现共享Session<br />使用独立的内存存储来实现Session</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661921616087-778dd8bf-63cc-4796-b1c3-677122547928.png?x-oss-process=image%2Fresize%2Cw_940%2Climit_0#averageHue=%23f7f6f6&amp;from=url&amp;id=eA3eN&amp;originHeight=427&amp;originWidth=940&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>key如何设计<br />为了安全性，随机生成Token，而不是拼接用户信息，防止恶意伪造或爆破</p>
<h4 id="选用何种value数据结构放入用户信息"><a href="#选用何种value数据结构放入用户信息" class="headerlink" title="选用何种value数据结构放入用户信息"></a>选用何种value数据结构放入用户信息</h4><p>string还是hash？有两种方案：<br />1、先在程序中将对象进行Json序列化，再以String类型写入<br />2、直接以Hash结构写入</p>
<p>因为用户信息时对象，建议选择hash数据结构，占用内存更少、且支持对单个字段的增删改查<br />具体流程：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661922180950-6aa9be44-d6cb-4753-a2c7-0b808e6de6ca.png?x-oss-process=image%2Fresize%2Cw_916%2Climit_0#averageHue=%23f1eeee&amp;from=url&amp;id=wqMa5&amp;originHeight=481&amp;originWidth=916&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>写入Redis的数据一定设置过期时间</li>
<li>存入redis的数据尽量保证精简安全，比如存入用户信息时移除密码等敏感数据</li>
<li>已登陆的用户访问系统后，记得刷新token过期时效，并且访问任何路径时都要刷新token，而不仅是登录的路径，可以新增一层的拦截器来实现token刷新，如下图：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661923370328-3c051d77-234c-4553-a207-a0f897bd2779.png?x-oss-process=image%2Fresize%2Cw_955%2Climit_0#averageHue=%23e5d4d3&amp;from=url&amp;id=GUq5c&amp;originHeight=479&amp;originWidth=955&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>什么是缓存？<br />临时存放数据的缓冲区</p>
<p>缓存无处不在：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661923818451-afd131ec-3f5e-4147-af3d-2bcf310a0112.png?x-oss-process=image%2Fresize%2Cw_903%2Climit_0#averageHue=%23fafafa&amp;from=url&amp;id=faN9S&amp;originHeight=455&amp;originWidth=903&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>为什么需要缓存？<br />提前准备好数据，便于更快读写</p>
<p>缓存不是银弹，要权衡利弊！<br />优点：</p>
<ul>
<li>降低后端节点负载</li>
<li>提高数据读取性能</li>
</ul>
<p>缺点：</p>
<ul>
<li>额外引入中间间，增加运维成本</li>
<li>额外开发和解决缓存带来的问题，提高开发成本</li>
<li>需要保证数据一致性</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>关键流程</p>
<ol>
<li>暂无缓存，从数据库读取，然后设置缓存</li>
<li>已有缓存，直接读取</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661924258122-ccc9a1d4-16a8-46bb-9e44-cd4d4a85ae42.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f2f2f2&amp;from=url&amp;id=z95iH&amp;originHeight=381&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>几种常见的策略，一般选择主动更新+超时剔除兜底：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661924949521-2c030516-1fe7-4685-85e4-c6b686b5a0fe.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23ecebeb&amp;from=url&amp;id=QBJBx&amp;originHeight=377&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>主动更新缓存的几种方法：</p>
<ol>
<li>cache aside ：通过人工编码，在更新数据库的同时更新缓存</li>
<li>write/read through ：使用现成的数据写入服务，原理就是将缓存和数据库整合为一套服务，让服务来维护数据库和缓存的一致性，我们只需要写数据即可，写完数据后缓存就有，我们不用关心数据一致性问题。</li>
<li>write behind cache：只更新缓存，通过异步线程定期将缓存的数据持久化到数据库</li>
</ol>
<p>是选择删除缓存还是更新缓存？<br />建议选择删除缓存，等待下次查询时自动设置缓存，做到随用随取，可以避免每次更新数据库后都更新缓存的无效操作</p>
<p>多线程情况下，如何保证缓存和数据库的一致性？</p>
<ol>
<li>单机：使用本地事务</li>
<li><p>分布式，使用TCC等分布式事务</p>
<p><br />先删除缓存还是先操作数据库<br />下图为两种方式在多线程下可能存在的问题：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661925752772-983448c9-25a2-486a-98fd-a723ea56ca82.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f4f3f3&amp;from=url&amp;id=bMsHT&amp;originHeight=390&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />两种方案都不能做到百分百一致性，但是建议选择先操作数据库，再删除缓存，出现问题的概率会更低，可以配合延时双删保证缓存一定被删除</p>
</li>
</ol>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>客户端请求的数据在缓存和数据库中都不存在的，这样缓存永远不会生效，这些请求都会打到数据库。<br />解决方案：</p>
<ol>
<li>缓存空值：比如向redis中塞一个空字符串，注意可以给空对象设置一个短的过期时间，或者在新增数据时，强制清除下对应的缓存，防止查出来的为null；</li>
<li>布隆过滤</li>
</ol>
<p>初始化布隆过滤器：在Redis中，可以使用BitSet数据结构来实现位数组。可以使用SETBIT命令初始化位数组，将所有位都设置为0。<br />插入缓存数据：在缓存中存储正常的数据。对于每个要插入的数据，使用多个不同的哈希函数计算出多个哈希值，并将对应的位数组位置设置为1，表示该数据存在。<br />判断请求是否合法：当有请求到达时，先使用相同的多个哈希函数计算出对应的哈希值，并检查位数组中对应的位置是否都为1。如果有任何一个位置为0，则说明该请求的数据一定不存在，可以直接返回缓存未命中的结果，避免访问数据库。<br />处理缓存未命中：如果布隆过滤器判断请求的数据可能存在（即所有位置都为1），则继续从缓存中查询数据。如果缓存中也不存在该数据，则返回缓存未命中的结果。<br />通过使用布隆过滤器，可以在O(1)的时间复杂度内快速判断请求是否合法，减少对数据库的不必要访问，从而提高系统性能和安全性。然而，需要注意的是，布隆过滤器是一个概率型数据结构，存在一定的误判率。因此，在使用布隆过滤器时，需要根据实际情况进行调整，以平衡误判率和空间开销。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661944372353-2f44d70a-6207-42b5-8602-bdfb0330d159.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f5f5f5&amp;from=url&amp;id=LSlsY&amp;originHeight=328&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>预防做法：</p>
<ol>
<li>增加对请求数据的校验 ，比如id&gt;0</li>
<li>增加对数据格式的控制，比如id设置为10位，不为10位的请求直接拒绝</li>
<li>增加用户权限校验</li>
<li>通过限流来保护数据库</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在同一时间大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p>解决思路：</p>
<ol>
<li>不让key同时失效（可以为key设置时间时添加后缀，使到期时间相差几分钟，防止同一时间大量key失效）</li>
<li>Redis集群，提高服务可用性，不同Redis之间可以实现数据同步</li>
<li>为缓存添加多级缓存（nginx，redis，jvm等，最后查询数据库）</li>
<li>给缓存业务添加降级限流策略</li>
<li>尽量不让redis宕机</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661945589442-a88fd882-3452-461e-9adb-9bfa2a577eb6.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f3f0f0&amp;from=url&amp;id=yvVER&amp;originHeight=329&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿问题也叫热点key问题，就是一个被高并发访问并且缓存重建<br />业务较复杂的key失效，无数的请求在瞬间给数据库带来了巨大冲击</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661945757372-9427691c-56bc-4521-b996-e93c7351afe0.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f4f4f3&amp;from=url&amp;id=Hpp8s&amp;originHeight=369&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />两种解决方案：</p>
<ol>
<li>互斥锁：只有一个线程负责缓存重建，其他线程拿不到锁，就等待</li>
<li>逻辑过期：key设置为永不过期，在value中记录过期时间，业务中根据这个时间判断缓存是否有效，如果缓存已过期，只有一个线程抢到锁，然后再次判断缓存是否存在，开启独立的线程去更新缓存，然后立即返回过期数据，其他抢不到锁的线程也立即返回过期数据，不用等着释放。</li>
</ol>
<p>如图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661946415976-1cc6c5fa-f333-4088-9efe-a8431b857d43.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23eeeded&amp;from=url&amp;id=E9NeB&amp;originHeight=385&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>两种方式都使用了互斥锁来降低重建的开销。<br />方案优缺点对比:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661946774577-4368f0a8-419c-42a4-87cd-6e3c8c81f957.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f8f8f6&amp;from=url&amp;id=k4abM&amp;originHeight=305&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>以上几种缓存常见问题的解决方案都是和业务无关的，因此可以封装自己的缓存操作封装类。</p>
<p>互斥锁解决思路：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1685064819205-654deccf-6b1f-4d73-8ad5-c65dc4887b9e.png#averageHue=%23f7f2f1&amp;clientId=u2541892d-404e-4&amp;from=paste&amp;height=469&amp;id=u936233a4&amp;originHeight=516&amp;originWidth=703&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=133210&amp;status=done&amp;style=none&amp;taskId=u19c0b384-1484-4792-be05-a37e8c2ffcd&amp;title=&amp;width=639.090895238987" alt="756IK1DE(17S%X`TTI{_N$7.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TbShop <span class="title function_">quarywithStuck</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> CACHE_QUERYSHOP_ID;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key + id);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> JSONUtil.toBean(json, TbShop.class);</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> tbShop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据为空值，因此该店铺不存在!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span> (!aBoolean) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            quarywithStuck(id);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        查库</span></span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">byId</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">if</span> (Optional.ofNullable(byId).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(Key + id, JSONUtil.toJsonStr(byId));</span><br><span class="line">                stringRedisTemplate.expire(Key + id, CACHE_QUERYSHOP_ID_TTL, TimeUnit.MINUTES);</span><br><span class="line">                log.info(<span class="string">&quot;通过数据库查询数据并写入缓存!&quot;</span>);</span><br><span class="line">                relaseLock(LOCK_SHOP_KEY + id);</span><br><span class="line">                <span class="keyword">return</span> byId;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;缓存写入失败!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(Key + id, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            stringRedisTemplate.expire(Key + id, CACHE_QUERYSHOP_ID_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            log.info(<span class="string">&quot;通过数据库查询数据不存在，并写空值到缓存中!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>逻辑过期解决思路：<br />![L(3XY$%$`A~)%[MN)Q9GS<a target="_blank" rel="noopener" href="https://cdn.nlark.com/yuque/0/2023/png/33551426/1685064766656-f3a27e75-9533-48b4-ac42-a8a754443aaa.png#averageHue=%23f8f3f3&amp;clientId=u2541892d-404e-4&amp;from=paste&amp;height=488&amp;id=u83297854&amp;originHeight=537&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=170563&amp;status=done&amp;style=none&amp;taskId=u89ee9c75-438c-4b37-8da5-2bd96afa702&amp;title=&amp;width=910.9090711656685">7.png</a><br />具体代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        缓存穿透解决方案</span></span><br><span class="line"><span class="comment">//        TbShop tbShop = quarywithNull(id);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        利用互斥锁解决缓存击穿</span></span><br><span class="line"><span class="comment">//        TbShop tbShop = quarywithStuck(id);</span></span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> quarywithLocalExpire(id);</span><br><span class="line">        <span class="keyword">if</span> (Optional.ofNullable(tbShop).isPresent()) &#123;</span><br><span class="line">            Result.fail(<span class="string">&quot;该店铺不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(tbShop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">50</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExpre</span><span class="params">(Long id, Long expireSecond)</span> &#123;</span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(tbShop);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSecond));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_QUERYSHOP_ID + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CHCHE_REBUTLD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑过期解决缓存击穿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TbShop <span class="title function_">quarywithLocalExpire</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> CACHE_QUERYSHOP_ID;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key + id);</span><br><span class="line"><span class="comment">//        未命中 为空，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        命中，判断是否过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> JSONUtil.toBean(data, TbShop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line"><span class="comment">//        未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> tbShop;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        已过期，尝试获取互斥锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span> (!aBoolean) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;未获取到锁&quot;</span>);</span><br><span class="line"><span class="comment">//        获取失败，返回旧数据</span></span><br><span class="line">            <span class="keyword">return</span> tbShop;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//        获取成功，开启独立线程，返回旧数据</span></span><br><span class="line">            log.info(<span class="string">&quot;已获取到锁&quot;</span>);</span><br><span class="line">            CHCHE_REBUTLD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.setExpre(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//               释放锁</span></span><br><span class="line">                    relaseLock(LOCK_SHOP_KEY + id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tbShop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>引入模块:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>解决问题（缓存穿透（空值）、缓存击穿(逻辑过期)）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.xiaozhang.entity.domain.TbShop;</span><br><span class="line"><span class="keyword">import</span> com.xiaozhang.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xiaozhang.utils.RedisConstants.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xiaozhang.utils.RedisConstants.LOCK_SHOP_KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:22603</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2023/5/27 13:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setwithLocalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存穿透利用空值解决</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  &lt;R, ID&gt; R <span class="title function_">quarywithNull</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbfallck, Long time, TimeUnit unit,Long cacheWithNull,TimeUnit unitWithNull)</span> &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(json, type);</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据为空值!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        查库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> dbfallck.apply(id);</span><br><span class="line">        <span class="keyword">if</span> (Optional.ofNullable(result).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.set(Key, result, time, unit);</span><br><span class="line">                log.info(<span class="string">&quot;通过数据库查询数据并写入缓存!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;缓存写入失败!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(Key, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            stringRedisTemplate.expire(Key, cacheWithNull, unitWithNull);</span><br><span class="line">            log.info(<span class="string">&quot;通过数据库查询数据不存在，并写空值到缓存中!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">50</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CHCHE_REBUTLD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑过期解决缓存击穿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">quarywithLocalExpire</span><span class="params">(String keyPrefix,String lockeyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbfallck, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> keyPrefix+id;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key);</span><br><span class="line"><span class="comment">//        未命中 为空，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        命中，判断是否过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(data, type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line"><span class="comment">//        未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        已过期，尝试获取互斥锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> tryLock(lockeyPrefix + id);</span><br><span class="line">        <span class="keyword">if</span> (!aBoolean) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;未获取到锁&quot;</span>);</span><br><span class="line"><span class="comment">//        获取失败，返回旧数据</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//        获取成功，开启独立线程，返回旧数据</span></span><br><span class="line">            log.info(<span class="string">&quot;已获取到锁&quot;</span>);</span><br><span class="line">            CHCHE_REBUTLD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(lockeyPrefix + id);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> dbfallck.apply(id);</span><br><span class="line">                    <span class="built_in">this</span>.setwithLocalExpire(Key,result,time,unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//               释放锁</span></span><br><span class="line">                    relaseLock(lockeyPrefix + id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="分布式全局ID生成"><a href="#分布式全局ID生成" class="headerlink" title="分布式全局ID生成"></a>分布式全局ID生成</h3><p>为什么需要分布式全局ID生成器?<br />1.对于订单这种数据，数据库自增的规律性太明显，会暴露一些信息（比如根据昨日和今日的订单号差值看出销<br />量)<br />2．数据量过大时，不同表的id分别自增，容易出现id冲突</p>
<p>分布式全局ID生成应满足的特点:<br />1．唯一:整个系统每个id都是唯一的<br />2．递增:虽然不连续，但整体ID保持递增，有利于数据库创建索引(也符合自然规律)<br />3．安全:不能通过id看出敏感业务信息<br />4．高可用:作为核心服务，不能挂掉，否则会影响新数据的生成5．高性能:作为频繁调用的服务，性能—定要高</p>
<p>几种常见的ID生成方法，建议根据自己的实际需求选择和设计算法:</p>
<ul>
<li>雪花算法:性能更高，引入机器序号，但依赖全局时钟</li>
<li>数据库自增:单独的自增表，所有id全从这个表取。但性能没有Redis高</li>
<li>UUID:随机生成十六进制字符串，性能高，但是乱序、字符串会占用更多空间</li>
<li>Redis自增ID:利用incr命令实现单key的自增</li>
</ul>
<p>Redis自增ID完全可以满足以上几个分布式全局ID的特点。</p>
<h4 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h4><p>以下是一种ID生成的设计，使用Long类型存储ID<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1685174529136-c1643a46-bf91-43de-baa6-3a59afc22dd8.png#averageHue=%23f6f4f4&amp;clientId=ud5f11d0f-88e8-4&amp;from=paste&amp;height=516&amp;id=u416a5458&amp;originHeight=568&amp;originWidth=1172&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=162891&amp;status=done&amp;style=none&amp;taskId=ua1273b1b-761b-4b35-996c-309a0a8cf88&amp;title=&amp;width=1065.4545223614407" alt="T]6]UP)NBR)~0HR2H68`_%G.png"></p>
<p>使用Redis的incr命令，可以实现后32位的原子性递增。<br />Redis的key可以设计为[业务]:[类型]:[日期],这样每天都会从1开始生成序列。如果用单key，可能出现生成的序号数溢出2^32的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1685318400L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="优惠券秒杀流程"><a href="#优惠券秒杀流程" class="headerlink" title="优惠券秒杀流程"></a>优惠券秒杀流程</h3><p>秒杀业务的核心流程是:判断日期和库存、扣减库存、创建订单<br />如下图:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662008375039-1a71b20d-1d87-4607-b7e0-c29b05808d41.png?x-oss-process=image%2Fresize%2Cw_615%2Climit_0#averageHue=%23fbfafa&amp;from=url&amp;id=lvLMK&amp;originHeight=488&amp;originWidth=615&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>注意，秒杀库存信息和商品信息最好是独立的两张表，不要放在一起影响性能。</p>
<h3 id="订单超卖问题"><a href="#订单超卖问题" class="headerlink" title="订单超卖问题"></a>订单超卖问题</h3><p>出现的原因：有多个人同时下单，在库存扣减前大家查库存都大于0，都触发了减库存的操作</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662008722698-a9549270-6dc2-4ede-b081-07e0e6ba0456.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f5f5f5&amp;from=url&amp;id=d6i0q&amp;originHeight=402&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>解决方法：</p>
<p>1）悲观锁:假定每次并发都会冲突，所以干脆给操作整体加锁，将并发改为同步执行。可以通过synchronized关键字实现。<br />优点是实现简单，缺点是严重影响性能(大家可以同时抢购)。</p>
<p>2)乐观锁:假定并发不一定会冲突，所以不加锁，而是通过判断数据是否在查出来之后被其他线程修改过，来决定是否允许操作。</p>
<p>乐观锁主要有版本号法和CAS两种实现方式。</p>
<p>版本号法:<br />给数据增加一个版本号字段，每次修改操作版本号＋1，就可以通过版本号来判断数据是否有被修改。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662009330789-7326c51e-3039-456c-8f3d-b4530e53445b.png?x-oss-process=image%2Fresize%2Cw_945%2Climit_0#averageHue=%23faf9f9&amp;from=url&amp;id=Z296U&amp;originHeight=431&amp;originWidth=945&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>CAS是对乐观锁的简化，即直接用一个每次都会查询和更新的字段来代替版本号，比如库存stock 字段:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662009326982-7488a52c-d95d-4d88-85a0-29d5884b28f0.png?x-oss-process=image%2Fresize%2Cw_935%2Climit_0#averageHue=%23fbfafa&amp;from=url&amp;id=bzJgq&amp;originHeight=420&amp;originWidth=935&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>优点:性能好<br />缺点:存在成功率低的问题(很多人查到的版本号是一样的，结果只能有一个人操作成功)，可以使用分段锁来改进。比如将100个库存分为10份，大家分别抢这10份。</p>
<p>对于以上这种场景，其实不用判断stock是否变化，可以直接判断stock &gt; 0，从而保障成功率。</p>
<h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>对应视频P54，这集封神<br />优惠券或者秒杀活动的目的是为了吸引新用户，因此不能让一个用户把所有东西都抢走了。所以需要额外判断用户当前下单数是否&gt; 0。<br />这一步操作在多线程场景下依然会出现问题:新用户第一次进来同时抢10次，结果判断下单数都是0，然后就都抢成功了。<br />所以还是需要加锁，因为订单是新创建的数据，所以无法使用乐观锁，使用悲观锁实现。</p>
<h4 id="单机实现"><a href="#单机实现" class="headerlink" title="单机实现"></a>单机实现</h4><p>单机部署后端服务器时，可以使用java自带的synchronized关键字作为悲观锁<br />要注意几个细节问题：<br />1）synchronized的范围不能太大，不能锁住整个对象，会严重影响性能，因为是一人一单 ，所有可以每个用户独立的一把锁。<br />注意:锁住 对象时要用toString().intern()，保证同id的用户始终是同一个用户，单单tostring，会new一个String，相当于一个新对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (id.toString().intern()) &#123;</span><br><span class="line"><span class="comment">//            获取事务代理对象</span></span><br><span class="line">            <span class="type">TbVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>2)synchronized必须在使用@Transactional注解的方法外层使用，因为@Transactional是使用代理对象，，在方法执行完才能提交事务，如果把synchronized写在事务方法里，提交事务前释放锁，但此时数据未更新，其他线程依然能获取锁并顺利执行，依然会存在线程问题<br />3）调用事务方法不能用this对象，因为@Transactional注解实际是调用spring生成的代理对象方法，如果调用this对象，会无法使用事务功能，所以要获取代理对象并调用。<br />代码实现：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662011259738-a6a16663-4e36-438d-9e78-f40063cd67c4.png?x-oss-process=image%2Fresize%2Cw_717%2Climit_0#averageHue=%23f1f4eb&amp;from=url&amp;id=IHVIc&amp;originHeight=141&amp;originWidth=717&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h4><p>synchronized只对单个jvm有效，多机部署可能同时有多个不同的jvm线程访问已加锁的方法。<br />具体原理：<br />单机条件下，只有一个tomcat，一个tomcat服务器相当于有一个全新的jvm，在jvm内部维护了一个锁监视器对象，在Id相同的情况下，只能存放一个线程，其他线程进来时不允许访问，维护的是同一个用户。在集群模式下，会有多个jvm存在，每个jvm内部有自己的锁，每个锁相互独立，多个线程同时运行，会存在线程安全问题。<br />如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662030241202-f47dd469-1d9b-4df5-9f26-092d2730d984.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23efeded&amp;from=url&amp;id=WdnrZ&amp;originHeight=341&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>因此，我们不能把锁存储在单个服务器上，而是应该使用一个集中的存储来管理锁，所以进程都能读到他，这就需要分布式锁。</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁：满足分布式系统或者集群模式下多个进程可见并且互斥的锁</p>
<p>分布式锁的两个基本特征：</p>
<ol>
<li>多进程（线程）可见（读写）</li>
<li>互斥</li>
</ol>
<p>还具备的特征：</p>
<ol>
<li>高可用：不能挂机，不能经常出现问题</li>
<li>高性能（并发）：读写快</li>
<li>安全性：不能出现死锁<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4>注意有三种：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662031300272-0956bc6b-69e4-48f5-87fe-47b7e5df15d8.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f8f2f0&amp;from=url&amp;id=O5br0&amp;originHeight=318&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />其中，mysql的实现成本最低、redis性能最高，Zookeeper可以实现，但是不推荐（保证的是强一致性而不是性能和高可用性，cp模式）</li>
</ol>
<h4 id="Redis-分布式锁实现"><a href="#Redis-分布式锁实现" class="headerlink" title="Redis 分布式锁实现"></a>Redis 分布式锁实现</h4><p>获取锁：</p>
<ul>
<li>使用setnx命令设置lock（本质是键值对），保证只有一个线程取锁成功。并执行业务逻辑，其他线程可以重试或返回失败</li>
<li>必须setnx指定lock、过期时间（满足安全性）</li>
</ul>
<p>注意事项：</p>
<ol>
<li>为了防止setnx后宕机导致死锁，必须使用set 【key】 ex nx 的原子命令，保证每个lock都有过期时间</li>
<li>锁的key建议设计包含userid，保证多个用户可以并发执行，而不是多个用户抢同一把锁。</li>
</ol>
<p>释放锁：</p>
<ul>
<li>主动是否：业务执行完删除key，注意释放锁的逻辑放在finlly中</li>
<li>超时自动释放（key过期）</li>
</ul>
<p>流程：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662031740955-361196d9-008c-430f-96c9-968da059d16e.png#averageHue=%23f8f6f6&amp;from=url&amp;id=WjNSy&amp;originHeight=822&amp;originWidth=598&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="误删情况"><a href="#误删情况" class="headerlink" title="误删情况"></a>误删情况</h4><h5 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h5><p>如果线程A执行业务时间过长，锁提前过期了，另一个线程B拿到锁并执行业务流程，这是A突然又执行完了，结果误删了线程B加的锁，会导致新的线程C又可以拿到锁，从而又出现线程安全问题<br /> <img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662052166859-f38be15f-b57d-40e9-ba2c-1fb638039954.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23faf9f9&amp;from=url&amp;id=QMusl&amp;originHeight=314&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="情况1解决方案"><a href="#情况1解决方案" class="headerlink" title="情况1解决方案"></a>情况1解决方案</h5><p>在获取锁的时候value中存入【本机标识+当前线程id】，释放锁时检测value必须等于该值，是自己的锁才可以释放。<br />注意：不能只在value中存入线程id，因为多个机器的线程id可能是一样的，仍然可能出现问题，因此可以给每个机器生成一个唯一标识，再拼接id</p>
<p>流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662051386701-c39bfd2a-1e7a-43fb-8af2-cb6380ddc4db.png?x-oss-process=image%2Fresize%2Cw_322%2Climit_0#averageHue=%23f1edea&amp;from=url&amp;id=V0xeE&amp;originHeight=383&amp;originWidth=322&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h5><p>假设线程A释放锁时判断了是自己的锁，但这时jvm触发了stop the world，线程A卡住了，然后锁超时释放了，线程B拿到了锁的执行业务，这时，线程A醒来了，删除了锁key，线程c正好进来啦，拿到了锁并执行，又出现了线程安全问题。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662051917992-256924ba-49b7-4eeb-bff8-0db968eea18d.png?x-oss-process=image%2Fresize%2Cw_657%2Climit_0#averageHue=%23f9f8f8&amp;from=url&amp;id=fyRJ7&amp;originHeight=382&amp;originWidth=657&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="情况2-解决方案"><a href="#情况2-解决方案" class="headerlink" title="情况2 - 解决方案"></a>情况2 - 解决方案</h5><p>问题的本质是判断锁value和删除锁是两个动作，不具备原子性！<br />可以使用redis lua脚本，将多个redis 命令放到一个脚本中，整个脚本的执行具有原子性。<br />Lua语言是轻量级脚本语言，很方便嵌入各种应用程序中。<br /><a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a><br />Lua脚本可以使用redis.call 调用redis命令，并支持传递动态参数：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662052994671-0557ed25-ed75-4aec-8341-e91371d3647c.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23d1d6ca&amp;from=url&amp;id=KRx2S&amp;originHeight=380&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>用Lua脚本释放锁脚本如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662093874892-f64e6e31-c729-45af-83c1-e5a4b04363b0.png?x-oss-process=image%2Fresize%2Cw_546%2Climit_0#averageHue=%230f2332&amp;from=url&amp;id=VppHF&amp;originHeight=132&amp;originWidth=546&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="Redis分布式锁的实现思路"><a href="#Redis分布式锁的实现思路" class="headerlink" title="Redis分布式锁的实现思路"></a>Redis分布式锁的实现思路</h5><ul>
<li>利用set nx ex 获取锁，nx确保互斥，只有一个线程能拿到锁，ex兜底，过期锁自动删除</li>
<li>释放锁时先判断线程标识是否和自己一致，一致则删除。</li>
</ul>
<p>特性：</p>
<ul>
<li>利用set nx ex 满足互斥性</li>
<li>利用set ex保证故障时依然可以释放，避免死锁</li>
<li>利用Redis集群保证高可用和高并发<h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h5 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h5>除了误删之外，现在的分布式锁实现还存在以下几个问题:</li>
</ul>
<ol>
<li>不可重入:同一个线程无法获取同一把锁（递归调用或调用的子函数抢同一把锁时就会出现死锁)</li>
<li>不可重试:没抢到锁就失败了</li>
<li>超时释放:业务未执行完，锁就超时释放了</li>
<li>主从一致性:主节点设置锁成功，还未及时同步到从节点，这时主节点宕机，从节点被选为主节点。但此时从</li>
</ol>
<p>节点还没有锁，仍可以抢锁成功。</p>
<p>要自己解决这些问题，非常麻烦，所以我们一般会选择现成的类库，比如Redisson。</p>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson 是java的Redis高级客户端，提供了各种现成的分布式工具类方便我们使用Redis<br />中文文档：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></p>
<p>1）引入独立的Redisson包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2)创建一个Redisson客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redisson 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 22603</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setPassword(password).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>3)使用Redisson的lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + id);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line"><span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许同一用户重复下单!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">TbVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h5><p>目的：保证同一个线程可以多次获取同一把锁<br />解决思路：在锁的value中额外保存当前线程获取锁的次数，每次获取锁+1，释放锁-1，当次数为0时真正可以了删除key</p>
<p>Redisson 底层也是通过lua脚本实现可重入锁</p>
<p>采用hash结构来存储锁信息：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662098121346-c34758fa-9b99-412a-9b42-6fe8cd30bda3.png#averageHue=%23e0e0e2&amp;from=url&amp;id=bFEXY&amp;originHeight=232&amp;originWidth=450&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>流程：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662097922411-4ba1a8d5-e402-4ddf-8596-b19f13a5f216.png?x-oss-process=image%2Fresize%2Cw_389%2Climit_0#averageHue=%23e8dddb&amp;from=url&amp;id=iMT3a&amp;originHeight=417&amp;originWidth=389&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>注意：</p>
<ol>
<li>所有的判断和操作都需要使用Lua脚本来保证原子性</li>
<li>每次获取和释放锁时要重置锁的有效期，就像抢到新锁一样，给业务充分的执行时间</li>
</ol>
<p>获取锁的Lua脚本:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--获取锁的key</span></span><br><span class="line"><span class="keyword">local</span> key=key[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--获取线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> thread =ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--所得自动释放时间</span></span><br><span class="line"><span class="keyword">local</span> releaseTime= ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">--判断锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>,key)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--不存在，获取锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>,key,thread,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">--设置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,key,releaseTime)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--若锁存在  判断锁是否为自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>,key,thread)==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--是自己的，则统计数+1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>,key,thread,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">--设置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,key,releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">--返回结果</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>释放锁的Lua脚本<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---释放</span></span><br><span class="line"><span class="comment">--- Generated by Luanalysis</span></span><br><span class="line"><span class="comment">--- Created by 22603.</span></span><br><span class="line"><span class="comment">--- DateTime: 2023/6/10 9:34</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">---获取key</span></span><br><span class="line"><span class="keyword">local</span> key = Key[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--获取唯一标识</span></span><br><span class="line"><span class="keyword">local</span> thread = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--获取锁的自动释放时间</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">--判断锁是否为自己的锁</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, thread) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--是自己的锁，则冲入次数-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, thread, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">--如果</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, Key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h5 id="如何实现重试获取锁？"><a href="#如何实现重试获取锁？" class="headerlink" title="如何实现重试获取锁？"></a>如何实现重试获取锁？</h5><p>基于redis pub/sub发布订阅机制，如果获取锁失败，则阻塞订阅释放所得消息，当锁被释放时，会触发推送（告诉其他线程我释放锁），然后其他线程再重试获取，如此以往，直到超时。</p>
<h5 id="如何防止锁提前释放？"><a href="#如何防止锁提前释放？" class="headerlink" title="如何防止锁提前释放？"></a>如何防止锁提前释放？</h5><p>基于看门狗机制，如果不手动设置释放时间，默认设置30s过期，并且给当前锁注册一个定时任务，该定时任务每隔1/3的锁释放时间（一般是10s），会重置锁的过期时间（递归调用，一次续期完了再）。</p>
<p>需要考虑两个问题：</p>
<ol>
<li>如何保证同一个锁只注册一个定时任务？</li>
<li>如何防止无线续期？</li>
</ol>
<p>要解决这些问题，使用全局ConcurrentHashMap来管理锁=&gt;任务信息，key为锁的id，从而保证唯一，当某个锁释放时，从全局ConcurrentHashMap中取处定时任务并取消，然后把锁的消息从Map中删除即可。</p>
<p>最终，完整的分布式锁流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662120120114-c6cb6b96-0d32-4d1d-9d70-63f20fdc1ace.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fcfcfc&amp;from=url&amp;id=Ksuix&amp;originHeight=354&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="Redisson主从一致性问题"><a href="#Redisson主从一致性问题" class="headerlink" title="Redisson主从一致性问题"></a>Redisson主从一致性问题</h5><p>如果使用主从复制的多台redis集群，可能出现主从节点设置的锁状态不一致的问题。<br />可以使用Redisson的MultiLock（联锁）来解决，核心思想是开启多个独立的Redis主节点，设置锁时必须在所有的主节点都写入成功，才算设置成功。</p>
<p>这样做哪怕有部分节点挂掉，其他线程也无法setnx全部成功，就不会出现重复执行业务的问题。</p>
<p>如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662135970012-219beab6-83e4-47f2-b6c3-490875f31be3.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f0ece3&amp;from=url&amp;id=tGbsi&amp;originHeight=285&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />实现MultiLock的几个关键：</p>
<ol>
<li>遍历所有节点，依次设置锁，并使用列表记录所有主节点的锁是否设置成功。</li>
<li>只要有一个节点设置不成功，就要释放锁，从头来过。</li>
<li>因为不同节点设置成功的时间不同，所以所有锁设置成功后，要统一设置过期时间（但如果leaseTime=-1就不用设置，因为开启了看门狗机制会自动续期）</li>
<li>释放锁时间（leasetime）必须要大于抢锁最大等待时间（waitTime），否则可能出现第一个节点抢到锁，最后一个节点还没抢到锁，之前的锁已经超时释放了，所有如果指定了waitTime和leaseTime，默认leasetime=waitTime*2</li>
</ol>
<p>MultiLock最安全，但同样会带来很大的运维成本。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686564559708-ccbd6909-113b-4f75-919f-c3fed1d2d1e8.png#averageHue=%23ebebeb&amp;clientId=uaaefd9b4-4e39-4&amp;from=paste&amp;height=353&amp;id=u897e08d6&amp;originHeight=530&amp;originWidth=633&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=120131&amp;status=done&amp;style=none&amp;taskId=u72602ece-0e50-40f4-afaf-ab2d7877c36&amp;title=&amp;width=422" alt="1686564553020.png"></p>
<h3 id="秒杀业务优化"><a href="#秒杀业务优化" class="headerlink" title="秒杀业务优化"></a>秒杀业务优化</h3><p>优化思路：</p>
<ul>
<li>串行改并行：原本由一个线程的操作改为由两个或多个线程同时执行，比如一个线程负责判断秒杀资格，一个线程负责减库存+创建订单（写操作）</li>
<li>同步改异步：判断完秒杀资格后，就可以返回订单id给前端，其余的写操作可以异步执行。</li>
<li>提高判断秒杀资格的性能：读DB改为读redis</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662138152995-d16f2727-c4d9-40da-bf39-065150d7ed0a.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fcfcfc&amp;from=url&amp;id=Xr5II&amp;originHeight=347&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>优化后的流程如下：<br />1）将库存信息提前缓存到redis中，并使用set来记录用户是否下单，实现仅在redis里判断秒杀资格<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662170418646-2bafd7db-ad02-43c9-a0e6-724fee09823c.png#averageHue=%23e5e6e5&amp;from=url&amp;id=D4uww&amp;originHeight=150&amp;originWidth=1416&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />2）将判断秒杀资格的逻辑封装为Lua脚本，保证原子性，原业务流程调用即可、<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686620752062-bb46f036-193d-4a86-bdaa-2041cb9bde4e.png#averageHue=%23f0efef&amp;clientId=uaaefd9b4-4e39-4&amp;from=paste&amp;height=253&amp;id=ua1d0de2c&amp;originHeight=379&amp;originWidth=551&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72363&amp;status=done&amp;style=none&amp;taskId=u3c4aa951-9ddf-41fb-acae-fe8f5005ce8&amp;title=&amp;width=367.3333333333333" alt="1686620746821.png"><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优惠卷id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 缓存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 1、判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 1.1 不充足直接返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 1.2 充足</span></span><br><span class="line"><span class="comment">-- 1.2.1 判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 买过返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 未买过返回 扣库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>,stockKey,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">--下单</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>,orderKey,userId);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>3）确认有秒杀资格后，将订单信息传递给阻塞队列，单个独立线程串行从队列中取出信息并异步下单<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662170512882-07909c3b-932c-4f8f-bbf8-16f5f6d9d83d.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f6f6f6&amp;from=url&amp;id=hED9d&amp;originHeight=288&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />这样一来，可以大大提高性能。<br />阻塞队列可以使用jdk原生的BlockingQueue实现，记得指定队列容量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TbSeckillVoucherService tbSeckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;TbVoucherOrder&gt; blockingDeque = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  提供了一系列方法来管理线程池和执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_SERVICE</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类加载完成后执行初始化任务</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHander</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化代理对象</span></span><br><span class="line">    <span class="keyword">private</span> TbVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    开启一个独立的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHander</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">TbVoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> blockingDeque.take();</span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;异步抢购失败:&quot;</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠卷秒杀优化</span></span><br><span class="line"><span class="comment">     * 串行改并行：原本由一个线程的操作改为由两个或多个线程同时执行</span></span><br><span class="line"><span class="comment">     * 比如一个线程负责判断秒杀资格，一个线程负责减库存+创建订单（写操作）</span></span><br><span class="line"><span class="comment">     * 同步改异步：判断完秒杀资格后，就可以返回订单id给前端，其余的写操作可以异步执行。</span></span><br><span class="line"><span class="comment">     * 提高判断秒杀资格的性能：读DB改为读redis</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//        1、执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString()</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//        2、判断结果为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//        2.1 不为0，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(value == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2.2 为0 ，有资格，把下单信息保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        2. 保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        获取代理对象</span></span><br><span class="line">        proxy = (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        tbVoucherOrder.setId(order);</span><br><span class="line">        tbVoucherOrder.setVoucherId(voucherId);</span><br><span class="line">        tbVoucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line"><span class="comment">//        将订单添加到阻塞队列中</span></span><br><span class="line">        blockingDeque.add(tbVoucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(TbVoucherOrder tbVoucherOrder)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        1.获取对象</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> tbVoucherOrder.getUserId();</span><br><span class="line"><span class="comment">//        2.获取锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line"><span class="comment">//        3.获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1L</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//        4.失败返回</span></span><br><span class="line">        <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        5.代理对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proxy.createVoucherOrder2(tbVoucherOrder);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder2</span><span class="params">(TbVoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//      获取订单数量</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> voucherOrder.getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, id).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;重复购买&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      扣减</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tbSeckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).ge(<span class="string">&quot;voucher_id&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.save(voucherOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="优惠卷秒杀"><a href="#优惠卷秒杀" class="headerlink" title="优惠卷秒杀"></a>优惠卷秒杀</h4><h5 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h5><p>流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/33551426/1686628797776-88c48a66-791d-4ee2-b01e-6afd10874035.jpeg" alt=""></p>
<p>代码逻辑：</p>
<ol>
<li>判断秒杀是否开始</li>
<li>判断库存</li>
<li>单机情况下为解决超卖问题，为确保原子性，将获取订单数量、判断是否购买、扣减、保存订单信息等和数据库相关的写操作加悲观锁</li>
<li>分布式情况下，为实现带来的数据不一致性问题，采用分布式锁实现<img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662030241202-f47dd469-1d9b-4df5-9f26-092d2730d984.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0%2Fresize%2Cw_750%2Climit_0#averageHue=%23efeded&amp;from=url&amp;id=NbM4S&amp;originHeight=341&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></li>
</ol>
<p>代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TbSeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> tbSeckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//      ① synchronized 单机实现   锁的整个方法</span></span><br><span class="line"><span class="comment">//        synchronized (id.toString().intern()) &#123;</span></span><br><span class="line"><span class="comment">//            获取事务代理对象</span></span><br><span class="line"><span class="comment">//            TbVoucherOrderService proxy = (TbVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line"><span class="comment">//            return proxy.createVoucherOrder1(voucherId);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//          ② 分布式实现  锁的整个方法</span></span><br><span class="line"><span class="comment">//        SimpleRedisLock simpleRedisLock = new SimpleRedisLock(&quot;order:&quot; + id, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + id);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1L</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许同一用户重复下单!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">TbVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder1(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式解决优惠卷秒杀</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder1</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//      获取订单数量</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, id).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;该用户已购买一次!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      扣减</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tbSeckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).ge(<span class="string">&quot;voucher_id&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        tbVoucherOrder.setId(order);</span><br><span class="line">        tbVoucherOrder.setVoucherId(voucherId);</span><br><span class="line">        tbVoucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.save(tbVoucherOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h5 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h5><ol>
<li>将秒杀功能中对优惠卷信息 、订单信息缓存到redis中，为了数据的原子性，通过使用Lua脚本，来进行对redis中优惠卷以及订单信息的判断，最终，若用户首次购买，则将优惠卷信息添加到阻塞队列中，然后返回订单id。</li>
<li><p>异步开启一个独立的线程，去读取阻塞队列中的优惠卷信息，然后进行减库存以及保存订单信息等对数据库的写操作。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>jdk阻塞队列可能存在哪些问题？</p>
</li>
<li><p>服务器宕机，内存队列的订单信息全部丢失</p>
</li>
<li>线程处理错误，已读出单个订单信息，但是没有入库</li>
<li>受单个jvm内存限制</li>
</ol>
<p>所有，我们需要一个独立的队列来存管订单信息，也就是消息队列。</p>
<h4 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h4><p>存管消息的队列，也是一种开发常用的中间件。<br />消息队列包括三个角色：</p>
<ol>
<li>消息队列：用于存放消息，类似于快递柜</li>
<li>生产者：发送消息到队列，类似快递员</li>
<li>消费者：从队列取走消息，类似于取快递的人</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662173544679-5086e788-493d-49ee-9ec3-81094b25119f.png#averageHue=%23a2b96c&amp;from=url&amp;id=sjkEg&amp;originHeight=180&amp;originWidth=1596&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>使用消息队列的优点：</p>
<ul>
<li>可以确保消息的安全、不丢失（快递柜上锁）</li>
<li>可以解藕生产者和消费者（不用立刻去取快递）</li>
<li>独立组件，不影响jvm</li>
<li>可以保证消息一定被接受，避免线程处理错误后订单丢失的问题</li>
<li>消息是有序的</li>
</ul>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="Redis-List实现"><a href="#Redis-List实现" class="headerlink" title="Redis List实现"></a>Redis List实现</h5><p>使用Redis List 的结构作为消息队列，使用LPush模拟生产者发送消息入队，使用BRPOP模拟消费者取出消息，没有消息时会保持阻塞状态，从而实现类似jvm阻塞队列的效果</p>
<p>可以满足消息队列的安全性（redis的持久化机制）、有序、独立内存的要求。<br />缺点：</p>
<ol>
<li>只能存在单消费者</li>
<li>消息获取之后就删除了，无法保证业务一定办理成功</li>
</ol>
<h5 id="Redis-Pub-Sub"><a href="#Redis-Pub-Sub" class="headerlink" title="Redis Pub/Sub"></a>Redis Pub/Sub</h5><p>使用Redis的订阅发布模式，生产者可以将消息推送给某个channel，多个消费者可以订阅该频道，从而同时得到消息。<br />用的命令是：</p>
<ul>
<li>Publish 推送</li>
<li>SubScribe 订阅</li>
<li>PSubScribe 订阅某个表达式匹配的多个频道</li>
</ul>
<p>这样就可以实现多生产、多消费。也很灵活，一条消息可以发送给一个消费者，也可以发送给多个消费者。<br />缺点：</p>
<ol>
<li>Pub/Sub是一次性的，Redis不会保存发过的消息，没人收消息就会丢失。</li>
<li>因为上一点，无法做到持久化</li>
<li>客户端虽然可能会缓存收到的消息，但是也有上限，可能还是会丢失消息</li>
</ol>
<p><strong>不建议使用</strong><br /><strong> </strong></p>
<h5 id="Redis-Stream"><a href="#Redis-Stream" class="headerlink" title="Redis Stream"></a>Redis Stream</h5><p>redis 5.0 新推出的数据结构，可以实现单向的消息队列。<br />核心命令：</p>
<ul>
<li>XADD：添加消息/创建队列，消息会自动持久化，不用担心丢失，每隔消息都有唯一的全局唯一id</li>
<li>XRead：消息可回溯，支持多消费者读，可以指定消息id开始读，支持阻塞读最新消息，有漏读风险。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686735365106-bf4c07a6-f9ba-45c1-a20d-f9c99fb09f5a.png#averageHue=%23122a3d&amp;clientId=u1469bab5-7119-4&amp;from=paste&amp;height=192&amp;id=uffd1de90&amp;originHeight=211&amp;originWidth=1024&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=234565&amp;status=done&amp;style=none&amp;taskId=u6408a1e3-4094-42cc-a3b3-15e57f9b323&amp;title=&amp;width=930.9090707321802" alt="4_QC8`J7$%BO_57N$%CO)]8.png"><br />只有这两个命令不够，因为目前只支持阻塞读最新消息，假设处理消息过程又来几条消息，可能出现漏读情况。<br />为解决上述问题，可以使用Stream的以下特性：</p>
<ul>
<li>消费组：同组的多个消费者可以竞争消费，从而提升消费能力。对应命令为XGROUP、XREADGROUP</li>
<li>消费标识：自动记录消费进度，支持从上次未消费的地方开始接着消费，保证每个消息都能按顺序消费</li>
<li>消息确认机制：默认消费的消息未pending状态，会放到每个消费者的pending list中，只有消息由消费者确认(ACK)，才会从pending list移除，这样如果消费业务处理异常，可以从pending list开头依次读取未确认的消息，重试处理。（也需要避免无线重试，实在处理不成功，就强制ACK+业务记录日志）</li>
</ul>
<p>整个消费流程：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686735706416-d04cc86a-5092-4121-b21a-6e39008aa0e4.png#averageHue=%23eeeff3&amp;clientId=u1469bab5-7119-4&amp;from=paste&amp;height=487&amp;id=u987986b6&amp;originHeight=536&amp;originWidth=591&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=125950&amp;status=done&amp;style=none&amp;taskId=u5340fbbd-5fe4-4a21-b424-8daf60da509&amp;title=&amp;width=537.2727156276547" alt="0)ZOX05G0VUWU~Q~ZRA~SQU.png"><br />在java中操作Redis Strean 两种方法：</p>
<ol>
<li>调用Lua脚本</li>
<li>使用Redis Template 的 opsForStrean（）</li>
</ol>
<p>方案对比：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662187826716-5ff99aa2-fb34-49b8-9795-acb6f925a4b1.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f9f7f4&amp;from=url&amp;id=BvmOl&amp;originHeight=331&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>注意，redis 虽然可以实现较为完备的消息队列，但还是不如专业的消息队列Kafka，RabbitMQ，RocketMQ专业，比如持久化能力差，不支持生产确认，顺序消费性等。</p>
<h5 id="抢购优惠卷业务终极版"><a href="#抢购优惠卷业务终极版" class="headerlink" title="抢购优惠卷业务终极版"></a>抢购优惠卷业务终极版</h5><ol>
<li><p>redis创建消息队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接redis服务器</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment">// 认证</span></span><br><span class="line">redis-cli -h &lt;<span class="number">124.221</span><span class="number">.169</span><span class="number">.181</span>&gt; -p &lt;<span class="number">3306</span>&gt;</span><br><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line">XGROUP CREATE Stream.orders orders <span class="number">0</span> MKSTREAM</span><br><span class="line"><span class="comment">// 查看消息队列信息</span></span><br><span class="line">XINFO STREAM Stream.orders</span><br></pre></td></tr></table></figure>
</li>
<li><p>lua脚本，将判断库存，判断用户下单等操作封装到lua脚本中，如果用户没有下单就在redis中扣库存，把订单消息存储到redis中，同时将这个消息发送到队列中，队列采用的是Stream模式，然后返回</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在java逻辑代码中，首先进入seckillVoucher接口，然后先执行lua脚本，对于返回结果判断，无购买资格则返回，有购买资格则获取代理对象后返回，通过在类加载完成后初始化的异步线程中，获取消息失败则循环监听消息队列，获取消息队列中的消息后，解析其中的订单信息，然后进行下单，下单成功后返回通过ack消息确认机制进行确认后，将订单消息从队列中删除，抢购失败，则打印日志并获取消息队列中的失败的消息，再次进行消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;TbVoucherOrder&gt; blockingDeque = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化代理对象</span></span><br><span class="line">    <span class="keyword">private</span> TbVoucherOrderService proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  提供了一系列方法来管理线程池和执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_SERVICE</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">VoucherOrderHander</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    获取消息队列中的消息</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream()</span><br><span class="line">                            .read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>), StreamReadOptions.empty()</span><br><span class="line">                                    .count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)), StreamOffset.create(queueName, ReadOffset.lastConsumed()));</span><br><span class="line"><span class="comment">//                    判断是否获取成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    解析消息 中的订单信息</span></span><br><span class="line">                    Map&lt;Object, Object&gt; value = list.get(<span class="number">0</span>).getValue();</span><br><span class="line">                    <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//                    如果成功 可以下单</span></span><br><span class="line">                    handleVoucherOrder(tbVoucherOrder);</span><br><span class="line"><span class="comment">//                    ack确认</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, list.get(<span class="number">0</span>).getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;异步抢购失败:&quot;</span> + e);</span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    获取消息队列中的消息</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream()</span><br><span class="line">                            .read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>), StreamReadOptions.empty()</span><br><span class="line">                                    .count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)), StreamOffset.create(queueName, ReadOffset.from(<span class="string">&quot;0&quot;</span>)));</span><br><span class="line"><span class="comment">//                    判断是否获取成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//                       失败说明pendinglist中没有消息，直接结束</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    解析消息 中的订单信息</span></span><br><span class="line">                    Map&lt;Object, Object&gt; value = list.get(<span class="number">0</span>).getValue();</span><br><span class="line">                    <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//                    如果成功 可以下单</span></span><br><span class="line">                    handleVoucherOrder(tbVoucherOrder);</span><br><span class="line"><span class="comment">//                    ack确认</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, list.get(<span class="number">0</span>).getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;异步抢购失败:&quot;</span> + e);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠卷秒杀优化</span></span><br><span class="line"><span class="comment">     * 串行改并行：原本由一个线程的操作改为由两个或多个线程同时执行</span></span><br><span class="line"><span class="comment">     * 比如一个线程负责判断秒杀资格，一个线程负责减库存+创建订单（写操作）</span></span><br><span class="line"><span class="comment">     * 同步改异步：判断完秒杀资格后，就可以返回订单id给前端，其余的写操作可以异步执行。</span></span><br><span class="line"><span class="comment">     * 提高判断秒杀资格的性能：读DB改为读redis</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"><span class="comment">//        1、执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(order));</span><br><span class="line"><span class="comment">//        2、判断结果为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//        2.1 不为0，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(value == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2.2 为0 ，有资格，把下单信息保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        2. 保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        获取代理对象</span></span><br><span class="line">        proxy = (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类加载完成后执行初始化任务</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHander</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h5><p>流程：</p>
<ol>
<li>判断用户是否已经点赞</li>
<li>更新DB点赞和点赞关系</li>
</ol>
<p>如果全部数据库操作，性能不高，可以把判断是否已经点赞、维护点赞关系的逻辑移至redis，只用更新数据库点赞即可</p>
<p>可以使用redis set结构，比如key=like:[帖子id],value为去重的已点赞用户id列表，就可以判断是否已经点赞了。</p>
<blockquote>
<p>点赞功能的实现可能存在同时点赞的情况，可以参考秒杀优化的逻辑，使用分布式锁、或者lua脚本解决、操作DB的部分可以使用异步、队列之类的机制。</p>
</blockquote>
<p>使用分布式锁解决：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:like:&quot;</span> + userId);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MICROSECONDS)) &#123;</span><br><span class="line">               <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">               <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">                   <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">                   <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">                   <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">                   <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                       stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">                   <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">                   <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">                   <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">                   <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                       stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> Result.ok();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;点赞功能繁忙,请稍后重试!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h5><p>示例需求:展示最先给某个帖子点赞的TopN用户<br />实现:使用Redis SortedSet(自动按score排序的数据结构)，把用户点赞时间作为score即可，使用ZRange范围查询TopN。</p>
<p>点赞排行榜存在的坑：</p>
<ol>
<li>将点赞用户按时间戳插入redis的zset中时，存在sorce分数高的排在上面，分数低的自动往后移，这里查找了网上关于zset的教程，查询排名时以升序排序（ score 越大排名越靠后），这里是因为quickredis自动排序了（踩了很久的坑），</li>
<li>从redis的Zset集合中拿到返回值后，原本的顺序就是点赞的顺序，但是在mapper文件中使用in以及 foreach标签时，会自动对集合中的数据进行排序后，再进行查询，就会导致排行榜点赞顺序与我们的预期不符，在mapper中写sql时通过order by find_in_set(id, #{idStr})实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">bloglikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">      Set&lt;String&gt; range = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> (!Optional.ofNullable(range).isPresent())&#123;</span><br><span class="line">          <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;Integer&gt; ids = range.stream().map(Integer::valueOf).collect(Collectors.toList());</span><br><span class="line">      List&lt;UserDTO&gt; userDTOS = userMapper.getTopfiveByIds(ids).stream()</span><br><span class="line">.map(tbUser -&gt; BeanUtil.copyProperties(tbUser, UserDTO.class))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">      <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getTopfiveByIds&quot; resultType<span class="operator">=</span>&quot;com.xiaozhang.entity.domain.TbUser&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;Base_Column_List&quot;<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="operator">/</span>include<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="keyword">in</span></span><br><span class="line">    <span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;ids&quot; item<span class="operator">=</span>&quot;id&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot; separator<span class="operator">=</span>&quot;,&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot;<span class="operator">&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> find_in_set(id, #&#123;idStr&#125;)</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h5><p>需求:计算两个人共同关注的所有用户思路:本质就是求两个用户关注集合的交集<br />实现:使用Redis Set数据结构，每个key保存1个用户的关注集合(取关时从集合中移除对应用户)，最后对2个用户对应的set进行intersect取交集操作即可</p>
<h4 id="Feed流关注推送"><a href="#Feed流关注推送" class="headerlink" title="Feed流关注推送"></a>Feed流关注推送</h4><p>up主发布新内容，系统给粉丝发送消息</p>
<p>何为feed流？<br />feed流是指无线下拉刷新的内容列表，给用户沉浸式的体验</p>
<p>两种模式：</p>
<ol>
<li>Timeline 时间线模式：所有内容按时间顺序展示，比如朋友圈</li>
<li>智能排序模式：根据一定算法推荐用户感兴趣的内容，比如现在的视频网站</li>
</ol>
<p>解决问题：如何将关注用户的新内容展示到Feed流中？</p>
<h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><p>1）拉模式：用户上线打开Feed流时，再获取up推送的内容（主动拉取，比较耗时）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199526960-ad74c98d-869d-454a-88be-06f0bbf6e236.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fcfcfc&amp;from=url&amp;id=N4ZjD&amp;originHeight=381&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />2）推模式：up主发布内容时，直接把内容推送到所有粉丝内容列表里，（粉丝多的大up主写入时很占资源）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199531728-ab03c11f-4c34-4758-85c0-d97db0eb17a1.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fdfdfd&amp;from=url&amp;id=IfDjO&amp;originHeight=473&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>3）推拉结合<br />推模式：粉丝少的up、推送给活跃用户<br />拉模式：粉丝多的up&amp;&amp;推给非活跃用户<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199536976-2a8e6360-4eb0-45b4-8d5d-ac35579b2271.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fbfbfb&amp;from=url&amp;id=pBlrT&amp;originHeight=408&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>各种方式的优缺点：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199523680-8bbeeea1-d638-420b-be70-4c7aa72b6e3f.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f8f5f3&amp;from=url&amp;id=zTLoY&amp;originHeight=330&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>一般系统的用户量级小的时候采用推模式，系统用户量大的时候采用推拉结合模式。</p>
<h5 id="推模式Redis实现"><a href="#推模式Redis实现" class="headerlink" title="推模式Redis实现"></a>推模式Redis实现</h5><p>因为推送是按照时间排序的，所有可以使用sortedSet数据结构来保存，每一个key表示一个用户的收件箱，value为推送id，sorce为推送时间戳。</p>
<p>分页问题：<br />每条消息都会动态变化，导致数据重复查询，如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662258685043-daec4891-e0b5-4034-b784-e41dd23aaef6.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f9f8f8&amp;from=url&amp;id=F6TOy&amp;originHeight=486&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />因此，可以使用滚动分页，记录每次当前时间戳的下一条开始查询，如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662258695058-1cf81cf7-601e-4aeb-8941-bb97f89cc444.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f9f9f8&amp;from=url&amp;id=fIn1U&amp;originHeight=497&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />可以使用sortedset的zrevrangeBysorce 命令实现，每次查询指定时间戳范围（0，当前最大时间戳）的指定条数的数据。示例命令：<br />ZRevRangeByScore key 0 maxTimeStamp offset limit。<br />注意有个问题，可能出现相同时间戳的数据，因此第一次查询时 offset 为 0（从第一条开始查），之后每次查询，offset 为上一页中时间戳最小值的数量，保证不查出重复数据。<br />比如 score 列表为：5, 4, 4, 3, 2, 1。每页 3 条。<br />第一次查询 ZRevRangeByScore key 0 9999999 0 3 查出 5、4、4，最小值 4 重复 2 次，即下一次的最大值为 4、offset 为 2。<br />所以第二次查询为 ZRevRangeByScore key 0 4 2 3 查出 3、2、1</p>
<h4 id="GEO-地理坐标计算"><a href="#GEO-地理坐标计算" class="headerlink" title="GEO 地理坐标计算"></a><br />GEO 地理坐标计算</h4><p><br />P88 - P90<br />Redis 支持 GEO 数据结构，可用于存储多个地理坐标、计算坐标间的距离，计算某坐标半径范围内的其他点和距离（实现附近的人）。<br />GEO 底层是 SortedSet 类型<br />支持以下命令：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662259856441-adec18e0-f19f-4839-8138-0e207f66fdaa.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f1f1f1&amp;from=url&amp;id=Ag5GV&amp;originHeight=391&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="查附近"><a href="#查附近" class="headerlink" title="查附近"></a>查附近</h5><p><br />需求：查询你附近所有的小姐姐，以及每个小姐姐和你的距离，并且按照距离由近到远排序<br />实现：<br />1使用 GEOADD 添加所有小姐姐的 id 和位置到一个 key 中<br />2使用 GEOSEARCH 查询以你当前坐标为中心、指定距离内的所有小姐姐，默认返回的就是由近及远的 SortedSet（value 为 id、score 为和你的距离）<br />小技巧：<br />如果我们要根据分类来计算同组内的距离及排名，可以每个类别一个独立的 key，如图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662261432855-a5b54817-a81d-42a7-9864-7d3a7a52d6de.png?x-oss-process=image%2Fresize%2Cw_533%2Climit_0#averageHue=%23b8beb4&amp;from=url&amp;id=lwz8E&amp;originHeight=280&amp;originWidth=533&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a><br /><br />BitMap</h4><p><br />多个二进制位组成的数据结构，每个二进制位对应一个业务的两种互斥状态。比如：10010011。<br />BitMap 的优点是可以用最小的代码（1 个 bit）来保存业务含义，从而大幅节省空间、实现高效运算等。比如可以把某个二进制位从 0 改为 1。<br />底层是 string 类型，以字节为单位存储，所以 bit 的长度为 8 的倍数</p>
<p>命令：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662263399913-82c17736-6b4f-4bbc-910f-392b016a86ce.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f2f2f2&amp;from=url&amp;id=eZvuB&amp;originHeight=428&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a><br /><br />签到功能</h5><p><br />这是 BitMap 的一个经典应用场景。<br />如果使用传统数据库来记录用户某日签到状态，每次签到对应 1 行数据，那么将占用几百 byte 的空间。用户量大了后，占用的内存不可估量。<br />而使用 BitMap，可以用每一个二进制位表示当天的签到状态，0 表示用户已签到、1 表示用户未签到，如下图：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662263817244-d2e78caf-38b9-490f-8b9b-756d4cdec63f.png#averageHue=%23faf9f9&amp;from=url&amp;id=erBjw&amp;originHeight=352&amp;originWidth=1442&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>只用 31 bit，就能表示某用户 1 个月的签到状态。<br />其原理就类似于签到卡，用户可以在一张签到卡上同时对多个不同的日期进行签到，从而避免了重复的用户签名、重复去写日期。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662264055714-e9977747-f48d-4e69-96b5-06189f31394e.png?x-oss-process=image%2Fresize%2Cw_225%2Climit_0#averageHue=%23dbd9aa&amp;from=url&amp;id=dUM08&amp;originHeight=408&amp;originWidth=225&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a><br /><br />基本实现</h5><h5 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h5><p><br />用 BITSET 设置某一天对应位置的 bit 值即可，需要查询签到状态时可以用 BITFIELD GET 取出整个 BitMap 的十进制值，再用 位运算 将十进制值转为业务需要的格式。</p>
<h5 id="统计连续签到天数"><a href="#统计连续签到天数" class="headerlink" title="统计连续签到天数"></a><br />统计连续签到天数</h5><p><br />可以先用 BITFIELD GET 取出整个 BitMap 的十进制值。然后循环右移，依次用 1 去和 BitMap 的最后一位进行 <strong>与运算</strong>，即可得知当前位数是否为 1（已签到），配合计数器完成连续 1 的统计。<br />示例代码如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662265366088-f364fe64-cc67-427b-a9d9-7e216c6c7bc8.png?x-oss-process=image%2Fresize%2Cw_790%2Climit_0#averageHue=%23f4f8f1&amp;from=url&amp;id=ifTpB&amp;originHeight=346&amp;originWidth=790&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>注意，循环右移一定要用 &gt;&gt;&gt;（无符号右移，高位补 0），否则可能会死循环。</p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><br />HyperLogLog</h4><p><br />HyperLogLog（HLL）是 Redis 的高级数据结构，使用概率学算法实现，可以用极低的内存实现不重复元素个数的统计。<br />用法和集合类似，插入元素、求不重复元素个数、合并多个 HLL 等：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662270538754-0a2ec2e5-c32c-42cc-9cfc-d5650fbc7c0f.png?x-oss-process=image%2Fresize%2Cw_840%2Climit_0#averageHue=%23102136&amp;from=url&amp;id=MHeHm&amp;originHeight=281&amp;originWidth=840&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>
<p>优点：占用内存极低，不会超过 16 Kb<br />缺点：基于概率统计，存在 &lt; 0.81% 的误差<br />因此，它很适合用于 UV、PV 等数据量大、精度要求不高的统计。</p>
<h5 id="UV-PV-统计"><a href="#UV-PV-统计" class="headerlink" title="UV / PV 统计"></a><br />UV / PV 统计</h5><p><br />只需要把用户 id 用 PFADD 添加到 HLL 中，用 PFCOUNT 求值即可；还可以用 PFMERGE 合并多天的统计，来估算整月的 UV。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com">小张</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2022/12/24/Redis%E7%AC%94%E8%AE%B0/">https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2022/12/24/Redis笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com" target="_blank">keep Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/./img/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记"><img class="cover" src="/./img/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/24/Mysql/" title="Mysql笔记"><img class="cover" src="/./img/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mysql笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/24/Mysql/" title="Mysql笔记"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-24</div><div class="title">Mysql笔记</div></div></a></div><div><a href="/2023/09/12/SpringCloud01/" title="SpringCloudDay1"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">SpringCloudDay1</div></div></a></div><div><a href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/" title="SpringCloudDay2"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-14</div><div class="title">SpringCloudDay2</div></div></a></div><div><a href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">RabbitMQ笔记</div></div></a></div><div><a href="/2021/09/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="java基础知识"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-17</div><div class="title">java基础知识</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODc3NS8zNTIzNw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小张</div><div class="author-info__description">记录代码日常</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://keepcheerful.github.io/" target="_blank" title="Github"><i class="iconfont icon-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81redis%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">一、redis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">redis介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%89%B9%E5%BE%81"><span class="toc-number">1.2.</span> <span class="toc-text">Redis特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.</span> <span class="toc-text">Redis常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">通用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Redis 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.4.</span> <span class="toc-text">Set类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.5.</span> <span class="toc-text">SortedSet类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.6.</span> <span class="toc-text">Redis 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.6.1.</span> <span class="toc-text">主流客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Data-Redis"><span class="toc-number">1.6.2.</span> <span class="toc-text">Spring Data Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedisTemplate-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.6.3.</span> <span class="toc-text">RedisTemplate 序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%ABSession%EF%BC%88%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">共享Session（单点登录）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E7%94%A8%E4%BD%95%E7%A7%8Dvalue%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%94%BE%E5%85%A5%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-number">1.7.3.</span> <span class="toc-text">选用何种value数据结构放入用户信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.7.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">1.8.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">缓存更新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3"><span class="toc-number">1.9.</span> <span class="toc-text">问题及解决</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.9.2.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.9.3.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.9.4.</span> <span class="toc-text">封装工具类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90"><span class="toc-number">1.10.</span> <span class="toc-text">分布式全局ID生成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">设计实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E6%B5%81%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">优惠券秒杀流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E5%8D%95%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.12.</span> <span class="toc-text">订单超卖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">1.13.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.13.1.</span> <span class="toc-text">单机实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.13.2.</span> <span class="toc-text">分布式实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.14.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.14.1.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">Redis 分布式锁实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AF%E5%88%A0%E6%83%85%E5%86%B5"><span class="toc-number">1.14.3.</span> <span class="toc-text">误删情况</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B51"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">情况1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B51%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">情况1解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B52"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">情况2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B52-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.14.3.4.</span> <span class="toc-text">情况2 - 解决方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">1.14.3.5.</span> <span class="toc-text">Redis分布式锁的实现思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.14.3.6.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.3.7.</span> <span class="toc-text">其他问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-number">1.15.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%9F"><span class="toc-number">1.15.0.1.</span> <span class="toc-text">如何实现可重入锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%87%8D%E8%AF%95%E8%8E%B7%E5%8F%96%E9%94%81%EF%BC%9F"><span class="toc-number">1.15.0.2.</span> <span class="toc-text">如何实现重试获取锁？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E9%94%81%E6%8F%90%E5%89%8D%E9%87%8A%E6%94%BE%EF%BC%9F"><span class="toc-number">1.15.0.3.</span> <span class="toc-text">如何防止锁提前释放？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redisson%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.15.0.4.</span> <span class="toc-text">Redisson主从一致性问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1%E4%BC%98%E5%8C%96"><span class="toc-number">1.16.</span> <span class="toc-text">秒杀业务优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80"><span class="toc-number">1.16.1.</span> <span class="toc-text">优惠卷秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.16.1.1.</span> <span class="toc-text">原始方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">1.16.1.2.</span> <span class="toc-text">优化思路：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.17.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">1.17.1.</span> <span class="toc-text">什么是消息队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.17.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-List%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.17.2.1.</span> <span class="toc-text">Redis List实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-Pub-Sub"><span class="toc-number">1.17.2.2.</span> <span class="toc-text">Redis Pub&#x2F;Sub</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-Stream"><span class="toc-number">1.17.2.3.</span> <span class="toc-text">Redis Stream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A2%E8%B4%AD%E4%BC%98%E6%83%A0%E5%8D%B7%E4%B8%9A%E5%8A%A1%E7%BB%88%E6%9E%81%E7%89%88"><span class="toc-number">1.17.2.4.</span> <span class="toc-text">抢购优惠卷业务终极版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-number">1.17.2.5.</span> <span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E%E6%8E%92%E8%A1%8C%E6%A6%9C"><span class="toc-number">1.17.2.6.</span> <span class="toc-text">点赞排行榜</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E5%85%B3%E6%B3%A8"><span class="toc-number">1.17.2.7.</span> <span class="toc-text">共同关注</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Feed%E6%B5%81%E5%85%B3%E6%B3%A8%E6%8E%A8%E9%80%81"><span class="toc-number">1.17.3.</span> <span class="toc-text">Feed流关注推送</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-number">1.17.3.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A8%E6%A8%A1%E5%BC%8FRedis%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.17.3.2.</span> <span class="toc-text">推模式Redis实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GEO-%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97"><span class="toc-number">1.17.4.</span> <span class="toc-text">GEO 地理坐标计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E9%99%84%E8%BF%91"><span class="toc-number">1.17.4.1.</span> <span class="toc-text">查附近</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BitMap"><span class="toc-number">1.17.5.</span> <span class="toc-text">BitMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%BE%E5%88%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">1.17.5.1.</span> <span class="toc-text">签到功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.17.5.2.</span> <span class="toc-text">基本实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-1"><span class="toc-number">1.17.5.3.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E8%BF%9E%E7%BB%AD%E7%AD%BE%E5%88%B0%E5%A4%A9%E6%95%B0"><span class="toc-number">1.17.5.4.</span> <span class="toc-text">统计连续签到天数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">1.17.6.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#UV-PV-%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.17.6.1.</span> <span class="toc-text">UV &#x2F; PV 统计</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/" title="SpringCloudDay2"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloudDay2"/></a><div class="content"><a class="title" href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/" title="SpringCloudDay2">SpringCloudDay2</a><time datetime="2023-09-14T02:29:58.000Z" title="发表于 2023-09-14 10:29:58">2023-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/12/hello-world/" title="Hello World"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2023/09/12/hello-world/" title="Hello World">Hello World</a><time datetime="2023-09-12T09:32:40.000Z" title="发表于 2023-09-12 17:32:40">2023-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/12/SpringCloud01/" title="SpringCloudDay1"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloudDay1"/></a><div class="content"><a class="title" href="/2023/09/12/SpringCloud01/" title="SpringCloudDay1">SpringCloudDay1</a><time datetime="2023-09-12T02:29:58.000Z" title="发表于 2023-09-12 10:29:58">2023-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RabbitMQ笔记"/></a><div class="content"><a class="title" href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记">RabbitMQ笔记</a><time datetime="2023-07-24T02:29:58.000Z" title="发表于 2023-07-24 10:29:58">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis笔记"/></a><div class="content"><a class="title" href="/2022/12/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记">Redis笔记</a><time datetime="2022-12-24T02:29:58.000Z" title="发表于 2022-12-24 10:29:58">2022-12-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 小张</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div>本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img class="cdn" src="./img/youpaiyun.png" /></a>提供CDN加速/云储存服务<div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="/js/debounce.js" async></script><script src="/js/sun_moon.js" async></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script src="/js/footer.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><div id="music-player" class="aplayer no-destroy" data-id="8418044320" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script async src="/js/snow.js"></script><script src="/js/star.js"></script><script src="/js/copy.js"></script><script async src="/js/fps.js"></script><script src="/js/random.js"></script><script async src="//at.alicdn.com/t/c/font_4185042_s9i9e08l3w.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '982e2f357e344923beb3175e4b012b6d';
  var gaud_map_key = '2c2137f367e0748bc2e4317025f9ad38';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>