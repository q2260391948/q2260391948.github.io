<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringCloudDay2</title>
      <link href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/"/>
      <url>/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud实用篇02"><a href="#SpringCloud实用篇02" class="headerlink" title="SpringCloud实用篇02"></a>SpringCloud实用篇02</h1><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><h1 id="1-Nacos配置管理"><a href="#1-Nacos配置管理" class="headerlink" title="1.Nacos配置管理"></a>1.Nacos配置管理</h1><p>Nacos除了可以做注册中心，同样可以做配置管理来使用。</p><h2 id="1-1-统一配置管理"><a href="#1-1-统一配置管理" class="headerlink" title="1.1.统一配置管理"></a>1.1.统一配置管理</h2><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/20210714164426792.png" alt="image-20210714164426792"></p><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h3 id="1-1-1-在nacos中添加配置文件"><a href="#1-1-1-在nacos中添加配置文件" class="headerlink" title="1.1.1.在nacos中添加配置文件"></a>1.1.1.在nacos中添加配置文件</h3><p>如何在nacos中管理配置呢？</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714164742924.png" alt="image-20210714164742924"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/0714164856664.png" alt="image-20210714164856664"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h3 id="1-1-2-从微服务拉取配置"><a href="#1-1-2-从微服务拉取配置" class="headerlink" title="1.1.2.从微服务拉取配置"></a>1.1.2.从微服务拉取配置</h3><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：bootstrap.yaml文件，会在application.yml之前被读取，流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150916809.png" alt="img"></p><p>1）引入nacos-config依赖</p><p>首先，在user-service服务中，引入nacos-config的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）添加bootstrap.yaml</p><p>然后，在user-service中添加一个bootstrap.yaml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#开发环境，这里是dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150917632.png" alt="image-20210714170845901"></p><p>3）读取nacos配置</p><p>在user-service中的UserController中添加业务逻辑，读取pattern.dateformat配置：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150917431.png" alt="image-20210714170337448"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在页面访问，可以看到效果：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150917833.png" alt="image-20210714170449612"></p><h2 id="1-2-配置热更新"><a href="#1-2-配置热更新" class="headerlink" title="1.2.配置热更新"></a>1.2.配置热更新</h2><p>我们最终的目的，是修改nacos中的配置后，微服务中无需重启即可让配置生效，也就是<strong>配置热更新</strong>。</p><p>要实现配置热更新，可以使用两种方式：</p><h3 id="1-2-1-方式一"><a href="#1-2-1-方式一" class="headerlink" title="1.2.1.方式一"></a>1.2.1.方式一</h3><p>在@Value注入的变量所在类上添加注解@RefreshScope：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150918040.png" alt="image-20210714171036335"></p><h3 id="1-2-2-方式二"><a href="#1-2-2-方式二" class="headerlink" title="1.2.2.方式二"></a>1.2.2.方式二</h3><p>使用@ConfigurationProperties注解代替@Value注解。</p><p>在user-service服务中，添加一个类，读取patterrn.dateformat属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PatternProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UserController中使用这个类代替@Value：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150918131.png" alt="image-20210714171316124"></p><p>完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.web;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.config.PatternProperties;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.user.service.UserService;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PatternProperties patternProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">now</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(patternProperties.getDateformat()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-配置共享"><a href="#1-3-配置共享" class="headerlink" title="1.3.配置共享"></a>1.3.配置共享</h2><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h3 id="1）添加一个环境共享配置"><a href="#1）添加一个环境共享配置" class="headerlink" title="1）添加一个环境共享配置"></a>1）添加一个环境共享配置</h3><p>我们在nacos中添加一个userservice.yaml文件：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150918681.png" alt="image-20210714173233650"></p><h3 id="2）在user-service中读取共享配置"><a href="#2）在user-service中读取共享配置" class="headerlink" title="2）在user-service中读取共享配置"></a>2）在user-service中读取共享配置</h3><p>在user-service服务中，修改PatternProperties类，读取新添加的属性：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150919277.png" alt="image-20210714173324231"></p><p>在user-service服务中，修改UserController，添加一个方法：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150935943.png" alt="image-20210714173721309"></p><h3 id="3）运行两个UserApplication，使用不同的profile"><a href="#3）运行两个UserApplication，使用不同的profile" class="headerlink" title="3）运行两个UserApplication，使用不同的profile"></a>3）运行两个UserApplication，使用不同的profile</h3><p>修改UserApplication2这个启动项，改变其profile值：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150936142.png" alt="image-20210714173538538"></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150937904.png" alt="image-20210714173519963"></p><p>这样，UserApplication(8081)使用的profile是dev，UserApplication2(8082)使用的profile是test。</p><p>启动UserApplication和UserApplication2</p><p>访问<a href="http://localhost:8081/user/prop，结果：">http://localhost:8081/user/prop，结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150937830.png" alt="image-20210714174313344"></p><p>访问<a href="http://localhost:8082/user/prop，结果：">http://localhost:8082/user/prop，结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150937757.png" alt="image-20210714174424818"></p><p>可以看出来，不管是dev，还是test环境，都读取到了envSharedValue这个属性的值。</p><h3 id="4）配置共享的优先级"><a href="#4）配置共享的优先级" class="headerlink" title="4）配置共享的优先级"></a>4）配置共享的优先级</h3><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150938842.png" alt="image-20210714174623557"></p><h2 id="1-4-搭建Nacos集群"><a href="#1-4-搭建Nacos集群" class="headerlink" title="1.4.搭建Nacos集群"></a>1.4.搭建Nacos集群</h2><p>Nacos生产环境下一定要部署为集群状态，部署方式参考课前资料中的文档：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150938504.png" alt="image-20210714174728042"></p><h1 id="2-Feign远程调用"><a href="#2-Feign远程调用" class="headerlink" title="2.Feign远程调用"></a>2.Feign远程调用</h1><p>先来看我们以前利用RestTemplate发起远程调用的代码：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150938982.png" alt="image-20210714174814204"></p><p>存在下面的问题：</p><p>•代码可读性差，编程体验不统一</p><p>•参数复杂URL难以维护</p><p>Feign是一个声明式的http客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150939819.png" alt="image-20210714174918088"></p><h2 id="2-1-Feign替代RestTemplate"><a href="#2-1-Feign替代RestTemplate" class="headerlink" title="2.1.Feign替代RestTemplate"></a>2.1.Feign替代RestTemplate</h2><p>Fegin的使用步骤如下：</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>我们在order-service服务的pom文件中引入feign的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）添加注解"><a href="#2）添加注解" class="headerlink" title="2）添加注解"></a>2）添加注解</h3><p>在需要调用Feign客户端的模块中的启动类上加入@EnableFeignClients注解，如在order-service的启动类添加注解开启Feign的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150939629.png" alt="image-20210714175102524"></p><h3 id="3）编写Feign的客户端"><a href="#3）编写Feign的客户端" class="headerlink" title="3）编写Feign的客户端"></a>3）编写Feign的客户端</h3><p>在order-service中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="4）测试"><a href="#4）测试" class="headerlink" title="4）测试"></a>4）测试</h3><p>修改order-service中的OrderService类中的queryOrderById方法，使用Feign客户端代替RestTemplate：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150939585.png" alt="image-20210714175415087"></p><p>是不是看起来优雅多了。</p><h3 id="5）总结"><a href="#5）总结" class="headerlink" title="5）总结"></a>5）总结</h3><p>使用Feign的步骤：</p><p>① 引入依赖</p><p>② 添加@EnableFeignClients注解(在需要的模块中引入该注解，可以是编写客户端模块，也可以是调用客户端模块)</p><p>③ 编写FeignClient接口</p><p>④ 使用FeignClient中定义的方法代替RestTemplate</p><p>存在问题：</p><ol><li>org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient.choose报错解决</li></ol><p>解决方法其实也很简单 直接在pom文件里移除ribbon文件并加上loadbalance</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--        服务注册/发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将ribbon排除 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        添加loadbalancer--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>刷新maven，重启项目</p><ol><li><p>[503] during [GET]<br>to [<a href="http://userservice/user/1">http://userservice/user/1</a>] [UserServiceClient#queryById(Long)]: [Load balancer does not contain an instance for the service userservice]</p><p>顾名思义找不到该服务</p><p>解决方法就是检查自己的nacos是否在同一个命名空间(namespace)中，命名空间不一致导致访问不到该服务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ # 集群名称</span><br><span class="line">#        namespace: 6f7fe72c-a02f-424f-a992-5e6a46589383</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-2-自定义配置"><a href="#2-2-自定义配置" class="headerlink" title="2.2.自定义配置"></a>2.2.自定义配置</h2><p>Feign可以支持很多的自定义配置，如下表所示：</p><div class="table-container"><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table></div><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h3 id="2-2-1-配置文件方式"><a href="#2-2-1-配置文件方式" class="headerlink" title="2.2.1.配置文件方式"></a>2.2.1.配置文件方式</h3><p>基于配置文件修改feign的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment">#  日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h3 id="2-2-2-Java代码方式"><a href="#2-2-2-Java代码方式" class="headerlink" title="2.2.2.Java代码方式"></a>2.2.2.Java代码方式</h3><p>也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfiguration</span>  &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要<strong>全局生效</strong>，将其放到启动类的@EnableFeignClients这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是<strong>局部生效</strong>，则把它放到对应的@FeignClient这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, configuration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><h2 id="2-3-Feign使用优化"><a href="#2-3-Feign使用优化" class="headerlink" title="2.3.Feign使用优化"></a>2.3.Feign使用优化</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><p>•URLConnection：默认实现，不支持连接池</p><p>•Apache HttpClient ：支持连接池</p><p>•OKHttp：支持连接池</p><p>因此提高Feign的性能主要手段就是使用<strong>连接池</strong>代替默认的URLConnection。</p><p>这里我们用Apache的HttpClient来演示。</p><p>1）引入依赖</p><p>在order-service的pom文件中引入Apache的HttpClient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置连接池</p><p>在order-service的application.yml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><p>接下来，在FeignClientFactoryBean中的loadBalance方法中打断点：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150940930.png" alt="image-20210714185925910"></p><p>Debug方式启动order-service服务，可以看到这里的client，底层就是Apache HttpClient：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150942891.png" alt="image-20210714190041542"></p><p>总结，Feign的优化：</p><p>1.日志级别尽量用basic</p><p>2.使用HttpClient或OKHttp代替URLConnection</p><p>① 引入feign-httpClient依赖</p><p>② 配置文件开启httpClient功能，设置连接池参数</p><h2 id="2-4-最佳实践"><a href="#2-4-最佳实践" class="headerlink" title="2.4.最佳实践"></a>2.4.最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>自习观察可以发现，Feign的客户端与服务提供者的controller代码非常相似：</p><p>feign客户端：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150942231.png" alt="image-20210714190542730"></p><p>UserController：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150942255.png" alt="image-20210714190528450"></p><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="2-4-1-继承方式"><a href="#2-4-1-继承方式" class="headerlink" title="2.4.1.继承方式"></a>2.4.1.继承方式</h3><p>一样的代码可以通过继承来共享：</p><p>1）定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</p><p>2）Feign客户端和Controller都集成改接口</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150943294.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h3 id="2-4-2-抽取方式"><a href="#2-4-2-抽取方式" class="headerlink" title="2.4.2.抽取方式"></a>2.4.2.抽取方式</h3><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150943688.png" alt="image-20210714214041796"></p><h3 id="2-4-3-实现基于抽取的最佳实践"><a href="#2-4-3-实现基于抽取的最佳实践" class="headerlink" title="2.4.3.实现基于抽取的最佳实践"></a>2.4.3.实现基于抽取的最佳实践</h3><h4 id="1）抽取"><a href="#1）抽取" class="headerlink" title="1）抽取"></a>1）抽取</h4><p>首先创建一个module，命名为feign-api：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150944589.png" alt="image-20210714204557771"></p><p>项目结构：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150944254.png" alt="image-20210714204656214"></p><p>在feign-api中然后引入feign的starter依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150944461.png" alt="image-20210714205221970"></p><h4 id="2）在order-service中使用feign-api"><a href="#2）在order-service中使用feign-api" class="headerlink" title="2）在order-service中使用feign-api"></a>2）在order-service中使用feign-api</h4><p>首先，删除order-service中的UserClient、User、DefaultFeignConfiguration等类或接口。</p><p>在order-service的pom文件中中引入feign-api的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改order-service中的所有与上述三个组件有关的导包部分，改成导入feign-api中的包</p><h4 id="3）重启测试"><a href="#3）重启测试" class="headerlink" title="3）重启测试"></a>3）重启测试</h4><p>重启后，发现服务报错了：</p><p><img src="assets/image-20210714205623048.png" alt="image-20210714205623048"></p><p>这是因为UserClient现在在cn.itcast.feign.clients包下，</p><p>而order-service的@EnableFeignClients注解是在cn.itcast.order包下，不在同一个包，无法扫描到UserClient。</p><h4 id="4）解决扫描包问题"><a href="#4）解决扫描包问题" class="headerlink" title="4）解决扫描包问题"></a>4）解决扫描包问题</h4><p>方式一：</p><p>指定Feign应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二：</p><p>指定需要加载的Client接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="3-Gateway服务网关"><a href="#3-Gateway服务网关" class="headerlink" title="3.Gateway服务网关"></a>3.Gateway服务网关</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor<br>等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>路由（根据什么条件，转发请求到哪里） 断言：一组规则、条件，用来确定如何转发路由 过滤器：对请求进行一系列的处理，比如添加请求头、添加请求参数</p><p>请求流程：</p><ol><li>客户端发起请求</li><li>handler mapping 根据断言将请求转发到对应的路由</li><li>web handler：处理请求，经过一层层过滤器</li><li>实际调用服务</li></ol><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150909822.png" alt="image-20230915090112127"></p><h2 id="3-1-为什么需要网关"><a href="#3-1-为什么需要网关" class="headerlink" title="3.1.为什么需要网关"></a>3.1.为什么需要网关</h2><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150911386.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="3-2-gateway快速入门"><a href="#3-2-gateway快速入门" class="headerlink" title="3.2.gateway快速入门"></a>3.2.gateway快速入门</h2><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h3 id="1）创建gateway服务，引入依赖"><a href="#1）创建gateway服务，引入依赖" class="headerlink" title="1）创建gateway服务，引入依赖"></a>1）创建gateway服务，引入依赖</h3><p>创建服务：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150912263.png" alt="image-20210714210919458"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）编写启动类"><a href="#2）编写启动类" class="headerlink" title="2）编写启动类"></a>2）编写启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3）编写基础配置和路由规则"><a href="#3）编写基础配置和路由规则" class="headerlink" title="3）编写基础配置和路由规则"></a>3）编写基础配置和路由规则</h3><p>创建application.yml文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h3 id="4）重启测试"><a href="#4）重启测试" class="headerlink" title="4）重启测试"></a>4）重启测试</h3><p>重启网关，访问<a href="http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：">http://localhost:10010/user/1时，符合`/user/**`规则，请求转发到uri：http://userservice/user/1，得到了结果：</a></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150913517.png" alt="image-20210714211908341"></p><h3 id="5）网关路由的流程图"><a href="#5）网关路由的流程图" class="headerlink" title="5）网关路由的流程图"></a>5）网关路由的流程图</h3><p>整个访问的流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150914611.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><p>接下来，就重点来学习路由断言和路由过滤器的详细知识</p><p>日志开启：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">        level:</span><br><span class="line">        org:</span><br><span class="line">        springframework:</span><br><span class="line">        cloud:</span><br><span class="line">        gateway: trace</span><br></pre></td></tr></table></figure><h2 id="3-3-断言工厂"><a href="#3-3-断言工厂" class="headerlink" title="3.3.断言工厂"></a>3.3.断言工厂</h2><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来</p><p>处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><div class="table-container"><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>- Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者- Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td></tr></tbody></table></div><p>我们只需要掌握Path这种路由工程就可以了。</p><h2 id="3-4-过滤器工厂"><a href="#3-4-过滤器工厂" class="headerlink" title="3.4.过滤器工厂"></a>3.4.过滤器工厂</h2><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150914259.png" alt="image-20210714212312871"></p><p>基本功能：对请求头、请求参数、响应头的增删改查</p><ol><li>添加请求头</li><li>添加请求参数</li><li>添加响应头</li><li>降级</li><li>限流</li><li>重试</li></ol><h3 id="3-4-1-路由过滤器的种类"><a href="#3-4-1-路由过滤器的种类" class="headerlink" title="3.4.1.路由过滤器的种类"></a>3.4.1.路由过滤器的种类</h3><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><div class="table-container"><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table></div><h3 id="3-4-2-请求头过滤器"><a href="#3-4-2-请求头过滤器" class="headerlink" title="3.4.2.请求头过滤器"></a>3.4.2.请求头过滤器</h3><p>下面我们以AddRequestHeader 为例来讲解。</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">          <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h3 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h3><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Itcast</span> <span class="string">is</span> <span class="string">freaking</span> <span class="string">awesome!</span> </span><br></pre></td></tr></table></figure><h3 id="3-4-4-添加请求头的过滤器"><a href="#3-4-4-添加请求头的过滤器" class="headerlink" title="3.4.4 添加请求头的过滤器"></a><strong>3.4.4 添加请求头的过滤器</strong></h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">add_request_header_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=xiaoyu,</span> <span class="string">xiaoyu</span></span><br></pre></td></tr></table></figure><h3 id="3-4-5-总结"><a href="#3-4-5-总结" class="headerlink" title="3.4.5.总结"></a>3.4.5.总结</h3><p>过滤器的作用是什么？</p><p>① 对路由的请求或响应做加工处理，比如添加请求头</p><p>② 配置在路由下的过滤器只对当前路由的请求生效</p><p>defaultFilters的作用是什么？</p><p>① 对所有路由都生效的过滤器</p><h2 id="3-5-全局过滤器"><a href="#3-5-全局过滤器" class="headerlink" title="3.5.全局过滤器"></a>3.5.全局过滤器</h2><p>上一节学习的过滤器，网关提供了31种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h3 id="3-5-1-全局过滤器作用"><a href="#3-5-1-全局过滤器作用" class="headerlink" title="3.5.1.全局过滤器作用"></a>3.5.1.全局过滤器作用</h3><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h3 id="3-5-2-自定义全局过滤器"><a href="#3-5-2-自定义全局过滤器" class="headerlink" title="3.5.2.自定义全局过滤器"></a>3.5.2.自定义全局过滤器</h3><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求参数</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();</span><br><span class="line">        <span class="comment">// 2.获取authorization参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">auth</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.校验</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.拦截</span></span><br><span class="line">        <span class="comment">// 4.1.禁止访问，设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">        <span class="comment">// 4.2.结束处理</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-过滤器执行顺序"><a href="#3-5-3-过滤器执行顺序" class="headerlink" title="3.5.3.过滤器执行顺序"></a>3.5.3.过滤器执行顺序</h3><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150914279.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><p><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code><br>方法是先加载defaultFilters，然后再加载某个route的filters，然后合并。</p><p><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code>方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</p><h2 id="3-6-跨域问题"><a href="#3-6-跨域问题" class="headerlink" title="3.6.跨域问题"></a>3.6.跨域问题</h2><h3 id="3-6-1-什么是跨域问题"><a href="#3-6-1-什么是跨域问题" class="headerlink" title="3.6.1.什么是跨域问题"></a>3.6.1.什么是跨域问题</h3><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS，这个以前应该学习过，这里不再赘述了。不知道的小伙伴可以查看<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h3 id="3-6-2-模拟跨域问题"><a href="#3-6-2-模拟跨域问题" class="headerlink" title="3.6.2.模拟跨域问题"></a>3.6.2.模拟跨域问题</h3><p>找到课前资料的页面文件：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150915586.png" alt="image-20210714215713563"></p><p>放入tomcat或者nginx这样的web服务器中，启动并访问。</p><p>可以在浏览器控制台看到下面的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/202309150915091.png" alt="image-20210714215832675"></p><p>从localhost:8090访问localhost:10010，端口不同，显然是跨域的请求。</p><h3 id="3-6-3-解决跨域问题"><a href="#3-6-3-解决跨域问题" class="headerlink" title="3.6.3.解决跨域问题"></a>3.6.3.解决跨域问题</h3><p>在gateway服务的application.yml文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/12/hello-world/"/>
      <url>/2023/09/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudDay1</title>
      <link href="/2023/09/12/SpringCloud01/"/>
      <url>/2023/09/12/SpringCloud01/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h1 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h1><p>随着互联网行业的发展，对服务的要求也越来越高，服务架构也从单体架构逐渐演变为现在流行的微服务架构。这些架构之间有怎样的差别呢？</p><h2 id="1-0-学习目标"><a href="#1-0-学习目标" class="headerlink" title="1.0.学习目标"></a>1.0.学习目标</h2><p>了解微服务架构的优缺点</p><h2 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1.单体架构"></a>1.1.单体架构</h2><p><strong>单体架构</strong>：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713202807818.png" alt="image-20210713202807818"></p><p>单体架构的优缺点如下：</p><p><strong>优点：</strong></p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点：</strong></p><ul><li>耦合度高（维护困难、升级困难）</li></ul><h2 id="1-2-分布式架构"><a href="#1-2-分布式架构" class="headerlink" title="1.2.分布式架构"></a>1.2.分布式架构</h2><p><strong>分布式架构</strong>：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713203124797.png" alt="image-20210713203124797"></p><p>分布式架构的优缺点：</p><p><strong>优点：</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级和拓展</li></ul><p><strong>缺点：</strong></p><ul><li>服务调用关系错综复杂</li></ul><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h2 id="1-3-微服务"><a href="#1-3-微服务" class="headerlink" title="1.3.微服务"></a>1.3.微服务</h2><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713203753373.png" alt="image-20210713203753373"></p><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在 Java 领域最引人注目的就是 SpringCloud 提供的方案了。</p><h2 id="1-4-SpringCloud"><a href="#1-4-SpringCloud" class="headerlink" title="1.4.SpringCloud"></a>1.4.SpringCloud</h2><p>SpringCloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud。">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud 集成了各种微服务功能组件，并基于 SpringBoot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713204155887.png" alt="image-20210713204155887"></p><p>另外，SpringCloud 底层是依赖于 SpringBoot 的，并且有版本的兼容关系，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713205003790.png" alt="image-20210713205003790"></p><p>我们课堂学习的版本是 Hoxton.SR10，因此对应的 SpringBoot 版本是 2.3.x 版本。</p><h2 id="1-5-总结"><a href="#1-5-总结" class="headerlink" title="1.5.总结"></a>1.5.总结</h2><ul><li><p>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p>微服务：一种良好的分布式架构方案</p><p>① 优点：拆分粒度更小、服务更独立、耦合度更低</p><p>② 缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p>SpringCloud 是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul><h1 id="2-服务拆分和远程调用"><a href="#2-服务拆分和远程调用" class="headerlink" title="2.服务拆分和远程调用"></a>2.服务拆分和远程调用</h1><p>任何分布式架构都离不开服务的拆分，微服务也是一样。</p><h2 id="2-1-服务拆分原则"><a href="#2-1-服务拆分原则" class="headerlink" title="2.1.服务拆分原则"></a>2.1.服务拆分原则</h2><p>这里我总结了微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/1.png" alt="image-20210713211009593"></p><h2 id="2-2-服务拆分示例"><a href="#2-2-服务拆分示例" class="headerlink" title="2.2.服务拆分示例"></a>2.2.服务拆分示例</h2><p>以课前资料中的微服务 cloud-demo 为例，其结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-2023091202.png" alt="image-20210713211009593"></p><p>cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露 Restful 的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库</li></ul><h3 id="2-2-1-导入-Sql-语句"><a href="#2-2-1-导入-Sql-语句" class="headerlink" title="2.2.1.导入 Sql 语句"></a>2.2.1.导入 Sql 语句</h3><p>首先，将课前资料提供的<code>cloud-order.sql</code>和<code>cloud-user.sql</code>导入到 mysql 中：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713211417049.png" alt="image-20210713211417049"></p><p>cloud-user 表中初始数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713211550169.png" alt="image-20210713211550169"></p><p>cloud-order 表中初始数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713211657319.png" alt="image-20210713211657319"></p><p>cloud-order 表中持有 cloud-user 表中的 id 字段。</p><h3 id="2-2-2-导入-demo-工程"><a href="#2-2-2-导入-demo-工程" class="headerlink" title="2.2.2.导入 demo 工程"></a>2.2.2.导入 demo 工程</h3><p>用 IDEA 导入课前资料提供的 Demo：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-2023091203.png" alt="image-20210713211814094"></p><p>项目结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713212656887.png" alt="image-20210713212656887"></p><p>导入后，会在 IDEA 右下角出现弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-2023091204.png" alt="image-20210713212349272"></p><p>点击弹窗，然后按下图选择：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713212336185.png" alt="image-20210713212336185"></p><p>会出现这样的菜单：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713212513324.png" alt="image-20210713212513324"></p><p>配置下项目使用的 JDK：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image20210713220736408.png" alt="image-20210713220736408"></p><h2 id="2-3-实现远程调用案例"><a href="#2-3-实现远程调用案例" class="headerlink" title="2.3.实现远程调用案例"></a>2.3.实现远程调用案例</h2><p>在 order-service 服务中，有一个根据 id 查询订单的接口：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713212749575.png" alt="image-20210713212749575"></p><p>根据 id 查询订单，返回值是 Order 对象，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713212901725.png" alt="image-20210713212901725"></p><p>其中的 user 为 null</p><p>在 user-service 中有一个根据 id 查询用户的接口：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713213146089.png" alt="image-20210713213146089"></p><p>查询的结果如图：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/ima20210713213213075.png" alt="image-20210713213213075"></p><h3 id="2-3-1-案例需求："><a href="#2-3-1-案例需求：" class="headerlink" title="2.3.1.案例需求："></a>2.3.1.案例需求：</h3><p>修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713213312278.png" alt="image-20210713213312278"></p><p>因此，我们需要在 order-service 中 向 user-service 发起一个 http 的请求，调用 <a href="http://localhost:8081/user/{userId}这个接口。">http://localhost:8081/user/{userId}这个接口。</a></p><p>大概的步骤是这样的：</p><ul><li>注册一个 RestTemplate 的实例到 Spring 容器</li><li>修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User</li><li>将查询的 User 填充到 Order 对象，一起返回</li></ul><h3 id="2-3-2-注册-RestTemplate"><a href="#2-3-2-注册-RestTemplate" class="headerlink" title="2.3.2.注册 RestTemplate"></a>2.3.2.注册 RestTemplate</h3><p>首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-实现远程调用"><a href="#2-3-3-实现远程调用" class="headerlink" title="2.3.3.实现远程调用"></a>2.3.3.实现远程调用</h3><p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713213959569.png" alt="image-20210713213959569"></p><p>调用结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">101</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">699900</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Apple 苹果 iPhone 12 &quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;userId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;柳岩&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="string">&quot;湖南省衡阳市&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-提供者与消费者"><a href="#2-4-提供者与消费者" class="headerlink" title="2.4.提供者与消费者"></a>2.4.提供者与消费者</h2><p>在服务调用关系中，会有两个不同的角色：</p><p><strong>服务提供者</strong>：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</p><p><strong>服务消费者</strong>：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713214404481.png" alt="image-20210713214404481"></p><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。</p><p>如果服务 A 调用了服务 B，而服务 B 又调用了服务 C，服务 B 的角色是什么？</p><ul><li>对于 A 调用 B 的业务而言：A 是服务消费者，B 是服务提供者</li><li>对于 B 调用 C 的业务而言：B 是服务消费者，C 是服务提供者</li></ul><p>因此，服务 B 既可以是服务提供者，也可以是服务消费者。</p><h1 id="3-Eureka-注册中心"><a href="#3-Eureka-注册中心" class="headerlink" title="3.Eureka 注册中心"></a>3.Eureka 注册中心</h1><p>假如我们的服务提供者 user-service 部署了多个实例，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713214925388.png" alt="image-20210713214925388"></p><p>大家思考几个问题：</p><ul><li>order-service 在发起远程调用的时候，该如何得知 user-service 实例的 ip 地址和端口？</li><li>有多个 user-service 实例地址，order-service 调用时该如何选择？</li><li>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</li></ul><h2 id="3-1-Eureka-的结构和作用"><a href="#3-1-Eureka-的结构和作用" class="headerlink" title="3.1.Eureka 的结构和作用"></a>3.1.Eureka 的结构和作用</h2><p>这些问题都需要利用 SpringCloud 中的注册中心来解决，其中最广为人知的注册中心就是 Eureka，其结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713220104956.png" alt="image-20210713220104956"></p><p>回答之前的各个问题。</p><p>问题 1：order-service 如何得知 user-service 实例地址？</p><p>获取地址信息的流程如下：</p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server（Eureka 服务端）。这个叫服务注册</li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题 2：order-service 如何从多个 user-service 实例中选择具体的实例？</p><ul><li>order-service 从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题 3：order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</p><ul><li>user-service 会每隔一段时间（默认 30 秒）向 eureka-server 发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了 eureka-client 端</p></blockquote><p>因此，接下来我们动手实践的步骤包括：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713220509769.png" alt="image-20210713220509769"></p><h2 id="3-2-搭建-eureka-server"><a href="#3-2-搭建-eureka-server" class="headerlink" title="3.2.搭建 eureka-server"></a>3.2.搭建 eureka-server</h2><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><h3 id="3-2-1-创建-eureka-server-服务"><a href="#3-2-1-创建-eureka-server-服务" class="headerlink" title="3.2.1.创建 eureka-server 服务"></a>3.2.1.创建 eureka-server 服务</h3><p>在 cloud-demo 父工程下，创建一个子模块：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713220605881.png" alt="image-20210713220605881"></p><p>填写模块信息：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image20210713220736408.png" alt="image-20210713220857396"></p><p>然后填写服务信息：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713221339022.png" alt="image-20210713221339022"></p><h3 id="3-2-2-引入-eureka-依赖"><a href="#3-2-2-引入-eureka-依赖" class="headerlink" title="3.2.2.引入 eureka 依赖"></a>3.2.2.引入 eureka 依赖</h3><p>引入 SpringCloud 为 eureka 提供的 starter 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-编写启动类"><a href="#3-2-3-编写启动类" class="headerlink" title="3.2.3.编写启动类"></a>3.2.3.编写启动类</h3><p>给 eureka-server 服务编写一个启动类，一定要添加一个@EnableEurekaServer 注解，开启 eureka 的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-编写配置文件"><a href="#3-2-4-编写配置文件" class="headerlink" title="3.2.4.编写配置文件"></a>3.2.4.编写配置文件</h3><p>编写一个 application.yml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-启动服务"><a href="#3-2-5-启动服务" class="headerlink" title="3.2.5.启动服务"></a>3.2.5.启动服务</h3><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713222157190.png" alt="image-20210713222157190"></p><h2 id="3-3-服务注册"><a href="#3-3-服务注册" class="headerlink" title="3.3.服务注册"></a>3.3.服务注册</h2><p>下面，我们将 user-service 注册到 eureka-server 中去。</p><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-boot.version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">spring-boot.version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>2021.0.5<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件"><a href="#2）配置文件" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）启动多个-user-service-实例"><a href="#3）启动多个-user-service-实例" class="headerlink" title="3）启动多个 user-service 实例"></a>3）启动多个 user-service 实例</h3><p>为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。</p><p>首先，复制原来的 user-service 启动配置：</p><p><a href="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713222656562.png">https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713222656562.png</a></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713222656562.png" alt="image-20210713222656562"></p><p>然后，在弹出的窗口中，填写信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=8082</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713222757702.png" alt="image-20210713222757702"></p><p>现在，SpringBoot 窗口会出现两个 user-service 启动配置：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713222841951.png" alt="image-20210713222841951"></p><p>不过，第一个是 8081 端口，第二个是 8082 端口。</p><p>启动两个 user-service 实例：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713223041491.png" alt="image-20210713223041491"></p><p>查看 eureka-server 管理页面：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713223150650.png" alt="image-20210713223150650"></p><h2 id="3-4-服务发现"><a href="#3-4-服务发现" class="headerlink" title="3.4.服务发现"></a>3.4.服务发现</h2><p>下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。</p><p>在 order-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置文件-1"><a href="#2）配置文件-1" class="headerlink" title="2）配置文件"></a>2）配置文件</h3><p>服务发现也需要知道 eureka 地址，因此第二步与服务注册一致，都是配置 eureka 信息：</p><p>在 order-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3）服务拉取和负载均衡"><a href="#3）服务拉取和负载均衡" class="headerlink" title="3）服务拉取和负载均衡"></a>3）服务拉取和负载均衡</h3><p>最后，我们要去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。</p><p>不过这些动作不用我们去做，只需要添加一些注解即可。</p><p>在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个@LoadBalanced 注解：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713212336185.png" alt="image-20210713224049419"></p><p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法。修改访问的 url 路径，用服务名代替 ip、端口：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image20210713224245731.png" alt="image-20210713224245731"></p><p>spring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><ol><li>搭建 EurekaServe</li></ol><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加注解</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer</span><br></pre></td></tr></table></figure><ul><li>在 yml 文件中配置地址</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment">#端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span> <span class="comment">#服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><ol><li>服务注册</li></ol><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 yml 文件中修改配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:  #服务名称</span><br><span class="line">    name: userservice</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">    ip-address: 127.0.0.1</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://127.0.0.1:10086/eureka</span><br></pre></td></tr></table></figure><ol><li>服务发现</li></ol><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加配置信息</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span> <span class="comment">#服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><ul><li>添加注解（服务拉取和负载均衡）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"> <span class="meta">@LoadBalanced</span></span><br><span class="line"> <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>远程调用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="comment">// 2.发起远程调用</span></span><br><span class="line"><span class="comment">//        String uri = &quot;http://localhost:8081/user/&quot; + order.getUserId();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(uri, User.class);</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Ribbon-负载均衡"><a href="#4-Ribbon-负载均衡" class="headerlink" title="4.Ribbon 负载均衡"></a>4.Ribbon 负载均衡</h1><p>上一节中，我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="4-1-负载均衡原理"><a href="#4-1-负载均衡原理" class="headerlink" title="4.1.负载均衡原理"></a>4.1.负载均衡原理</h2><p>SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713224517686.png" alt="image-20210713224517686"></p><p>那么我们发出的请求明明是 <a href="http://userservice/user/1，怎么变成了">http://userservice/user/1，怎么变成了</a> <a href="http://localhost:8081">http://localhost:8081</a> 的呢？</p><h2 id="4-2-源码跟踪"><a href="#4-2-源码跟踪" class="headerlink" title="4.2.源码跟踪"></a>4.2.源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h3 id="1）LoadBalancerIntercepor"><a href="#1）LoadBalancerIntercepor" class="headerlink" title="1）LoadBalancerIntercepor"></a>1）LoadBalancerIntercepor</h3><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求 uri，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取 uri 路径的主机名，其实就是服务 id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li></ul><p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="2）LoadBalancerClient"><a href="#2）LoadBalancerClient" class="headerlink" title="2）LoadBalancerClient"></a>2）LoadBalancerClient</h3><p>继续跟入 execute 方法：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/152562078.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了 8082 端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是 8081：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="3）负载均衡策略-IRule"><a href="#3）负载均衡策略-IRule" class="headerlink" title="3）负载均衡策略 IRule"></a>3）负载均衡策略 IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/22652849.png" alt="1525622652849"></p><p>我们看看这个 rule 是谁：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/1525622699666.png" alt="1525622699666"></p><p>这里的 rule 默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="4）总结"><a href="#4）总结" class="headerlink" title="4）总结"></a>4）总结</h3><p>SpringCloudRibbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p><ul><li>拦截我们的 RestTemplate 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service</li><li>DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li>IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li>RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1，发起真实请求">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="4-3-负载均衡策略"><a href="#4-3-负载均衡策略" class="headerlink" title="4.3.负载均衡策略"></a>4.3.负载均衡策略</h2><h3 id="4-3-1-负载均衡策略"><a href="#4-3-1-负载均衡策略" class="headerlink" title="4.3.1.负载均衡策略"></a>4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><div class="table-container"><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit 属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table></div><p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p><h3 id="4-3-2-自定义负载均衡策略"><a href="#4-3-2-自定义负载均衡策略" class="headerlink" title="4.3.2.自定义负载均衡策略"></a>4.3.2.自定义负载均衡策略</h3><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><ol><li>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：（全局配置）不适用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="4-4-饥饿加载"><a href="#4-4-饥饿加载" class="headerlink" title="4.4.饥饿加载"></a>4.4.饥饿加载</h2><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span></span><br></pre></td></tr></table></figure><h1 id="5-Nacos-注册中心"><a href="#5-Nacos-注册中心" class="headerlink" title="5.Nacos 注册中心"></a>5.Nacos 注册中心</h1><p>国内公司一般都推崇阿里巴巴的技术，比如注册中心，SpringCloudAlibaba 也推出了一个名为 Nacos 的注册中心。</p><h2 id="5-1-认识和安装-Nacos"><a href="#5-1-认识和安装-Nacos" class="headerlink" title="5.1.认识和安装 Nacos"></a>5.1.认识和安装 Nacos</h2><p><a href="https://nacos.io/">Nacos</a>是阿里巴巴的产品，现在是<a href="https://spring.io/projects/spring-cloud">SpringCloud</a>中的一个组件。相比<a href="https://github.com/Netflix/eureka">Eureka</a>功能更加丰富，在国内受欢迎程度较高。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713230444308.png" alt="image-20210713230444308"></p><h2 id="5-2-服务注册到-nacos"><a href="#5-2-服务注册到-nacos" class="headerlink" title="5.2.服务注册到 nacos"></a>5.2.服务注册到 nacos</h2><p>Nacos 是 SpringCloudAlibaba 的组件，而 SpringCloudAlibaba 也遵循 SpringCloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。</p><p>主要差异在于：</p><ul><li>依赖不同</li><li>服务地址不同</li></ul><h3 id="1）引入依赖-2"><a href="#1）引入依赖-2" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在 cloud-demo 父工程的 pom 文件中的<code>&lt;dependencyManagement&gt;</code>中引入 SpringCloudAlibaba 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 user-service 和 order-service 中的 pom 文件中引入 nacos-discovery 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉 eureka 的依赖。</p></blockquote><h3 id="2）配置-nacos-地址"><a href="#2）配置-nacos-地址" class="headerlink" title="2）配置 nacos 地址"></a>2）配置 nacos 地址</h3><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：不要忘了注释掉 eureka 的地址</p></blockquote><h3 id="3）重启"><a href="#3）重启" class="headerlink" title="3）重启"></a>3）重启</h3><p>重启微服务后，登录 nacos 管理页面，可以看到微服务信息：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713231439607.png" alt="image-20210713231439607"></p><h2 id="5-3-服务分级存储模型"><a href="#5-3-服务分级存储模型" class="headerlink" title="5.3.服务分级存储模型"></a>5.3.服务分级存储模型</h2><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos 就将同一机房内的实例 划分为一个<strong>集群</strong>。</p><p>也就是说，user-service 是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713232522531.png" alt="image-20210713232522531"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713232658928.png" alt="image-20210713232658928"></p><p>杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><h3 id="5-3-1-给-user-service-配置集群"><a href="#5-3-1-给-user-service-配置集群" class="headerlink" title="5.3.1.给 user-service 配置集群"></a>5.3.1.给 user-service 配置集群</h3><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个 user-service 实例后，我们可以在 nacos 控制台看到下面结果：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713232916215.png" alt="image-20210713232916215"></p><p>我们再次复制一个 user-service 启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p>配置如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713233528982.png" alt="image-20210713233528982"></p><p>启动 UserApplication3 后再次查看 nacos 控制台：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713233727923.png" alt="image-20210713233727923"></p><h3 id="5-3-2-同集群优先的负载均衡"><a href="#5-3-2-同集群优先的负载均衡" class="headerlink" title="5.3.2.同集群优先的负载均衡"></a>5.3.2.同集群优先的负载均衡</h3><p>默认的<code>ZoneAvoidanceRule</code>并不能实现根据同集群优先来实现负载均衡。</p><p>因此 Nacos 中提供了一个<code>NacosRule</code>的实现，可以优先从同集群中挑选实例。</p><p>1）给 order-service 配置集群信息</p><p>修改 order-service 的 application.yml 文件，添加集群配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:8848</span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>2）修改负载均衡规则</p><p>修改 order-service 的 application.yml 文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure><h2 id="5-4-权重配置"><a href="#5-4-权重配置" class="headerlink" title="5.4.权重配置"></a>5.4.权重配置</h2><p>实际部署中会出现这样的场景：</p><p>服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下 NacosRule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在 nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210713235133225.png" alt="image-20210713235133225"></p><p>在弹出的编辑窗口，修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/20210713235235219.png" alt="image-20210713235235219"></p><blockquote><p><strong>注意</strong>：如果权重修改为 0，则该实例永远不会被访问</p></blockquote><h2 id="5-5-环境隔离"><a href="#5-5-环境隔离" class="headerlink" title="5.5.环境隔离"></a>5.5.环境隔离</h2><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li></ul><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000101516.png" alt="image-20210714000101516"></p><h3 id="5-5-1-创建-namespace"><a href="#5-5-1-创建-namespace" class="headerlink" title="5.5.1.创建 namespace"></a>5.5.1.创建 namespace</h3><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000414781.png" alt="image-20210714000414781"></p><p>我们可以点击页面新增按钮，添加一个 namespace：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000440143.png" alt="image-20210714000440143"></p><p>然后，填写表单：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000505928.png" alt="image-20210714000505928"></p><p>就能在页面看到一个新的 namespace：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/20210714000522913.png" alt="image-20210714000522913"></p><h3 id="5-5-2-给微服务配置-namespace"><a href="#5-5-2-给微服务配置-namespace" class="headerlink" title="5.5.2.给微服务配置 namespace"></a>5.5.2.给微服务配置 namespace</h3><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">492a7d5d-237b-46a1-a99a-fa8e98e4b0f9</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启 order-service 后，访问控制台，可以看到下面的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000830703.png" alt="image-20210714000830703"></p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000837140.png" alt="image-20210714000837140"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 userservice，控制台会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No instances available <span class="keyword">for</span> userservice</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714000941256.png" alt="image-20210714000941256"></p><h2 id="5-6-Nacos-启动存在问题"><a href="#5-6-Nacos-启动存在问题" class="headerlink" title="5.6.Nacos 启动存在问题"></a>5.6.Nacos 启动存在问题</h2><p>参考文章：<a href="https://blog.csdn.net/wangpaiblog/article/details/131758005">https://blog.csdn.net/wangpaiblog/article/details/131758005</a></p><ol><li><p>找不到服务（未使用@LoadBalanced 注解）</p></li><li><p>null</p><p>需要如下相应的依赖，但此依赖在以前是不需要提供的。另外，此依赖的版本需要和 Spring Cloud 的相一致。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在父 POM 使用 Spring Cloud 依赖管理后，上述依赖可以不给出版本号。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Spring Cloud 的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>Nacos 修改权重服务时报错 errCode: 500</li></ol><p>大概意思就是注册的 Ip 啥的混乱了.出现这个问题,1.先停 nacos,2.删掉 data 目录下的 protocol 文件夹,3.重启。解决</p></li></ol><h2 id="5-7-Nacos-与-Eureka-的区别"><a href="#5-7-Nacos-与-Eureka-的区别" class="headerlink" title="5.7.Nacos 与 Eureka 的区别"></a>5.7.Nacos 与 Eureka 的区别</h2><p>Nacos 的服务实例分为两种 l 类型：</p><ul><li><p>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</p></li><li><p>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</p></li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><p>eureka 工作原理：</p><p><img src="https://img-blog.csdnimg.cn/117f8c8d65914fb3bde2af67730a677b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5rO95LiN5LyaSmF2YQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>Nacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/image-20210714001728017.png" alt="image-20210714001728017"></p><ul><li><p>Nacos 与 eureka 的共同点</p><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul></li><li><p>Nacos 与 Eureka 的区别</p><ul><li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka 采用 AP 方式</li></ul></li></ul><ul><li>本人个人理解的区别。</li></ul><p>1：在提供者和注册中心之间。</p><p>（1）Eureka 中会定时向注册中心发送心跳，如果在短期内没有发送心跳，则就会直接剔除。</p><p>（2）Nacos 也会向注册中心发送心跳，但是它的频率要比 Eureka 快。在 Nacos 中又分为临时实例和非临时实例。如果是临时实例的话，短期内没有发送心跳，则会直接剔除。但是如果是非临时实例长时间宕机，不会直接剔除，并且注册中心会直接<strong>主动询问</strong>并且等待非临时实例。</p><p>2：在消费者和注册中心之间。</p><p>（1）Eureka ：服务消费者会定时向注册中心定时拉去服务，如果不主动拉去服务，注册中心不会主动推送。</p><p>（2）Nacos：注册中心会定时向消费者主动推送信息 ，这样就会保持数据的准时性。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ笔记</title>
      <link href="/2023/07/24/RabbitMq/"/>
      <url>/2023/07/24/RabbitMq/</url>
      
        <content type="html"><![CDATA[<h1 id="MQ-架构设计原理"><a href="#MQ-架构设计原理" class="headerlink" title="MQ 架构设计原理"></a>MQ 架构设计原理</h1><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>存储消息的队列。<br>关键词：存储、队列、队列<br>存储:存储数据<br>消息：某种数据结构，比如字符串、对象、二进制数据、json 等等<br>队列：先进先出的数据结构</p><p>应用场景：在多个不同的系统、应用之间实现消息的传输，不需要考虑传输应用的编程语言、系统、框架等等。</p><p>具体实例：异步发送短信、异步发送优惠卷、处理比较耗时的操作</p><p>可以让 java 开发的应用发消息，让 php 开发的应用收消息，这样就不用把所有的代码写到一个项目中（应用解耦）。</p><h2 id="消息队列的模型"><a href="#消息队列的模型" class="headerlink" title="消息队列的模型"></a>消息队列的模型</h2><p>生产者：Producer，类比为快递员，发送消息的人（客户端）<br>消费者：Consumer，类比为取快递的人，接受读取消息的人（客户端）<br>消息：Message，类比为快递，就是生产者要传输给消费者的数据<br>消息队列：Queue</p><p>为什么不接传输，要用消息队列？生产者不用关心你的消费者要不要消费、什么时候消费，我只需要把东西给消息队列，我的工作就算完成了。<br>生产者和消费者实现了解耦，互不影响。</p><p><img src="https://cdn.jsdelivr.net/gh/keependeavour/picgo/img/211I61aL8.jpg" alt="测试照片"></p><h2 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h2><ul><li>1）异步处理<br>生产者发送完消息可以去忙别的事情，消费者想什么时候去取都可以，不会阻塞</li><li>2）削峰填谷<br>先把用户请求放到消息队列中，消费者可以按照自己的需求慢慢去取<br>原本：12 点来了十万个请求，原本情况下，十万个请求都在系统内部处理，很快系统压力过大就好宕机<br>现在：把十万个请求放到消息队列中，处理系统可以以自己恒定的速率慢慢执行，保护系统、稳定处理</li><li>3）可持久性、可靠性<br>大多数消息队列系统提供持久化功能，确保即使在系统故障或重启后，消息不会丢失。这可以提高系统的可靠性，并确保消息的可靠传递。</li><li>4）可拓展性、灵活性<br>通过使用消息队列，可以轻松地添加新的组件或服务，而无需更改现有的系统架构。新的组件可以订阅感兴趣的消息，从而扩展系统的功能和业务流程。</li></ul><h2 id="分布式消息队列的优势"><a href="#分布式消息队列的优势" class="headerlink" title="分布式消息队列的优势"></a>分布式消息队列的优势</h2><p>1）数据持久化:可以把消息持久化到硬盘，服务器重启不会丢失数据<br>2）可扩展性：可以根据需求，随时增减节点，继续保持稳定的服务<br>3）应用解耦：可以连接各个不同的语言、框架开发的系统，让这些系统能够灵活传输读取数据</p><p>应用解耦的优点：</p><p>以前，把功能放到一个项目中，调用多个子功能时，要给环节出错，系统就整体出错<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687920054171-7eb680e2-25da-4f1a-ac41-e576a332e534.png#averageHue=%23fefdfd&amp;clientId=u8e95eaa8-7658-4&amp;from=paste&amp;height=270&amp;id=u423efd77&amp;originHeight=338&amp;originWidth=924&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=17788&amp;status=done&amp;style=none&amp;taskId=uc6cc6d6f-10d0-4047-ad7c-48d86de67a7&amp;title=&amp;width=739.2" alt="2~F3M8$}8CT@H7VFWZ85NTU.png"></p><p>使用消息队列进行解耦：</p><ol><li>一个系统挂了，不影响另外的系统</li><li>系统挂了并恢复后，仍然可以取出消息，继续执行业务逻辑</li><li>只要发送消息到消息队列，就可以立即返回，不用同步调用所有的系统。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687920168751-0ea0b35d-2dfe-4a33-9aa4-8cfdaa8cb5f0.png#averageHue=%23fdfdfc&amp;clientId=u8e95eaa8-7658-4&amp;from=paste&amp;height=326&amp;id=u1cbde273&amp;originHeight=407&amp;originWidth=914&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=28414&amp;status=done&amp;style=none&amp;taskId=ue3ab7742-2791-482c-9c93-3d6ee1af88a&amp;title=&amp;width=731.2" alt="CCDJO%40}E7191ZEDV5_3%9.png"><br>4）发布订阅<br>如果一个非常大的系统要给其他子系统发送通知，最简单直接的方式是大系统依次调用小系统<br>问题:</p><ol><li>每次发通知都要调用很多系统、很麻烦、很可能失败</li><li>新出现的项目（或者说大项目感知不到的项目）无法得到通知</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687920548775-de4493f7-2ffe-4ee4-a977-a1e96b881002.png#averageHue=%23fefdfd&amp;clientId=u8e95eaa8-7658-4&amp;from=paste&amp;height=574&amp;id=ua58bdae9&amp;originHeight=717&amp;originWidth=931&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=42693&amp;status=done&amp;style=none&amp;taskId=u1a1a6f91-fb5a-445b-8eb2-ee471e0d3f1&amp;title=&amp;width=744.8" alt="ICBFGE74T~PTR3P]F@}XW5C.png"><br>解决方案：大的核心系统始终往一个地方发送消息，其它系统都去订阅这个消息队列（读取队列中的消息）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687920680994-9455d00a-fe1c-4b6c-a41b-7abe3df913ad.png#averageHue=%23fdfdfd&amp;clientId=u8e95eaa8-7658-4&amp;from=paste&amp;height=518&amp;id=ua45c28c1&amp;originHeight=647&amp;originWidth=815&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=39740&amp;status=done&amp;style=none&amp;taskId=ua11d7701-598c-4023-a44b-b7ea888bfaa&amp;title=&amp;width=652" alt="GM`9OT`H]T{$M%V}87(A(NO.png"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>耗时的场景（异步）</li><li>高并发场景（异步、削峰填谷）</li><li>分布式系统协作（跨团队、跨业务、应用解耦）</li></ol><p>比如 QQ 是一个系统，用 c++写的，微信用** <strong>java 写的</strong> **，qq 的消息可以通过消息队列传送给微信</p><ol><li>强稳定性的场景（金融业务、持久化、可靠性、削峰填谷）</li></ol><p>支付、转账</p><h2 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h2><p>要给系统引入额外的中间件，系统会更复杂、额外维护中间件、额外的费用（部署）成本<br>消息队列：消息丢失、顺序性、重复消费、数据的一致性（分布式系统就要考虑）</p><blockquote><p>也可以叫分布式场景下需要考虑的问题)</p></blockquote><h2 id="传统的-http-请求存在那些缺点"><a href="#传统的-http-请求存在那些缺点" class="headerlink" title="传统的 http 请求存在那些缺点"></a>传统的 http 请求存在那些缺点</h2><p>1.Http 请求基于请求与响应的模型，在高并发的情况下，客户端发送大量的请求达到<br>服务器端有可能会导致我们服务器端处理请求堆积。<br>2.Tomcat 服务器处理每个请求都有自己独立的线程，如果超过最大线程数会将该请求缓存到队列中，如果请求堆积过多的情况下，有可能会导致 tomcat 服务器崩溃的问题。<br>所以一般都会在 nginx 入口实现限流，整合服务保护框架。</p><ol><li>http请求处理业务逻辑如果比较耗时的情况下，容易造成客户端一直等待，阻塞等待<br>过程中会导致客户端超时发生重试策略，有可能会引发幂等性问题。</li></ol><p>注意事项：接口是为 http 协议的情况下，最好不要处理比较耗时的业务逻辑，耗时的业务逻辑应该单独交给多线程或者是 mq 处理。</p><h3 id="同步发送-http-请求"><a href="#同步发送-http-请求" class="headerlink" title="同步发送 http 请求"></a>同步发送 http 请求</h3><p>客户端发送请求到达服务器端，服务器端实现会员注册业务逻辑，<br>1.insertMember() —插入会员数据 1s<br>2.sendSms()——发送登陆短信提醒 3s<br>3.sendCoupons()——发送新人优惠券 3s<br>总共响应需要 6s 时间，可能会导致客户端阻塞 6s 时间，对用户体验<br>不是很好。</p><p>多线程与 MQ 方式实现异步？</p><p>互联网项目:<br>客户端安卓/IOS</p><p>服务器端：php/java<br>最好使用 mq 实现异步</p><h3 id="多线程处理业务逻辑"><a href="#多线程处理业务逻辑" class="headerlink" title="多线程处理业务逻辑"></a>多线程处理业务逻辑</h3><p>用户向数据库中插入一条数据之后，在单独开启一个线程异步发送短信和优惠操作。<br>客户端只需要等待 1s 时间<br>优点：适合于小项目实现异步<br>缺点：有可能会消耗服务器 cpu 资源资源</p><h3 id="Mq-处理业务逻辑"><a href="#Mq-处理业务逻辑" class="headerlink" title="Mq 处理业务逻辑"></a>Mq 处理业务逻辑</h3><p>先向数据库中插入一条会员数据，让后再向 MQ 中投递一个消息，MQ 服务器端在将消息推送给消费者异步解耦处理发送短信和优惠券。</p><h2 id="Mq-与多线程之间区别"><a href="#Mq-与多线程之间区别" class="headerlink" title="Mq 与多线程之间区别"></a>Mq 与多线程之间区别</h2><p>多线程也可以实现异步，但是消耗到 cpu 资源，没有实现解耦。<br>多线程异步去实现发送短信以及领取优惠卷会导致过度消耗 cpu 资源，cpu 上下文竞争关系，可能导致会员服务以及其他服务降低，因此多线程适合于小项目；而 MQ 可以实现异步/解耦/流量削峰问题，因此适合于大型项目。</p><h2 id="Mq-消息中间件名词"><a href="#Mq-消息中间件名词" class="headerlink" title="Mq 消息中间件名词"></a>Mq 消息中间件名词</h2><p>Producer 生产者：投递消息到 MQ 服务器端；<br>Consumer 消费者：从 MQ 服务器端获取消息处理业务逻辑；<br>Broker MQ 服务器端<br>Topic 主题：分类业务逻辑发送短信主题、发送优惠券主题<br>Queue 存放消息模型队列先进先出后进后出原则数组/链表<br>Message 生产者投递消息报文：json</p><h2 id="主流-mq-区别对比"><a href="#主流-mq-区别对比" class="headerlink" title="主流 mq 区别对比"></a>主流 mq 区别对比</h2><p><strong>技术对比</strong><br>技术选型指标：<br>● 吞吐量：IO、并发<br>● 时效性：类似延迟，消息的发送、到达时间<br>● 可用性：系统可用的比率（比如 1 年 365 天宕机 1s，可用率大概 X 个 9）<br>● 可靠性：消息不丢失（比如不丢失订单）、功能正常完成</p><div class="table-container"><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>kafka</th></tr></thead><tbody><tr><td>开发语言</td><td>java</td><td>erlang</td><td>java</td><td>scala</td></tr><tr><td>单机吞吐量</td><td>万级</td><td>万级</td><td>10 万级</td><td>10 万级</td></tr><tr><td>时效性</td><td>ms 级</td><td>us 级</td><td>ms 级</td><td>ms 级以内</td></tr><tr><td>可用性</td><td>高（主从架构）</td><td>高（主从架构）</td><td>非常高（分布式架构）</td><td>非常高（分布式架构）</td></tr><tr><td>功能特性</td><td>成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好</td><td>基于 erlang 开发，所以并发能力很强，性能极其好，延时很低管理界面较丰富</td><td>MQ 功能比较完备，扩展性佳</td><td>只支持主要的 MQ 功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</td></tr><tr><td>应用场景</td><td>中小型企业、项目</td><td>适合绝大多数分布式的应用，这也是先学他的原因</td><td>适用于 <strong>大规模</strong>处理数据的场景，比如构建日志收集系统、实时数据流传输、事件流收集传输</td><td>适用于 <strong>金融 </strong>、电商等对可靠性要求较高的场景，适合 <strong>大规模 </strong>的消息处理。</td></tr></tbody></table></div><h2 id="RabbitMQ-入门实战"><a href="#RabbitMQ-入门实战" class="headerlink" title="RabbitMQ 入门实战"></a>RabbitMQ 入门实战</h2><p>特点：生态好，好学习、易于理解，时效性强，支持很多不同语言的客户端，扩展性、可用性都很不错。<br>学习性价比非常高的消息队列，适用于绝大多数中小规模分布式系统。</p><p>官方网站：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>AMQP 协议：<a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a><br>AMQP 是一种消息传递协议，让符合要求的客户端应用程序能够与符合要求的消息中间件进行通信<br>高级消息队列协议（Advanced Message Queue Protocol）</p><p>生产者：发消息到某个交换机<br>消费者：从某个队列中取消息<br>交换机（Exchange）：负责把消息 转发 到对应的队列<br>队列（Queue）：存储消息的<br>路由（Routes）：转发，就是怎么把消息从一个地方转到另一个地方（比如从生产者转发到某个队列）<br><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686835103366-bdb220cd-b177-4f41-982d-8451e5f6ebfe.png?x-oss-process=image%2Fresize%2Cw_700%2Climit_0#averageHue=%23f9f2ee&amp;from=url&amp;id=Evvsx&amp;originHeight=328&amp;originWidth=700&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>访问：<a href="http://localhost:15672/#/">http://localhost:15672</a>，用户名密码都是 guest：</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686836097799-5f76d0cf-466c-41f7-9400-c7b31513ce48.png#averageHue=%23f9f9f8&amp;from=url&amp;id=QDJgA&amp;originHeight=1105&amp;originWidth=1848&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>如果想要在远程服务器安装访问 rabbitmq 管理面板，你要自己创建一个管理员账号，不能用默认的 guest，否则会被拦截（官方出于安全考虑）。</p><p>如果被拦截，可以自己创建管理员用户：<br>参考文档的 Adding a User：<a href="https://www.rabbitmq.com/access-control.html">https://www.rabbitmq.com/access-control.html</a></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686836238966-daf0d8b4-ae0f-4451-bbb5-89693eb064b8.png?x-oss-process=image%2Fresize%2Cw_831%2Climit_0#averageHue=%23767574&amp;from=url&amp;id=WIQkF&amp;originHeight=493&amp;originWidth=831&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>rabbitmq 端口占用：<br>5672：程序连接的端口<br>15672：webUI</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686836349584-8ec4cef9-d45a-4d02-8417-6739b7624a8e.png?x-oss-process=image%2Fresize%2Cw_825%2Climit_0#averageHue=%23f3f1ef&amp;from=url&amp;id=C7jLp&amp;originHeight=534&amp;originWidth=825&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>快速入门</p><p>MQ 官方教程：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p><p>单向发送<br>Hello World<br>文档：<a href="https://www.rabbitmq.com/tutorials/tutorial-one-java.html">https://www.rabbitmq.com/tutorials/tutorial-one-java.html</a></p><p>一个生产者给一个队列发消息，一个消费者从这个队列取消息。1 对 1。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686836521822-053f7420-498d-4539-9721-ae0bc6e5b012.png#averageHue=%23f4dbd6&amp;from=url&amp;id=IdUgY&amp;originHeight=244&amp;originWidth=1027&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>引入消息队列 java 客户端</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.rabbitmq/amqp-client --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.QI_BI.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Send</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//        创建连接</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"><span class="comment">//             创建Channel 频道（可以理解为客户端）</span></span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line"><span class="comment">//            创建队列</span></span><br><span class="line">            channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="comment">//            发送消息</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687944063317-2996bc0e-6d7b-4a2c-9206-0412a962d979.png#averageHue=%23ebeae9&amp;clientId=u8e95eaa8-7658-4&amp;from=paste&amp;height=110&amp;id=u022db1f9&amp;originHeight=110&amp;originWidth=1060&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=11950&amp;status=done&amp;style=none&amp;taskId=u00abceb2-39c1-4871-b373-bfcef629f89&amp;title=&amp;width=1060" alt="1687944045356.png"></p><p>消费者代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.QI_BI.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recv</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        创建工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"><span class="comment">//        创建Channel 频道（可以理解为客户端）</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"><span class="comment">//      注意这里的配置要和创建的配置一样</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"><span class="comment">//        定义如何处理消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="comment">//        消费消息，会持续阻塞</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Channel 频道：理解为操作消息队列的 client（比如 jdbcClient、redisClient），提供了和消息队列 server 建立通信的传输方法（为了复用连接，提高传输效率）。程序通过 channel 操作 rabbitmq（收发消息）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Queue.DeclareOk <span class="title function_">queueDeclare</span><span class="params">(String queue, <span class="type">boolean</span> durable, <span class="type">boolean</span> exclusive,</span></span><br><span class="line"><span class="params">                                    <span class="type">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span></span><br></pre></td></tr></table></figure><p>创建消息队列：<br>参数：<br>queue：消息队列名称（注意，同名称的消息队列，只能用同样的参数创建一次）<br>durable：消息队列重启后，消息是否丢失<br>exclusive：是否只允许当前这个创建消息队列的连接操作消息队列<br>autoDelete：没有人 用队列后，是否要删除队列</p><p>消费示例：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687944852554-33ad90fd-9830-4f78-ae56-cf709a0b3666.png#averageHue=%23f0efef&amp;clientId=u8e95eaa8-7658-4&amp;from=paste&amp;height=368&amp;id=u3ec41d11&amp;originHeight=368&amp;originWidth=1231&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=23173&amp;status=done&amp;style=none&amp;taskId=u72ecb416-9b43-4f58-930d-62be4f5106b&amp;title=&amp;width=1231" alt="1687944821005.png"></p><p><strong>多消费者</strong><br>官方教程：<a href="https://www.rabbitmq.com/tutorials/tutorial-two-java.html">https://www.rabbitmq.com/tutorials/tutorial-two-java.html</a><br>场景：多个机器同时去接受并处理任务（尤其是每个机器的处理能力有限）<br>一个生产者给一个队列发消息，<strong>多个消费者 </strong>从这个队列取消息。1 对多。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686837446793-34600b8b-907d-4c0a-8200-f077b3175c32.png#averageHue=%23f7e5e1&amp;from=url&amp;id=xMCTx&amp;originHeight=294&amp;originWidth=870&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>1）队列持久化<br>durable 参数设置为 true，服务器重启后队列不丢失：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>2）消息持久化<br>指定 MessageProperties.PERSISTENT_TEXT_PLAIN 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">        MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">        message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>生产者代码：<br>使用 Scanner 接受用户输入，便于发送多条消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.QI_BI.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.MessageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;multi_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">        channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME,</span><br><span class="line">                    MessageProperties.PERSISTENT_TEXT_PLAIN,</span><br><span class="line">                    message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制单个消费者的处理任务积压数：<br>每个消费者最多同时处理 1 个任务</p><p>消息确认机制：<br>为了保证消息成功被消费（快递成功被取走），rabbitmq 提供了消息确认机制，当消费者接收到消息后，比如要给一个反馈：<br>●ack：消费成功<br>●nack：消费失败<br>●reject：拒绝<br>如果告诉 rabbitmq 服务器消费成功，服务器才会放心地移除消息。<br>支持配置 autoack，会自动执行 ack 命令，接收到消息立刻就成功了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(TASK_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p><strong>autoack 为 true 表示自动确认，建议 autoack 改为 false，根据实际情况，去手动确认。</strong><br>指定确认某条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>默认情况第二个参数为 false，表示只确认当前消息，改为 true 则自动确认在此之前所有未确认的消息<br>指定拒绝某条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>第三个参数 false 是指 requeue 参数，用于指定当消息被拒绝（nack）后是否重新将消息放回队列。在该代码中，设置为 false 表示不将消息重新放回队列，即消息被拒绝后将被丢弃。</p><p>消费者代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.QI_BI.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;multi_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"><span class="comment">//        for循环模拟创建两个消费者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"><span class="comment">//          指定每个消费者最多同时消费的消息数</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 定义了如何处理消息</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理工作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + <span class="string">&quot;编号:&quot;</span> + finalI + <span class="string">&quot;:&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="comment">// 消费消息后手动确认消息</span></span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// 停 20 秒，模拟机器处理能力有限</span></span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//消费异常，</span></span><br><span class="line">                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Done&quot;</span>);</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 开启消费监听</span></span><br><span class="line">            channel.basicConsume(TASK_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 个小技巧： 1. 使用 Scanner 接受用户输入，便于快速发送多条消息 2. 使用 for 循环创建多个消费者，便于快速验证队列模型工作机制</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>一个生产者给 多个 队列发消息，1 个生产者对多个队列。<br>交换机的作用：提供消息转发功能，类似于网络路由器<br>要解决的问题：怎么把消息转发到不同的队列上，好让消费者从不同的队列消费。</p><p>绑定：交换机和队列关联起来，也可以叫路由，算是一个算法或转发策略<br>绑定代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueBind(queueName,EXCHANGE_NAME,<span class="string">&quot;绑定规则&quot;</span>);</span><br></pre></td></tr></table></figure><p>教程：<a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html">https://www.rabbitmq.com/tutorials/tutorial-three-java.html</a></p><p>交换机有多种类别：fanout、direct, topic, headers</p><h4 id="Fanout-交换机"><a href="#Fanout-交换机" class="headerlink" title="Fanout 交换机"></a>Fanout 交换机</h4><p>扇出、广播<br>特点：消息会被转发到所有绑定到该交换机的队列<br>场景：很适用于发布订阅的场景。比如写日志，可以多个系统间共享</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1686839285368-841c3ded-965b-4ed7-8214-091ac7f2c922.png#averageHue=%23ecb9af&amp;from=url&amp;id=FQ8wi&amp;originHeight=247&amp;originWidth=745&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>示例场景：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687948681364-80cd61ee-59a9-439e-a383-1508632217a8.png#averageHue=%23fefefd&amp;clientId=u1d2592de-0cbf-4&amp;from=paste&amp;height=386&amp;id=u93f7459a&amp;originHeight=386&amp;originWidth=785&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=22715&amp;status=done&amp;style=none&amp;taskId=uf5a03041-8aa6-4e4b-ba21-448e52f4d75&amp;title=&amp;width=785" alt="7K)]8JE8I`IBQ5$W$IS20R1.png"></p><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;fanout-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">        <span class="comment">// 创建交换机</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码：<br>注意：<br>1 消费者和生产者要绑定同一个交换机<br>2 要先有队列，才能绑定</p><p>消费者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.QI_BI.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DeliverCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;multi_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="comment">//        for循环模拟创建两个消费者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">            channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line">            <span class="comment">//          指定每个消费者最多同时消费的消息数</span></span><br><span class="line">            channel.basicQos(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 定义了如何处理消息</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 处理工作</span></span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + <span class="string">&quot;编号:&quot;</span> + finalI + <span class="string">&quot;:&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    <span class="comment">// 消费消息后手动确认消息</span></span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">// 停 20 秒，模拟机器处理能力有限</span></span><br><span class="line">                    Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">//消费异常，</span></span><br><span class="line">                    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot; [x] Done&quot;</span>);</span><br><span class="line">                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 开启消费监听</span></span><br><span class="line">            channel.basicConsume(TASK_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h4><p>官方教程：<a href="https://www.rabbitmq.com/tutorials/tutorial-four-java.html">https://www.rabbitmq.com/tutorials/tutorial-four-java.html</a><br>绑定：可以让交换机和队列进行关联，可以指定让交互机把什么样的消息发送给哪个队列（类似于计算机网络中，两个路由器，或者网络设备相互连接，也可以理解为网线）<br>routingKey：路由键，控制消息要转发给哪个队列的（IP 地址）</p><p>特点：消息会根据路由键转发到指定的队列<br>场景：特定的消息只交给特定的系统（程序）来处理<br>绑定关系：完全匹配字符串</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1687007686788-76df21d6-428d-4d2d-abb7-4da819faf775.png?x-oss-process=image%2Fresize%2Cw_408%2Climit_0#averageHue=%23150000&amp;from=url&amp;id=zHKr5&amp;originHeight=171&amp;originWidth=408&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>一个路由键可以给多个队列<br>交换机里存放着所有的路由键<br>比如发日志的场景<br><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1687007976055-a38c33d2-490f-4582-b9ea-36b881c2101e.png?x-oss-process=image%2Fresize%2Cw_423%2Climit_0#averageHue=%23140000&amp;from=url&amp;id=Mjcsv&amp;originHeight=171&amp;originWidth=423&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>示例场景：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687955344132-80370d91-734f-4a15-b26c-fb1db9bf78a4.png#averageHue=%23fefdfd&amp;clientId=ucd6a0eb8-2a30-4&amp;from=paste&amp;height=379&amp;id=uf244fd0e&amp;originHeight=379&amp;originWidth=790&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=23995&amp;status=done&amp;style=none&amp;taskId=u01e2c8e7-77d8-4da2-b389-25f312add09&amp;title=&amp;width=790" alt="7V`W[UCM7CDP0@(_G0MY2]B.png"></p><p>消费者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;xiaoyu_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;xiaoyu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;xiaopi_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;xiaopi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">xiaoyuDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [xiaoyu] Received &#x27;&quot;</span> +</span><br><span class="line">                    delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">xiaopiDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [xiaopi] Received &#x27;&quot;</span> +</span><br><span class="line">                    delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, xiaoyuDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicConsume(queueName2, <span class="literal">true</span>, xiaopiDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot; with routing:&quot;</span> + routingKey + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Topic-交换机"><a href="#Topic-交换机" class="headerlink" title="Topic 交换机"></a>Topic 交换机</h4><p>官方教程：<a href="https://www.rabbitmq.com/tutorials/tutorial-five-java.html">https://www.rabbitmq.com/tutorials/tutorial-five-java.html</a></p><p>特点：消息会根据模糊的路由键转发给指定的队列<br>场景：特定的一类消息可以交给特定的一类系统来处理<br>绑定关系：可以模糊匹配多个绑定</p><ul><li><ul><li>匹配一个单词，比如*.orange，那么 a.orange、b.orange 都能匹配</li></ul></li><li><h1 id="：匹配-0-个或者多个单词，比如-a-，那么-a-a、a-b、a-a-a-都能匹配"><a href="#：匹配-0-个或者多个单词，比如-a-，那么-a-a、a-b、a-a-a-都能匹配" class="headerlink" title="：匹配 0 个或者多个单词，比如 a.#，那么 a.a、a.b、a.a.a 都能匹配"></a>：匹配 0 个或者多个单词，比如 a.#，那么 a.a、a.b、a.a.a 都能匹配</h1></li></ul><p>注意：这里的匹配和 mysql 的 like 的%不一样，只能按照单词来匹配，每个‘.’分隔单词，如果是’#.’，其实可以忽略，匹配 0 个也 ok<br><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1687009111794-08bd54bb-234d-4280-a604-852e2b01840c.png#averageHue=%23f8ecea&amp;from=url&amp;id=XUeMy&amp;originHeight=622&amp;originWidth=1479&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>应用场景：<br>老板要下发一个任务，让多个组来处理<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687955866934-02d32e8e-3ff3-41b9-811d-eb0d2ea4d925.png#averageHue=%23fefdfd&amp;clientId=ucd6a0eb8-2a30-4&amp;from=paste&amp;height=622&amp;id=u16876434&amp;originHeight=622&amp;originWidth=760&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=36630&amp;status=done&amp;style=none&amp;taskId=uc426ae3a-ba42-45aa-a211-c9b9675ca44&amp;title=&amp;width=760" alt="M01_LSD@J@6GLGNYQ1@C_1W.png"></p><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">         <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line"></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot; with routing:&quot;</span> + routingKey + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">    factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建队列</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;frontend_queue&quot;</span>;</span><br><span class="line">      channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;#.前端.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建队列</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;backend_queue&quot;</span>;</span><br><span class="line">      channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      channel.queueBind(queueName2, EXCHANGE_NAME, <span class="string">&quot;#.后端.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建队列</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">queueName3</span> <span class="operator">=</span> <span class="string">&quot;product_queue&quot;</span>;</span><br><span class="line">      channel.queueDeclare(queueName3, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">      channel.queueBind(queueName3, EXCHANGE_NAME, <span class="string">&quot;#.产品.#&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">DeliverCallback</span> <span class="variable">xiaoaDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot; [xiaoa] Received &#x27;&quot;</span> +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="type">DeliverCallback</span> <span class="variable">xiaobDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot; [xiaob] Received &#x27;&quot;</span> +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="type">DeliverCallback</span> <span class="variable">xiaocDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot; [xiaoc] Received &#x27;&quot;</span> +</span><br><span class="line">                  delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      channel.basicConsume(queueName, <span class="literal">true</span>, xiaoaDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">      &#125;);</span><br><span class="line">      channel.basicConsume(queueName2, <span class="literal">true</span>, xiaobDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">      &#125;);</span><br><span class="line">      channel.basicConsume(queueName3, <span class="literal">true</span>, xiaocDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Headers-交换机"><a href="#Headers-交换机" class="headerlink" title="Headers 交换机"></a>Headers 交换机</h4><p>类似主题和直接交换机，可以根据 headers 中的内容来指定发送到哪个队列<br>由于性能差、比较复杂，一般不推荐使用。</p><blockquote><p>AI 学习连环问：是什么？有什么用？什么场景下会用？有什么优缺点？有没有示例代码？</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1687011466810-28a7cdc5-e42c-45f5-aa8c-2635c41e0a89.png?x-oss-process=image%2Fresize%2Cw_400%2Climit_0#averageHue=%23ccdbf3&amp;from=url&amp;id=Og523&amp;originHeight=1235&amp;originWidth=400&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h4><p>支持用消息队列来模拟 RPC 的调用，但是一般没必要，直接用 Dubbo、GRPC 等 RPC 框架就好了。</p><h3 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h3><h4 id="消息过期机制"><a href="#消息过期机制" class="headerlink" title="消息过期机制"></a>消息过期机制</h4><p>官方文档：<a href="https://www.rabbitmq.com/ttl.html">https://www.rabbitmq.com/ttl.html</a></p><p>可以给每个消息指定一个有效期，一段时间内未处理，就过期<br>示例场景：消费者（库存系统）挂了，一个订单 15 分钟还没有被库存清理，这个订单其实已经失效了，哪怕库存系统恢复，也不扣库存<br>试用场景：<br>订单系统中顾客下单、模拟延迟队列的实现（区分 vip 和普通用户）、专门让某个程序处理过期的请求<br>1）给队列中的所有消息指定过期时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列，指定消息过期参数</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// args 指定参数</span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1687012172430-53fff46b-6383-40c9-99ae-bc96667f71d4.png#averageHue=%23ebe6e5&amp;from=url&amp;id=mBQr0&amp;originHeight=468&amp;originWidth=1010&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>如果在过期时间内，还没有消费者取消息，消息才会过期。<br>注意，如果消息已经收到，但是没有确认，是不会过期的</p><blockquote><p>如果消息处于代消费状态并且过期时间到达后，消息将被标记为过期。但是，如果消息已经处于正在处理的过程，即将过期，消息仍然会被正常处理，不会过期</p></blockquote><p>消费者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ttl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建队列，指定消息过期参数</span></span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// args 指定参数</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义了如何处理消息</span></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 消费消息，会持续阻塞</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产者示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ttl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//        factory.setUsername();</span></span><br><span class="line"><span class="comment">//        factory.setPassword();</span></span><br><span class="line"><span class="comment">//        factory.setPort();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接、创建频道</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)给某条消息指定过期时间<br>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给消息指定过期时间</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder()</span><br><span class="line">        .expiration(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">channel.basicPublish(<span class="string">&quot;my-exchange&quot;</span>, <span class="string">&quot;routing-key&quot;</span>, properties, message.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ttl_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建连接工厂</span></span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//        factory.setUsername();</span></span><br><span class="line"><span class="comment">//        factory.setPassword();</span></span><br><span class="line"><span class="comment">//        factory.setPort();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立连接、创建频道</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 发送消息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给消息指定过期时间</span></span><br><span class="line">            AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties.Builder()</span><br><span class="line">                    .expiration(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;my-exchange&quot;</span>, <span class="string">&quot;routing-key&quot;</span>, properties, message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h4><p>官方文档：<a href="https://www.rabbitmq.com/confirms.html">https://www.rabbitmq.com/confirms.html</a><br>为了保证消息被正常消费（快递员取走），rabbitMQ 提供了消息确认机制，当消费者收到消息后，要给一个反馈。</p><ul><li>ack 消费成功</li><li>nack 消费失败</li><li>reject 拒绝</li></ul><p>如果告诉 rabbitMQ 服务器消费成功，服务器才会放心移除消息。<br>支持配置 autoack，会自动执行 ack 命令，接到消息立刻就成功了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.basicConsume(TASK_QUEUE_NAME, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>一般情况，建议 autoack 改为 false，根据实际情况，去手动确认。</p><p>指定确认某条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), );</span><br></pre></td></tr></table></figure><p>第二个参数 multiple 批量确认；是指是否要一次性确认所有的历史消息直到当前这一条</p><p>拒绝某条消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>第二个 参数指示是否拒绝多条消息，如果为 true，则拒绝所有比给定 deliveryTag 小或等于它的未确认消息；如果为 false，则只拒绝指定 deliveryTag 的消息。<br>第三个参数表示是否重新入队，用于重试</p><p>与之相反，<strong>basicReject</strong> 方法是另一种拒绝消息的方式，它只能拒绝单个消息，并且只能将消息重新放回队列。如果您需要拒绝多条消息或选择性地将消息重新放回队列或直接丢弃，那么您应该使用 basicNack 方法。</p><h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>官方文档：<a href="https://www.rabbitmq.com/dlx.html">https://www.rabbitmq.com/dlx.html</a></p><p>为了保证消息的可靠性，比如每条消息都成功消费，需要提供一个容错机制，即：失败的消息怎么处理？<br>死信：过期的消息、拒收的消息、消息队列满了、处理失败的消息的统称<br>死信队列：专门处理死信的队列（注意，它就是一个普通队列，只不过是专门用来处理死信的，你甚至可以理解这个队列的名称叫 “死信队列”）</p><p>死信交换机：专门给死信队列转发消息的交换机（注意，它就是一个普通交换机，只不过是专门给死信队列发消息而已，理解为这个交换机的名称就叫 “死信交换机”）。也存在路由绑定<br>死信可以通过死信交换机绑定到死信队列。</p><p>示例场景：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1687964741456-462605ae-f905-4fbd-ae73-327dbf685706.png#averageHue=%23fdfdfd&amp;clientId=ucd6a0eb8-2a30-4&amp;from=paste&amp;height=597&amp;id=ud8150982&amp;originHeight=597&amp;originWidth=748&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=27670&amp;status=done&amp;style=none&amp;taskId=uc97c0fe9-d41a-4306-af3f-9c3cb997c43&amp;title=&amp;width=748" alt="1687964679285.png"></p><p>实现：<br>1）创建死信交换机和死信队列，并且绑定关系<br><img src="https://cdn.nlark.com/yuque/0/2023/png/398476/1687013888188-1bde4fc6-73c1-48e4-b9c8-7d231a4e5a72.png#averageHue=%23fcfcfc&amp;from=url&amp;id=ZZ33J&amp;originHeight=418&amp;originWidth=772&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>2）给失败之后需要容错处理的队列绑定死信交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定死信队列参数</span></span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 要绑定到哪个交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line"><span class="comment">// 指定死信要转发到哪个死信队列</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;waibao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;xiaodog_queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;xiaodog&quot;</span>);</span><br></pre></td></tr></table></figure><p>3）可以给要容错的队列指定死信之后的转发规则，死信应该再转发到哪个死信队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定死信要转发到哪个死信队列</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;waibao&quot;</span>);</span><br></pre></td></tr></table></figure><p>4）可以通过程序来读取死信队列中的消息，从而进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;laoban_dlx_queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, DEAD_EXCHANGE_NAME, <span class="string">&quot;laoban&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;waibao_dlx_queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName2, DEAD_EXCHANGE_NAME, <span class="string">&quot;waibao&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">laobanDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 拒绝消息</span></span><br><span class="line">    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; [laoban] Received &#x27;&quot;</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">waibaoDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="comment">// 拒绝消息</span></span><br><span class="line">    channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot; [waibao] Received &#x27;&quot;</span> +</span><br><span class="line">            delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.basicConsume(queueName, <span class="literal">false</span>, laobanDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">channel.basicConsume(queueName2, <span class="literal">false</span>, waibaoDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>完整生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxDirectProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;dlx-direct-exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WORK_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct2-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">             <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;</span><br><span class="line">            <span class="comment">// 声明死信交换机</span></span><br><span class="line">            channel.exchangeDeclare(DEAD_EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;laoban_dlx_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(queueName, DEAD_EXCHANGE_NAME, <span class="string">&quot;laoban&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;waibao_dlx_queue&quot;</span>;</span><br><span class="line">            channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">            channel.queueBind(queueName2, DEAD_EXCHANGE_NAME, <span class="string">&quot;waibao&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">laobanDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息</span></span><br><span class="line">                channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [laoban] Received &#x27;&quot;</span> +</span><br><span class="line">                        delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="type">DeliverCallback</span> <span class="variable">waibaoDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息</span></span><br><span class="line">                channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot; [waibao] Received &#x27;&quot;</span> +</span><br><span class="line">                        delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            channel.basicConsume(queueName, <span class="literal">false</span>, laobanDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line">            channel.basicConsume(queueName2, <span class="literal">false</span>, waibaoDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">userInput</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                String[] strings = userInput.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (strings.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> strings[<span class="number">0</span>];</span><br><span class="line">                <span class="type">String</span> <span class="variable">routingKey</span> <span class="operator">=</span> strings[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                channel.basicPublish(WORK_EXCHANGE_NAME, routingKey, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="string">&quot; with routing:&quot;</span> + routingKey + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消费者完整代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxDirectConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;dlx-direct-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WORK_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct2-exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">        factory.setHost(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        channel.exchangeDeclare(WORK_EXCHANGE_NAME, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定死信队列参数</span></span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 要绑定到哪个交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">        <span class="comment">// 指定死信要转发到哪个死信队列</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;waibao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;xiaodog_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br><span class="line">        channel.queueBind(queueName, WORK_EXCHANGE_NAME, <span class="string">&quot;xiaodog&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; args2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        args2.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE_NAME);</span><br><span class="line">        args2.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;laoban&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建队列，随机分配一个队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;xiaocat_queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName2, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, args2);</span><br><span class="line">        channel.queueBind(queueName2, WORK_EXCHANGE_NAME, <span class="string">&quot;xiaocat&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot; [*] Waiting for messages. To exit press CTRL+C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">xiaoyuDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 拒绝消息</span></span><br><span class="line">            channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [xiaodog] Received &#x27;&quot;</span> +</span><br><span class="line">                    delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">xiaopiDeliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 拒绝消息</span></span><br><span class="line">            channel.basicNack(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot; [xiaocat] Received &#x27;&quot;</span> +</span><br><span class="line">                    delivery.getEnvelope().getRoutingKey() + <span class="string">&quot;&#x27;:&#x27;&quot;</span> + message + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">false</span>, xiaoyuDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">        channel.basicConsume(queueName2, <span class="literal">false</span>, xiaopiDeliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ-重要知识"><a href="#RabbitMQ-重要知识" class="headerlink" title="RabbitMQ 重要知识"></a>RabbitMQ 重要知识</h3><blockquote><p>也是面试考点</p></blockquote><ol><li>消息队列的概念、模型、应用场景</li></ol><p>概念:<br>消息队列就是存储消息的队列。<br>模型：<br>生产者：Producer，类比为快递员，发送消息的人（客户端）<br>消费者：Consumer，类比为取快递的人，接受读取消息的人（客户端）<br>消息：Message，类比为快递，就是生产者要传输给消费者的数据<br>消息队列：Queue 为什么不接传输，要用消息队列？生产者不用关心你的消费者要不要消费、什么时候消费，我只需要把东西给消息队列，我的工作就算完成了。 生产者和消费者实现了解耦，互不影响。<br>应用场景: 1.耗时的场景（异步） 2.高并发场景（异步、削峰填谷） 3.分布式系统协作（跨团队、跨业务、应用解耦）<br>比如 QQ 是一个系统，用 c++写的，微信用 java 写的，qq 的消息可以通过消息队列传送给微信 4.强稳定性的场景（金融业务、持久化、可靠性、削峰填谷）<br>支付、转账</p><ol><li>交换机的类别、路由绑定的关系<ol><li>Fanout</li><li>Direct</li><li>Topic</li><li>Headers</li><li>RPC</li></ol></li></ol><p>扇形交换机（Fanout Exchange）：在扇形交换机中，绑定不需要指定路由键。交换机会将消息广播到所有与之绑定的队列，忽略消息的路由键。<br>直连交换机（Direct Exchange）：在直连交换机中，绑定需要指定一个特定的路由键。当消息的路由键与绑定的路由键完全匹配时，消息将被路由到与之绑定的队列。<br>主题交换机（Topic Exchange）：在主题交换机中，绑定使用模式匹配的路由键。路由键可以包含通配符 <em> 和 #。</em> 匹配一个单词，# 匹配零个或多个单词。交换机将消息根据路由键与绑定的模式进行匹配，然后路由到相应的队列。<br>标头交换机（Headers Exchange）：在标头交换机中，绑定使用消息的标头信息进行匹配。绑定时可以指定一组键值对，当消息的标头信息与绑定的键值对匹配时，消息将被路由到相应的队列。</p><ol><li>消息可靠性<br>a 消息确认机制（ack、nack、reject）<br>b 消息持久化（durable）<br>首先，您需要确保队列本身是持久化的，以防止在 RabbitMQ 服务器重启或崩溃时丢失队列的定义和消息。其次，您需要确保消息本身是持久化的，以便在服务器重启或崩溃后仍然保留消息。在发布消息时，可以通过设置 deliveryMode 参数为 2 来使消息持久化。</li></ol><p>c 消息过期机制<br>d 死信队列<br>消费过程中可能存在消息消费失败、消息过期、消息达到最大重试次数、消息被拒绝等情况，死信队列为消息处理提供了一种容错机制，确保系统能够对异常情况进行适当的处理，并提高消息系统的可靠性和稳定性</p><ol><li>延迟队列（类似死信队列）</li><li>顺序消费、消费幂等性（本次不讲）</li><li>可扩展性（仅作了解）<br>a 集群<br>b 故障的恢复机制<br>c 镜像</li><li>运维监控告警（仅作了解）</li></ol><h2 id="Mq-设计基础知识"><a href="#Mq-设计基础知识" class="headerlink" title="Mq 设计基础知识"></a>Mq 设计基础知识</h2><p><strong>多线程版本 mq；</strong><br><strong>基于网络通讯版本 mq netty 实现</strong></p><h3 id="基于多线程队列简单实现-mq"><a href="#基于多线程队列简单实现-mq" class="headerlink" title="基于多线程队列简单实现 mq"></a>基于多线程队列简单实现 mq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>:22603</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Date</span>:2023/3/3 15:23</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMQ</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedBlockingDeque&lt;JSONObject&gt;linkedBlockingDeque=<span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">                        jsonObject.put(<span class="string">&quot;phone&quot;</span>, <span class="string">&quot;18790034997&quot;</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,获取到数据:&quot;</span> + jsonObject.toJSONString());</span><br><span class="line">                        linkedBlockingDeque.offer(jsonObject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产额&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">JSONObject</span> <span class="variable">poll</span> <span class="operator">=</span> linkedBlockingDeque.poll();</span><br><span class="line">                    <span class="keyword">while</span> (poll != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;,获取到数据:&quot;</span> + poll.toJSONString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        customer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于-netty-实现-mq"><a href="#基于-netty-实现-mq" class="headerlink" title="基于 netty 实现 mq"></a>基于 netty 实现 mq</h3><p>消费者 netty 客户端与 nettyServer 端 MQ 服务器端保持长连接，MQ 服务器端保存<br>消费者连接。<br>生产者 netty 客户端发送请求给 nettyServer 端 MQ 服务器端，MQ 服务器端在将该<br>消息内容发送给消费者。</p><p>body:{“msg”:{“userId”:”123456”,”age”:”23”},”type”:”producer”，”topic”:””}<br><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1677922569697-19813871-c904-431a-bbf5-ce353198fc3e.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1677922569697-19813871-c904-431a-bbf5-ce353198fc3e.java%22%2C%22name%22%3A%22NettyMQServer.java%22%2C%22size%22%3A7210%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u0ca88953-3f38-4e45-984b-3635444ee04%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22uc92a400b%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">NettyMQServer.java</a><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1677922569698-50ef2ac6-6029-45a6-affa-91b513fd2597.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1677922569698-50ef2ac6-6029-45a6-affa-91b513fd2597.java%22%2C%22name%22%3A%22NettyMQConsumer.java%22%2C%22size%22%3A4182%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u495980a7-67b8-4244-93e9-43d7a4a2073%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u57358565%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">NettyMQConsumer.java</a><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1677922569722-760c8e69-dd07-46c2-a6d3-e1cdb34fb5be.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1677922569722-760c8e69-dd07-46c2-a6d3-e1cdb34fb5be.java%22%2C%22name%22%3A%22NettyMQProduce.java%22%2C%22size%22%3A4579%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u9a7a267a-f4c8-4d80-a791-f4129711153%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ud6e420a2%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">NettyMQProduce.java</a></p><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><p>生产者投递消息给 MQ 服务器端，MQ 服务器端需要缓存该消息<br>如果 mq 服务器端宕机之后，消息如何保证不丢失</p><ol><li>持久化机制<br>① 生产者投递消息给消费者，消息不只是放在内存里，他也会持久化到我们的硬盘中<br>② 消息支持持久化到 Commitlog 里面，即使宕机后重启，未消费的消息也是可以加载出来的</li></ol><p>2、如果 mq 接收到生产者投递消息，如果消费者不在的情况下，该消息是否会丢失？<br>不会丢失，消息确认机制必须要消费者消费该消息成功之后，在通知给 mq 服务器端<br>删除该消息。</p><p>3、冗余部署：采用冗余部署的架构，使用多个 MQ 服务器组成集群或者使用主从复制机制。当主服务器宕机时，备份服务器可以接管服务，并保证消息的持久化和可靠传递。</p><p>4、数据备份与恢复：定期备份 MQ 服务器上的消息数据，并确保备份数据的完整性和可靠性。在服务器宕机后，可以通过恢复备份数据来恢复消息队列的状态。</p><p>5、监控与报警：建立监控系统，实时监测 MQ 服务器的状态。一旦服务器发生故障或宕机，及时触发报警机制，以便管理员能够尽快采取措施来保护消息不丢失。</p><p><strong>Mq 服务器端将该消息推送消费者和费者主动拉取消息的区别？</strong></p><p><strong>Mq 服务器端将该消息推送消费者：</strong><br>消费者已经和 mq 服务器保持长连接。</p><p><strong>消费者主动拉取消息：</strong><br>消费者第一次刚启动的时候</p><p><strong>两者区别：生产者将消息推送给 mq 服务器端，mq 服务器端发现消费者不在的情况下，就会将消息缓存起来，随后消费者上线与 mq 服务器建立连接，拉取消息的过程属于消费者主动拉取消息，消费者消费消息后，会通知 mq 服务器端删除该消息，随后生产者将消息推送给 mq 服务器端，mq 服务器在已经与消费者建立连接的情况下，主动将消息推送给消费者。</strong></p><p><strong>Mq 如何实现抗高并发思想？</strong></p><ol><li>异步处理：将业务逻辑解耦并异步化，通过将请求转化为消息并发送到消息队列中，而不是直接同步处理请求。这样可以将高并发的请求转化为消息并发放到消息队列中，让消费者以适合的速率进行处理，从而实现系统的高并发能力。</li><li>消息并发消费：通过增加消费者的数量，实现消息的并发消费能力。通过水平扩展消费者，可以增加系统的处理能力和并发处理的吞吐量。</li><li>消费者负载均衡：在有多个消费者的情况下，可以使用负载均衡策略来平均分配消息的处理负载。常见的负载均衡策略包括轮询、随机、最少连接等，确保消息能够平均地分发给多个消费者进行处理。</li><li>消息预取（Prefetch）：消息队列通常支持设置消费者的预取数量，即一次从队列中预取的消息数量。通过适当调整预取数量，可以提高消费者的处理效率和系统的吞吐量。</li><li>限流和流量控制：通过设置适当的限流策略和流量控制机制，控制消息的发送速率和消费速率。这可以避免系统被过多的请求压垮，保持系统的稳定性和可靠性。</li><li>消息批量处理：对于大量的小消息，可以进行批量处理，将多个消息打包成一个批次进行处理，减少系统的开销和通信成本。</li><li>消息重试和幂等性：在高并发场景下，可能会出现消息处理失败的情况。通过实现消息的重试机制和保证消息处理的幂等性，可以避免因为重复消息或消息处理失败而引发的问题。</li><li>高可用和故障恢复：通过使用多个消息队列节点和复制机制，实现高可用性和故障恢复能力。当某个节点发生故障时，其他节点可以接替其工作，确保系统的稳定性和可用性。</li></ol><p>缺点：存在延迟的问题</p><p><strong>如何避免 mq 消息堆积问题？</strong></p><p>需要考虑 mq 消费者提高速率的问题：<br>如何消费者提高速率：<strong>消费者实现集群、消费者批量获取消息即可。</strong><br>提供多个消费者，每个消费者每次取一百或者十条，从而提高效率</p><h4 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h4><p>| ```</p><dependencies><pre><code> &lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;     &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;io.netty&lt;/groupId&gt;     &lt;artifactId&gt;netty-all&lt;/artifactId&gt;     &lt;version&gt;4.0.23.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;     &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt;     &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;     &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;     &lt;version&gt;3.11&lt;/version&gt; &lt;/dependency&gt;</code></pre><p>   &lt;/dependencies&gt;<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">| |</span><br><span class="line">| |</span><br><span class="line"></span><br><span class="line"># RabbitMQ</span><br><span class="line"></span><br><span class="line">## RabbitMQ 基本介绍</span><br><span class="line"></span><br><span class="line">RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），RabbitMQ 服务器是用 Erlang 语言编写的。</span><br><span class="line">RabitMQ 官方网站:</span><br><span class="line">[https://www.rabbitmq.com/](https://www.rabbitmq.com/) 1.点对点(简单)的队列 2.工作(公平性)队列模式 3.发布订阅模式 4.路由模式 Routing 5.通配符模式 Topics</span><br><span class="line">6.RPC</span><br><span class="line">https://www.rabbitmq.com/getstarted.html</span><br><span class="line"></span><br><span class="line">## RabbitMQ 环境的基本安装</span><br><span class="line"></span><br><span class="line">1.下载并安装 erlang,下载地址：http://www.erlang.org/download 2.配置 erlang 环境变量信息</span><br><span class="line">新增环境变量 ERLANG_HOME=erlang 的安装地址</span><br><span class="line">将%ERLANG_HOME%\bin 加入到 path 中 3.下载并安装 RabbitMQ，下载地址：http://www.rabbitmq.com/download.html</span><br><span class="line">注意: RabbitMQ 它依赖于 Erlang,需要先安装 Erlang。</span><br><span class="line">[https://www.rabbitmq.com/install-windows.html](https://www.rabbitmq.com/install-windows.html)</span><br><span class="line"></span><br><span class="line">安装教程：[https://blog.csdn.net/tirster/article/details/121938987](https://blog.csdn.net/tirster/article/details/121938987)</span><br><span class="line"></span><br><span class="line">### 安装 RabbitMQ 环境步骤</span><br><span class="line"></span><br><span class="line">配置 Erlang 环境变量：</span><br><span class="line"></span><br><span class="line">### 如何启动 Rabbitmq</span><br><span class="line"></span><br><span class="line">net start RabbitMQ</span><br><span class="line"></span><br><span class="line">### 启动 Rabbitmq 常见问题</span><br><span class="line"></span><br><span class="line">如果 rabbitmq 启动成功无法访问管理平台页面</span><br><span class="line"></span><br><span class="line">进入到 F:\path\rabbitmq\rabbitmq\rabbitmq_server-3.6.9\sbin&gt;</span><br><span class="line">执行</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line">rabbitmqctl start_app</span><br><span class="line"></span><br><span class="line">### Rabbitmq 管理平台中心</span><br><span class="line"></span><br><span class="line">RabbitMQ 管理平台地址 http://127.0.0.1:15672</span><br><span class="line">默认账号:guest/guest 用户可以自己创建新的账号</span><br><span class="line"></span><br><span class="line">Virtual Hosts:</span><br><span class="line">像 mysql 有数据库的概念并且可以指定用户对库和表等操作的权限。那 RabbitMQ 呢？</span><br><span class="line">RabbitMQ 也有类似的权限管理。在 RabbitMQ 中可以虚拟消息服务器 VirtualHost，每</span><br><span class="line">个 VirtualHost 相当月一个相对独立的 RabbitMQ 服务器，每个 VirtualHost 之间是相互</span><br><span class="line">隔离的。exchange、queue、message 不能互通。</span><br><span class="line"></span><br><span class="line">默认的端口 15672：rabbitmq 管理平台端口号</span><br><span class="line">默认的端口 5672： rabbitmq 消息中间内部通讯的端口</span><br><span class="line">默认的端口号 25672 rabbitmq 集群的端口号</span><br><span class="line"></span><br><span class="line">### RabbitMQ 常见名词</span><br><span class="line"></span><br><span class="line">/Virtual Hosts---分类</span><br><span class="line">/队列存放我们消息</span><br><span class="line">Exchange 分派我们消息在那个队列存放起来类似于 nginx</span><br><span class="line"></span><br><span class="line">15672---rabbitmq 控制台管理平台 http 协议</span><br><span class="line">25672rabbitmq 集群通信端口号</span><br><span class="line">Amqp 5672 rabbitmq 内部通信的一个端口号</span><br><span class="line"></span><br><span class="line">### RabbitMQ 创建账户</span><br><span class="line"></span><br><span class="line">### RabbitMQ 平台创建 Virtual Hosts</span><br><span class="line"></span><br><span class="line">### RabbitMQ 平台创建消息队列</span><br><span class="line"></span><br><span class="line">## 快速入门 RabbitMQ 简单队列</span><br><span class="line"></span><br><span class="line">首先需要再 RabbitMQ 平台创建 Virtual Hosts 和队列。</span><br><span class="line">/meiteVirtualHosts</span><br><span class="line">----订单队列</span><br><span class="line">----支付队列</span><br><span class="line"></span><br><span class="line">1.        在RabbitMQ平台创建一个队列；</span><br><span class="line">2.        在编写生产者代码</span><br><span class="line">3.        在编写消费者代码</span><br><span class="line"></span><br><span class="line">### RabbitMQ 如何保证消息不丢失</span><br><span class="line"></span><br><span class="line">先来看看消息都有可能再哪些环节丢失</span><br><span class="line">![JZ9O8F]IZ$ND00NCWW[R2(D.png](https://cdn.nlark.com/yuque/0/2023/png/33551426/1678063490365-7adcdad9-0f2b-4208-9a45-51079bbc7de8.png#averageHue=%23f8f8f8&amp;clientId=ub4a67b8a-2261-4&amp;from=paste&amp;height=200&amp;id=u467660a7&amp;originHeight=200&amp;originWidth=677&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=11164&amp;status=done&amp;style=none&amp;taskId=u30c0e8f7-b810-48b6-b612-f69425b7ca3&amp;title=&amp;width=677)</span><br><span class="line">Mq 如何保证消息不丢失：</span><br><span class="line"></span><br><span class="line">1.        生产者角色</span><br><span class="line"></span><br><span class="line">    由于网络波动导致消息发送失败</span><br><span class="line">    确保生产者投递消息到 MQ 服务器端成功。</span><br><span class="line">    解决:Ack 消息确认机制</span><br><span class="line">    存在同步或者异步的形式，同步会存在生产者将消息发送给 MQ 服务器端，MQ 服务器端未能及时响应给生产者，就会导致生产者服务延迟阻塞，响应给客户端。异步是在生产者和 MQ 服务第端之间会有一个观察者进行事件监听，只要 MQ 服务器端将消息持久化到硬盘，MQ 服务器端再给监听方法发通知，说明消息发送成功了。如果消息多久时间内一直未给响应结果的情况下，我们可以人为进行重试。</span><br><span class="line">    方式 1：Confirms 方式 2：事务消息</span><br><span class="line"></span><br><span class="line">2.        消费者角色</span><br><span class="line">    消费者在消费完消息之前宕机，MQ 服务器端认为认为消息消费成功，并把存储在内存中的消息删除，导致消息丢失</span><br><span class="line">    解决:</span><br><span class="line">    在 rabbitmq 情况下引入了消息应答机制：</span><br><span class="line">    必须要将消息消费成功之后，才会将该消息从 mq 服务器端中移除。</span><br><span class="line">    在 kafka 中的情况下：</span><br><span class="line">    不管是消费成功还是消费失败，该消息都不会立即从 mq 服务器端移除。</span><br><span class="line">    在 kafka 中，消费者宕机，MQ 服务器端如何判断这个消息消费了多少呢，kafka 中引入了分区 off、set，他会记录消费者消费了这个消息的哪个偏移量，消费者知道该从哪开始消费，消息清理，一般会有定时器在几天后定时把消费成功的消息进行清理</span><br><span class="line">3.        MQ服务器端把消息发送给消费者前宕机</span><br><span class="line"></span><br><span class="line">    Mq 服务器端在默认的情况下都会对队列中的消息实现持久化</span><br><span class="line">    持久化硬盘。</span><br><span class="line"></span><br><span class="line">4.  使用消息确认机制+持久技术</span><br><span class="line">    A.消费者确认收到消息机制</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, false, defaultConsumer);</span><br><span class="line">    注：第二个参数值为 false 代表关闭 RabbitMQ 的自动应答机制，改为手动应答。</span><br><span class="line">    在处理完消息时，返回应答状态，true 表示为自动应答模式。</span><br><span class="line">    channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">    B.生产者确认投递消息成功 使用 Confirm 机制 或者事务消息</span><br><span class="line"></span><br><span class="line">Confirm 机制：</span><br><span class="line">生产者将 Channel 设置成 confirm 模式，一旦 Channel 进入 confirm 模式，所有在该 Channel 上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker 回传给生产者的确认消息中 delivery-tag 域包含了确认消息的序列号，此外 broker 也可以设置 basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理；</span><br><span class="line">confirm 模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等 Channel 返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果 RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息；</span><br><span class="line">事务模式： channel.txSelect(); _//开启事务_</span><br><span class="line">channel.txCommit(); _//提交事务_</span><br><span class="line">channel.txRollback(); _//回滚_</span><br><span class="line">在通过 txSelect 开启事务之后，我们便可以发布消息给 broker 服务器了，如果 txCommit 提交成功了，则消息一定到达了 broker 了，如果在 txCommit 执行之前 broker 异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过 txRollback 回滚事务了。</span><br><span class="line"></span><br><span class="line">这里注意一下：txSelect 与 Confirm 模式不能共存。</span><br><span class="line">Confirm 模式的三种编程方式：</span><br><span class="line"></span><br><span class="line">1. 串行 confirm 模式：peoducer 每发送一条消息后，调用 waitForConfirms()方法，等待 broker 端 confirm。</span><br><span class="line">2. 批量 confirm 模式：producer 每发送一批消息后，调用 waitForConfirms()方法，等待 broker 端 confirm。</span><br><span class="line">3. 异步 confirm 模式：提供一个回调方法，broker confirm 了一条或者多条消息后 producer 端会回调这个方法。</span><br><span class="line"></span><br><span class="line">2.RabbitMQ 默认创建是持久化的</span><br><span class="line"></span><br><span class="line">代码中设置 durable 为 true</span><br><span class="line"></span><br><span class="line">参数名称详解：</span><br><span class="line">durable 是否持久化 durable 为持久化、 Transient 不持久化</span><br><span class="line">autoDelete 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过 RabbitMQ Management，查看某个队列的消费者数量，当 consumers = 0 时队列就会自动删除 2. 使用 rabbitmq 事务消息；</span><br><span class="line"></span><br><span class="line">| ```java</span><br><span class="line">channel.txSelect();</span><br><span class="line"></span><br><span class="line">channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());</span><br><span class="line"></span><br><span class="line">// int i = 1 / 0;</span><br><span class="line"></span><br><span class="line">channel.txCommit();</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 相关核心代码</span><br><span class="line">##### 生产者</span><br><span class="line">| ```java</span><br><span class="line">package com.example.demo1.RabbitMQ;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author:22603</span><br><span class="line">* @Date:2023/3/6 0:39</span><br><span class="line">*/</span><br><span class="line">public class ProduceMQ &#123;</span><br><span class="line"></span><br><span class="line">    public static final String QUEUE_NAME=&quot;StudyingQueues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Connection connection=ConnectionMQ.getConnect();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String msg=&quot;MQ你好呀啊222&quot;;</span><br><span class="line">        channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,msg.getBytes());</span><br><span class="line">        //       关闭通道和连接</span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">channel.confirmSelect();```java</span><br><span class="line">package com.example.demo1.RabbitMQ;</span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line">import com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- @author:22603</span><br><span class="line">- @Date:2023/3/6 0:29</span><br><span class="line">  \*/</span><br><span class="line">  public class ConnectionMQ &#123;</span><br><span class="line"></span><br><span class="line">      public static Connection getConnect() throws IOException, TimeoutException &#123;</span><br><span class="line">          ConnectionFactory connectionFactory=new ConnectionFactory();</span><br><span class="line">          //        设置连接的virtualhost</span><br><span class="line">          connectionFactory.setVirtualHost(&quot;/Study&quot;);</span><br><span class="line">          //        设置用户名密码</span><br><span class="line">          connectionFactory.setUsername(&quot;guest&quot;);</span><br><span class="line">          connectionFactory.setPassword(&quot;guest&quot;);</span><br><span class="line">          //        设置端口号和地址</span><br><span class="line">          connectionFactory.setPort(5672);</span><br><span class="line">          connectionFactory.setHost(&quot;127.0.0.1&quot;);</span><br><span class="line">          return connectionFactory.newConnection();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 消费者</span><br><span class="line">| ```java</span><br><span class="line">package com.example.demo1.RabbitMQ;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author:22603</span><br><span class="line">* @Date:2023/3/6 0:39</span><br><span class="line">*/</span><br><span class="line">public class CustomMQ &#123;</span><br><span class="line"></span><br><span class="line">    public static final String QUEUE_NAME=&quot;StudyingQueues&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">        Connection connection=ConnectionMQ.getConnect();</span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        DefaultConsumer consumer=new DefaultConsumer(channel)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">                String msg=new String(body,&quot;utf-8&quot;);</span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //        监听队列</span><br><span class="line">        //        autoAck true 自动签收 false 手动签收</span><br><span class="line">        channel.basicConsume(QUEUE_NAME,true,consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">| |</span><br><span class="line">| |</span><br><span class="line"></span><br><span class="line">## RabbitMQ 五种消息模式</span><br><span class="line"></span><br><span class="line">### RabitMQ 工作队列</span><br><span class="line"></span><br><span class="line">默认的传统队列是为均摊消费，存在不公平性；如果每个消费者速度不一样的情况下，均摊消费是不公平的，应该是能者多劳。</span><br><span class="line">采用工作队列</span><br><span class="line">在通道中只需要设置 basicQos 为 1 即可，表示 MQ 服务器每次只会给消费者推送 1 条消息必须手动 ack 确认之后才会继续发送。</span><br><span class="line">channel.basicQos(1);</span><br><span class="line"></span><br><span class="line">### RabbitMQ 交换机类型</span><br><span class="line"></span><br><span class="line">Direct exchange（直连交换机）</span><br><span class="line">Fanout exchange（扇型交换机）</span><br><span class="line">Topic exchange（主题交换机）</span><br><span class="line">Headers exchange（头交换机）</span><br><span class="line">/Virtual Hosts---区分不同的团队</span><br><span class="line">----队列存放消息</span><br><span class="line">----交换机路由消息存放在那个队列中类似于 nginx</span><br><span class="line">---路由 key 分发规则</span><br><span class="line"></span><br><span class="line">## Direct Exchange</span><br><span class="line"></span><br><span class="line">直连交换机，根据 Routing Key(路由键)进行投递到不同队列。</span><br><span class="line">单个绑定，一个路由键对应一个队列。如下所示：</span><br><span class="line"></span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2023/png/33551426/1678158420140-54852ce3-04e7-40d7-a60b-7340d21e1fb0.png#averageHue=%23150000&amp;clientId=uf635b9a6-f378-4&amp;from=paste&amp;id=u8ea614a2&amp;originHeight=171&amp;originWidth=408&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ucefd7391-ea58-4e8e-898d-9d475721ba1&amp;title=)</span><br><span class="line">多个绑定，一个路由键对应多个队列，则消息会分别投递到两个队列中，如下所示：</span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2023/png/33551426/1678158420167-b0448137-666c-453a-9c1b-4275e5cbcfe5.png#averageHue=%23160000&amp;clientId=uf635b9a6-f378-4&amp;from=paste&amp;id=u1783ecdb&amp;originHeight=171&amp;originWidth=398&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u90472250-3f5e-48e2-971f-27fe37d1d41&amp;title=)</span><br><span class="line"></span><br><span class="line">## Fanout Exchange</span><br><span class="line"></span><br><span class="line">扇形交换机，采用广播模式，根据绑定的交换机，路由到与之对应的所有队列。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout 交换机转发消息是最快的。</span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2023/png/33551426/1678158420143-c9df29e5-deac-494d-bdce-35b50551b85c.png#averageHue=%231b0000&amp;clientId=uf635b9a6-f378-4&amp;from=paste&amp;id=u12903de6&amp;originHeight=160&amp;originWidth=329&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uec131518-b681-4fb7-b89a-759e4c379e8&amp;title=)</span><br><span class="line"></span><br><span class="line">## Topic Exchange</span><br><span class="line"></span><br><span class="line">主题交换机，对路由键进行模式匹配后进行投递，符号#表示一个或多个词，_表示一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc._” 只会匹配到“abc.def”。如下所示：</span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2023/png/33551426/1678158420143-c434869a-5462-4175-a76e-bb0b78b216f0.png#averageHue=%23140000&amp;clientId=uf635b9a6-f378-4&amp;from=paste&amp;id=u41779bab&amp;originHeight=171&amp;originWidth=424&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uecf232e1-a9fb-4854-956c-62a3dca002e&amp;title=)</span><br><span class="line"></span><br><span class="line">## Header Exchange</span><br><span class="line"></span><br><span class="line">头交换机，不处理路由键。而是根据发送的消息内容中的 headers 属性进行匹配。在绑定 Queue 与 Exchange 时指定一组键值对；当消息发送到 RabbitMQ 时会取到该消息的 headers 与 Exchange 绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 属性是一个键值对，可以是 Hashtable，键值对的值可以是任何类型。而 fanout，direct，topic 的路由键都需要要字符串形式的。</span><br><span class="line">匹配规则 x-match 有下列两种类型：</span><br><span class="line">x-match = all ：表示所有的键值对都匹配才能接受到消息</span><br><span class="line">x-match = any ：表示只要有键值对匹配就能接受到消息</span><br><span class="line">消息头交换机，如下图所示：</span><br><span class="line">![](https://cdn.nlark.com/yuque/0/2023/png/33551426/1678158420156-98a6b621-2b38-4b60-a6bf-91a5de07480e.png#averageHue=%23fdf3f2&amp;clientId=uf635b9a6-f378-4&amp;from=paste&amp;id=u17ba6b1d&amp;originHeight=225&amp;originWidth=587&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u2c67e31b-0cec-47bb-86d8-01d37832700&amp;title=)</span><br><span class="line">以上就是 RabbitMQ 常见的四种交换机模式。</span><br><span class="line"></span><br><span class="line">#### RabbitMQ Fanout 发布订阅</span><br><span class="line"></span><br><span class="line">生产者发送一条消息，经过交换机转发到多个不同的队列，多个不同的队列就多个不同的消费者。</span><br><span class="line"></span><br><span class="line">原理：</span><br><span class="line"></span><br><span class="line">1.        需要创建两个队列，每个队列对应一个消费者；</span><br><span class="line">2.        队列需要绑定我们交换机</span><br><span class="line">3.        生产者投递消息到交换机中，交换机在将消息分配给两个队列中都存放起来；</span><br><span class="line">4.        消费者从队列中获取这个消息。</span><br><span class="line"></span><br><span class="line">##### 生产者代码</span><br><span class="line"></span><br><span class="line">| ```</span><br><span class="line">import com.mayikt.rabbitmq.RabbitMQConnection;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Channel;</span><br><span class="line"></span><br><span class="line">import com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line">public class ProducerFanout &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line"></span><br><span class="line">      * 定义交换机的名称</span><br><span class="line"></span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">     private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">         //  创建Connection</span><br><span class="line"></span><br><span class="line">         Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line"></span><br><span class="line">         // 创建Channel</span><br><span class="line"></span><br><span class="line">         Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">         // 通道关联交换机</span><br><span class="line"></span><br><span class="line">         channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;, true);</span><br><span class="line"></span><br><span class="line">         String msg = &quot;每特教育6666&quot;;</span><br><span class="line"></span><br><span class="line">         channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, msg.getBytes());</span><br><span class="line"></span><br><span class="line">         channel.close();</span><br><span class="line"></span><br><span class="line">         connection.close();</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 消费者代码</span><br><span class="line">###### 邮件消费者</span><br><span class="line">| ```</span><br><span class="line">import com.mayikt.rabbitmq.RabbitMQConnection;</span><br><span class="line"></span><br><span class="line">   import com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   import java.io.IOException;</span><br><span class="line"></span><br><span class="line">   import java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public class MailConsumer &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line"></span><br><span class="line">      * 定义邮件队列</span><br><span class="line"></span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">     private static final String QUEUE_NAME = &quot;fanout_email_queue&quot;;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line"></span><br><span class="line">      * 定义交换机的名称</span><br><span class="line"></span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">     private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;邮件消费者...&quot;);</span><br><span class="line"></span><br><span class="line">         // 创建我们的连接</span><br><span class="line"></span><br><span class="line">         Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line"></span><br><span class="line">         // 创建我们通道</span><br><span class="line"></span><br><span class="line">         final Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">         // 关联队列消费者关联队列</span><br><span class="line"></span><br><span class="line">         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">         DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">             @Override</span><br><span class="line"></span><br><span class="line">             public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                 String msg = new String(body, &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">                 System.out.println(&quot;邮件消费者获取消息:&quot; + msg);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         // 开始监听消息 自动签收</span><br><span class="line"></span><br><span class="line">         channel.basicConsume(QUEUE_NAME, true, defaultConsumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">| |</span><br><span class="line">| |</span><br><span class="line"></span><br><span class="line">###### 短信消费者</span><br><span class="line"></span><br><span class="line">| ```</span><br><span class="line">public class SmsConsumer &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line"></span><br><span class="line">      * 定义短信队列</span><br><span class="line"></span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">     private static final String QUEUE_NAME = &quot;fanout_email_sms&quot;;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line"></span><br><span class="line">      * 定义交换机的名称</span><br><span class="line"></span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">     private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;短信消费者...&quot;);</span><br><span class="line"></span><br><span class="line">         // 创建我们的连接</span><br><span class="line"></span><br><span class="line">         Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line"></span><br><span class="line">         // 创建我们通道</span><br><span class="line"></span><br><span class="line">         final Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">         // 关联队列消费者关联队列</span><br><span class="line"></span><br><span class="line">         channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">         DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123;</span><br><span class="line"></span><br><span class="line">             @Override</span><br><span class="line"></span><br><span class="line">             public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                 String msg = new String(body, &quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">                 System.out.println(&quot;短信消费者获取消息:&quot; + msg);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;;</span><br><span class="line"></span><br><span class="line">         // 开始监听消息 自动签收</span><br><span class="line"></span><br><span class="line">         channel.basicConsume(QUEUE_NAME, true, defaultConsumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Direct路由模式</span><br><span class="line">当交换机类型为direct类型时，根据队列绑定的路由建转发到具体的队列中存放消息</span><br><span class="line"></span><br><span class="line">##### 生产者</span><br><span class="line">##### 消费者</span><br><span class="line"></span><br><span class="line">#### Topic主题模式</span><br><span class="line">当交换机类型为topic类型时，根据队列绑定的路由建模糊转发到具体的队列中存放。</span><br><span class="line">#号表示支持匹配多个词；</span><br><span class="line">*号表示只能匹配一个词</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## SpringBoot整合RabbitMQ</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Maven依赖</span><br><span class="line">| ```java</span><br><span class="line">&lt;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- springboot-web组件 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 添加springboot对amqp的支持 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--fastjson --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;1.2.49&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">| |</span><br><span class="line">| |</span><br><span class="line"></span><br><span class="line">### 配置类</span><br><span class="line"></span><br><span class="line">| ```java</span><br><span class="line">package com.example.demo1.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.FanoutExchange;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- @author:22603</span><br><span class="line">- @Date:2023/3/7 15:59</span><br><span class="line">  \*/</span><br><span class="line">  @Component</span><br><span class="line">  public class RabbitMQConfig &#123;</span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line"></span><br><span class="line">- 定义交换机</span><br><span class="line">  \*/</span><br><span class="line"></span><br><span class="line">          private String EXCHANGE_SPRINGBOOT_NAME = &quot;/SpringBoot&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line"></span><br><span class="line">- 短信队列</span><br><span class="line">  \*/</span><br><span class="line"></span><br><span class="line">          private String FANOUT_SMS_QUEUE = &quot;fanout_sms_queue&quot;;</span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line"></span><br><span class="line">- 邮件队列</span><br><span class="line">  \*/</span><br><span class="line">  private String FANOUT_EMAIL_QUEUE = &quot;fanout_email_queue&quot;;</span><br><span class="line"></span><br><span class="line">          @Bean</span><br><span class="line">          public Queue sms() &#123;</span><br><span class="line">              return new Queue(FANOUT_SMS_QUEUE);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line"></span><br><span class="line">- 配置 emailQueue</span><br><span class="line">-</span><br><span class="line">- @return</span><br><span class="line">  \*/</span><br><span class="line"></span><br><span class="line">          @Bean</span><br><span class="line"></span><br><span class="line">          public Queue emailQueue() &#123;</span><br><span class="line"></span><br><span class="line">              return new Queue(FANOUT_EMAIL_QUEUE);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line"></span><br><span class="line">- 配置 fanoutExchange</span><br><span class="line">-</span><br><span class="line">- @return</span><br><span class="line">  \*/</span><br><span class="line"></span><br><span class="line">          @Bean</span><br><span class="line">          public FanoutExchange fanoutExchange() &#123;</span><br><span class="line">              return new FanoutExchange(EXCHANGE_SPRINGBOOT_NAME);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Bean</span><br><span class="line">          public Binding bindingSmsFanoutExchange(Queue sms,FanoutExchange fanoutExchange)&#123;</span><br><span class="line">              return BindingBuilder.bind(sms).to(fanoutExchange);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          @Bean</span><br><span class="line">          public Binding bindingEmailFanoutExchange(Queue emailQueue,FanoutExchange fanoutExchange)&#123;</span><br><span class="line">              return BindingBuilder.bind(emailQueue).to(fanoutExchange);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"> </span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 配置文件</span><br><span class="line">application.yml</span><br><span class="line"></span><br><span class="line">| ```yaml</span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    ####连接地址</span><br><span class="line">    host: 127.0.0.1</span><br><span class="line"></span><br><span class="line">    ####端口号</span><br><span class="line"></span><br><span class="line">    port: 5672</span><br><span class="line"></span><br><span class="line">    ####账号</span><br><span class="line"></span><br><span class="line">    username: guest</span><br><span class="line"></span><br><span class="line">    ####密码</span><br><span class="line"></span><br><span class="line">    password: guest</span><br><span class="line"></span><br><span class="line">    ### 地址</span><br><span class="line"></span><br><span class="line">    virtual-host: /Study</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual # 手动应答</span><br><span class="line">        prefetch: 1 #每次从队列中取一个,轮询分发，默认是公平分发</span><br><span class="line">        retry:</span><br><span class="line">          max-attempts: 5 # 重试次数</span><br><span class="line">          enabled: true # 开启重试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">| |</span><br><span class="line">| |</span><br><span class="line"></span><br><span class="line">### 生产者</span><br><span class="line"></span><br><span class="line">| ```java</span><br><span class="line">package com.example.demo1.controller;</span><br><span class="line"></span><br><span class="line">import com.example.demo1.eneity.MsgEneity;</span><br><span class="line">import org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- @author:22603</span><br><span class="line">- @Date:2023/3/7 17:07</span><br><span class="line">  \*/</span><br><span class="line">  @RestController</span><br><span class="line">  public class fanoutController &#123;</span><br><span class="line"></span><br><span class="line">          @Resource</span><br><span class="line">          private AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">          @RequestMapping(&quot;/sendMsg&quot;)</span><br><span class="line">          public String sendMsg()&#123;</span><br><span class="line">              MsgEneity msgEneity=new MsgEneity(UUID.randomUUID().toString(),&quot;1&quot;,</span><br><span class="line">                                                &quot;18790034997&quot;,&quot;2260391948@qq.com&quot;);</span><br><span class="line">              amqpTemplate.convertAndSend(&quot;/SpringBoot&quot;,&quot;&quot;,msgEneity);</span><br><span class="line">              return &quot;消息投递成功:&quot;+msgEneity;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 消费者</span><br><span class="line">| ```java</span><br><span class="line">package com.example.demo1.Customer;</span><br><span class="line"></span><br><span class="line">import com.example.demo1.eneity.MsgEneity;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* @author:22603</span><br><span class="line">* @Date:2023/3/7 17:29</span><br><span class="line">*/</span><br><span class="line">@Slf4j</span><br><span class="line">    @Component</span><br><span class="line">    @RabbitListener(queues = &quot;fanout_email_queue&quot;)</span><br><span class="line">    public class EmailMsg &#123;</span><br><span class="line"></span><br><span class="line">        @RabbitHandler</span><br><span class="line">        public void process(MsgEneity msgEneity)&#123;</span><br><span class="line">            log.info(&quot;EmailMsg:&quot;+msgEneity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">| |</span><br><span class="line">| |</span><br><span class="line"></span><br><span class="line">| ```java</span><br><span class="line">package com.example.demo1.Customer;</span><br><span class="line"></span><br><span class="line">import com.example.demo1.eneity.MsgEneity;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitHandler;</span><br><span class="line">import org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- @author:22603</span><br><span class="line">- @Date:2023/3/7 17:29</span><br><span class="line">  \*/</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@RabbitListener(queues = &quot;fanout_sms_queue&quot;)</span><br><span class="line">public class MsgCustom &#123;</span><br><span class="line"></span><br><span class="line">        @RabbitHandler</span><br><span class="line">        public void process(MsgEneity msgEneity)&#123;</span><br><span class="line">            log.info(&quot;MsgCustom:&quot;+msgEneity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p> |<br>| —- |</p><h2 id="MQ异步发送短信发邮件"><a href="#MQ异步发送短信发邮件" class="headerlink" title="MQ异步发送短信发邮件"></a>MQ异步发送短信发邮件</h2><p>生产者：<br><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1678204154156-3fb8e446-6388-4ea7-86ca-f376ba44d973.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1678204154156-3fb8e446-6388-4ea7-86ca-f376ba44d973.java%22%2C%22name%22%3A%22RabbitMQConfig.java%22%2C%22size%22%3A1595%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u2a0fd865-e26e-486a-b61d-7a11a67e31f%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ucf5824fa%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">RabbitMQConfig.java</a><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1678204154169-a08ad0ad-575b-444a-a583-71c42fb06aee.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1678204154169-a08ad0ad-575b-444a-a583-71c42fb06aee.java%22%2C%22name%22%3A%22UserController.java%22%2C%22size%22%3A935%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ue9765300-6f17-4cb5-b6c6-240b5644961%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u91e9ed2a%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">UserController.java</a><br>消费者：<br><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1678204178501-023b7911-3796-4e3b-924c-4d42e44c5051.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1678204178501-023b7911-3796-4e3b-924c-4d42e44c5051.java%22%2C%22name%22%3A%22MsgCustom.java%22%2C%22size%22%3A584%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u8a49c97b-53f2-479f-9f89-32e02d987ce%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u98be3257%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">MsgCustom.java</a><a href="https://www.yuque.com/attachments/yuque/0/2023/java/33551426/1678204178518-0b08e124-b312-47e6-a91b-87ed415a11b2.java?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fjava%2F33551426%2F1678204178518-0b08e124-b312-47e6-a91b-87ed415a11b2.java%22%2C%22name%22%3A%22EmailMsg.java%22%2C%22size%22%3A571%2C%22ext%22%3A%22java%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u77599c3e-f1e0-4025-8f3a-3f4d1269c7b%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u36bcfe16%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">EmailMsg.java</a></p><h2 id="生产者如何获取消费结果"><a href="#生产者如何获取消费结果" class="headerlink" title="生产者如何获取消费结果"></a>生产者如何获取消费结果</h2><p><strong>1.     根据业务来定</strong><br><strong>消费者消费成功结果：</strong><br><strong>1.能够在数据库中插入一条数据</strong></p><p><strong>2.     Rocketmq 自带全局消息id，能够根据该全局消息获取消费结果</strong><br><strong>原理：生产者投递消息到mq服务器，mq服务器端在这时候返回一个全局的消息id，</strong><br><strong>当我们消费者消费该消息成功之后，消费者会给我们mq服务器端发送通知标记该消息</strong><br><strong>消费成功。</strong><br><strong>生产者获取到该消息全局id，每隔2s时间调用mq服务器端接口查询该消息是否</strong><br><strong>有被消费成功。</strong></p><ol><li>异步返回一个全局id，前端使用ajax定时主动查询；</li><li>在rocketmq中，自带根据消息id查询是否消费成功</li></ol><h2 id="RabbitMQ实战解决方案"><a href="#RabbitMQ实战解决方案" class="headerlink" title="RabbitMQ实战解决方案"></a>RabbitMQ实战解决方案</h2><h4 id="RabbitMQ死信队列"><a href="#RabbitMQ死信队列" class="headerlink" title="RabbitMQ死信队列"></a>RabbitMQ死信队列</h4><h4 id="死信队列产生的背景"><a href="#死信队列产生的背景" class="headerlink" title="死信队列产生的背景"></a>死信队列产生的背景</h4><p>RabbitMQ死信队列俗称，备胎队列；消息中间件因为某种原因拒收该消息后，可以转移到死信队列中存放，死信队列也可以有交换机和路由key等。</p><h4 id="产生死信队列的原因"><a href="#产生死信队列的原因" class="headerlink" title="产生死信队列的原因"></a>产生死信队列的原因</h4><ol><li>消息投递到MQ中存放 消息已经过期  消费者没有及时的获取到我们消息，消息如果存放到mq服务器中过期之后，会转移到备胎死信队列存放。</li><li>队列达到最大的长度 （队列容器已经满了）<br><strong>3.       </strong>消费者消费多次消息失败，就会转移存放到死信队列中<br>代码整合参考 mayikt-springboot-rabbitmq|#中order-dead-letter-queue项目</li></ol><h4 id="死信队列的架构原理"><a href="#死信队列的架构原理" class="headerlink" title="死信队列的架构原理"></a>死信队列的架构原理</h4><p>死信队列和普通队列区别不是很大<br>普通与死信队列都有自己独立的交换机和路由key、队列和消费者。<br>区别：<br>1.生产者投递消息先投递到我们普通交换机中，普通交换机在将该消息投到<br>普通队列中缓存起来，普通队列对应有自己独立普通消费者。<br>2.如果生产者投递消息到普通队列中，普通队列发现该消息一直没有被消费者消费<br>的情况下，在这时候会将该消息转移到死信（备胎）交换机中，死信（备胎）交换机<br>对应有自己独立的死信（备胎）队列对应独立死信（备胎）消费者。</p><h4 id="死信队列应用场景"><a href="#死信队列应用场景" class="headerlink" title="死信队列应用场景"></a>死信队列应用场景</h4><p>1.30分钟订单超时设计<br>A.    Redis过期key ：<br>B.    死信延迟队列实现：<br>采用死信队列，创建一个普通队列没有对应的消费者消费消息，在30分钟过后<br>就会将该消息转移到死信备胎消费者实现消费。<br>备胎死信消费者会根据该订单号码查询是否已经支付过，如果没有支付的情况下<br>则会开始回滚库存操作。</p><h3 id="RabbitMQ消息幂等问题"><a href="#RabbitMQ消息幂等问题" class="headerlink" title="RabbitMQ消息幂等问题"></a>RabbitMQ消息幂等问题</h3><h4 id="RabbitMQ消息自动重试机制"><a href="#RabbitMQ消息自动重试机制" class="headerlink" title="RabbitMQ消息自动重试机制"></a>RabbitMQ消息自动重试机制</h4><ol><li>当我们消费者处理执行我们业务代码的时候，如果抛出异常的情况下<br>在这时候mq会自动触发重试机制，默认的情况下rabbitmq是无限次数的重试。<br>需要人为指定重试次数限制问题</li><li>在什么情况下消费者需要实现重试策略？</li></ol><p>A.消费者获取消息后，调用第三方接口，但是调用第三方接口失败呢？是否需要重试？<br>该情况下需要实现重试策略，网络延迟只是暂时调用不通，重试多次有可能会调用通。<br>还有数据库连接超时，也可以进行重试，重试多次有可能会调用通。<br>B.<br>消费者获取消息后，因为代码问题抛出数据异常，是否需要重试？<br>该情况下是不需要实现重试策略，就算重试多次，最终还是失败的。<br>可以将日志存放起来，后期通过定时任务或者人工补偿形式。<br>如果是重试多次还是失败消息，需要重新发布消费者版本实现消费<br>可以使用死信队列</p><p>Mq在重试的过程中，有可能会引发消费者重复消费的问题。<br>Mq消费者需要解决幂等性问题<br>幂等性保证数据唯一</p><p>方式1：<br>生产者在投递消息的时候，生成一个全局唯一id，放在我们消息中。<br>Msg id=123456</p><p>Msg id=123456<br>Msg id=123456</p><p>消费者获取到我们该消息，可以根据该全局唯一id实现去重复。<br>全局唯一id 根据业务来定的  订单号码作为全局的id<br>实际上还是需要再db层面解决数据防重复。<br>业务逻辑是在做insert操作使用唯一主键约束<br>业务逻辑是在做update操作使用乐观锁</p><ol><li>当消费者业务逻辑代码中，抛出异常自动实现重试 （默认是无数次重试）</li><li>应该对RabbitMQ重试次数实现限制，比如最多重试5次，每次间隔3s；重试多次还是失败的情况下，存放到死信队列或者存放到数据库表中记录后期人工补偿<h4 id="如何合理选择消息重试"><a href="#如何合理选择消息重试" class="headerlink" title="如何合理选择消息重试"></a>如何合理选择消息重试</h4></li><li>消费者获取消息后，调用第三方接口，但是调用第三方接口失败呢？是否需要重试 ？</li><li>消费者获取消息后，应该代码问题抛出数据异常，是否需要重试？</li></ol><p>总结：如果消费者处理消息时，因为代码原因抛出异常是需要从新发布版本才能解决的，那么就不需要重试，重试也解决不了该问题的。存放到死信队列或者是数据库表记录、后期人工实现补偿。</p><h4 id="Rabbitmq如何开启重试策略"><a href="#Rabbitmq如何开启重试策略" class="headerlink" title="Rabbitmq如何开启重试策略"></a>Rabbitmq如何开启重试策略</h4><p>| <strong>spring</strong>:<br>  <strong>rabbitmq</strong>:<br>    <em>####连接地址</em>    <em><strong>host</strong>: 127.0.0.1    </em>####端口号<em>    </em><strong>port</strong>: 5672<br>    <em>####账号</em>    <em><strong>username</strong>: guest    </em>####密码<em>    </em><strong>password</strong>: guest<br>    <em>### 地址</em>    <em><strong>virtual-host</strong>: /meite_rabbitmq<br>    <strong>listener</strong>:<br>      <strong>simple</strong>:<br>        <strong>retry</strong>:          </em>####开启消费者（程序出现异常的情况下会）进行重试<em>          </em><strong>enabled</strong>: <strong>true          </strong><em>####最大重试次数</em>          <em><strong>max-attempts</strong>: 5          </em>####重试间隔次数<em>          </em><strong>initial-interval</strong>: 3000<br> |<br>| —- |</p><h4 id="消费者重试过程中，如何避免幂等性问题"><a href="#消费者重试过程中，如何避免幂等性问题" class="headerlink" title="消费者重试过程中，如何避免幂等性问题"></a>消费者重试过程中，如何避免幂等性问题</h4><p><strong>重试的过程中，为了避免业务逻辑重复执行，建议提前全局id提前查询，如果存在</strong><br><strong>的情况下，就无需再继续做该流程。</strong><br><strong>重试的次数最好有一定间隔次数，在数据库底层层面保证数据唯一性，比如加上唯一id。</strong></p><h4 id="SpringBoot开启消MQ架构设计原理"><a href="#SpringBoot开启消MQ架构设计原理" class="headerlink" title="SpringBoot开启消MQ架构设计原理"></a>SpringBoot开启消MQ架构设计原理</h4><p>什么是消息中间件<br>消息中间件基于队列模型实现异步/同步传输数据<br>作用：可以实现支撑高并发、异步解耦、流量削峰、降低耦合度。<br>传统的http请求存在那些缺点</p><p>1.Http请求基于请求与响应的模型，在高并发的情况下，客户端发送大量的请求达到<br>服务器端有可能会导致我们服务器端处理请求堆积。<br>2.Tomcat服务器处理每个请求都有自己独立的线程，如果超过最大线程数会将该请求缓存到队列中，如果请求堆积过多的情况下，有可能会导致tomcat服务器崩溃的问题。<br>所以一般都会在nginx入口实现限流，整合服务保护框架。</p><ol><li>http请求处理业务逻辑如果比较耗时的情况下，容易造成客户端一直等待，阻塞等待<br>过程中会导致客户端超时发生重试策略，有可能会引发幂等性问题。</li></ol><p>注意事项：接口是为http协议的情况下，最好不要处理比较耗时的业务逻辑，耗时的业务逻辑应该单独交给多线程或者是mq处理。</p><p>Mq应用场景有那些</p><ol><li>异步发送短信</li><li>异步发送新人优惠券</li><li>处理一些比较耗时的操作</li><li>异步发送短信</li><li>异步发送优惠券</li><li>比较耗时操作</li></ol><p>为什么需要使用mq<br>可以实现支撑高并发、异步解耦、流量削峰、降低耦合度。</p><p>同步发送http请求</p><p>客户端发送请求到达服务器端，服务器端实现会员注册业务逻辑，<br>1.insertMember() —插入会员数据  1s<br>2.sendSms()——发送登陆短信提醒 3s<br>3.sendCoupons()——发送新人优惠券  3s<br>总共响应需要6s时间，可能会导致客户端阻塞6s时间，对用户体验<br>不是很好。</p><p>多线程与MQ方式实现异步？</p><p>互联网项目:<br>客户端 安卓/IOS</p><p>服务器端：php/java<br>最好使用mq实现异步</p><p>多线程处理业务逻辑</p><p>用户向数据库中插入一条数据之后，在单独开启一个线程异步发送短信和优惠操作。<br>客户端只需要等待1s时间<br>优点：适合于小项目 实现异步<br>缺点：有可能会消耗服务器cpu资源资源<br>Mq处理业务逻辑</p><p>先向数据库中插入一条会员数据，让后再向MQ中投递一个消息，MQ服务器端在将消息推送给消费者异步解耦处理发送短信和优惠券。<br>Mq与多线程之间区别</p><p>MQ可以实现异步/解耦/流量削峰问题；<br>多线程也可以实现异步，但是消耗到cpu资源，没有实现解耦。</p><p>Mq消息中间件名词</p><p>Producer 生产者：投递消息到MQ服务器端；<br>Consumer  消费者：从MQ服务器端获取消息处理业务逻辑；<br>Broker   MQ服务器端<br>Topic 主题：分类业务逻辑发送短信主题、发送优惠券主题<br>Queue 存放消息模型 队列 先进先出 后进后出原则 数组/链表<br>Message 生产者投递消息报文：json</p><p>主流mq区别对比比</p><p>特性    ActiveMQ    RabbitMQ    RocketMQ    kafka<br>开发语言    java    erlang    java    scala<br>单机吞吐量    万级    万级    10万级    10万级<br>时效性    ms级    us级    ms级    ms级以内<br>可用性    高（主从架构）    高（主从架构）    非常高（分布式架构）    非常高（分布式架构）<br>功能特性    成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好    基于erlang开发，所以并发能力很强，性能极其好，延时很低管理界面较丰富    MQ功能比较完备，扩展性佳    只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。</p><p>Mq设计基础知识</p><p>多线程版本mq；<br>基于网络通讯版本mq netty实现</p><p>基于多线程队列简单实现mq<br>public class MayiktThreadMQ {<br>/**</p><ul><li>Broker<br>*/<br>private static LinkedBlockingDeque broker = new LinkedBlockingDeque();</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建生产者线程</span><br><span class="line">Thread producer = new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">JSONObject data = new JSONObject();</span><br><span class="line">data.put(&quot;phone&quot;, &quot;18611111111&quot;);</span><br><span class="line">broker.offer(data);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;生产者&quot;);</span><br><span class="line">    producer.start();</span><br><span class="line">    Thread consumer = new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    JSONObject data = broker.poll();</span><br><span class="line">                    if (data != null) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + &quot;,获取到数据:&quot; + data.toJSONString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &quot;消费者&quot;);</span><br><span class="line">    consumer.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>}</p><p>基于netty实现mq<br>消费者netty客户端与nettyServer端MQ服务器端保持长连接，MQ服务器端保存<br>消费者连接。<br>生产者netty客户端发送请求给nettyServer端MQ服务器端，MQ服务器端在将该<br>消息内容发送给消费者。</p><p>body:{“msg”:{“userId”:”123456”,”age”:”23”},”type”:”producer”，”topic”:””}</p><p>生产者投递消息给MQ服务器端，MQ服务器端需要缓存该消息<br>如果mq服务器端宕机之后，消息如何保证不丢失</p><ol><li>持久化机制<br>如果mq接收到生产者投递消息，如果消费者不在的情况下，该消息是否会丢失？<br>不会丢失，消息确认机制 必须要消费者消费该消息成功之后，在通知给mq服务器端<br>删除该消息。<br>Mq服务器端将该消息推送消费者：<br>消费者已经和mq服务器保持长连接。<br>消费者主动拉取消息：<br>消费者第一次刚启动的时候</li></ol><p>Mq如何实现抗高并发思想</p><p>Mq消费者根据自身能力情况 ，拉取mq服务器端消息消费。<br>默认的情况下是取出一条消息。</p><p>缺点：存在延迟的问题</p><p>需要考虑mq消费者提高速率的问题：</p><p>如何消费者提高速率：消费者实现集群、消费者批量获取消息即可。</p><p>Maven依赖</p><p>com.alibaba<br>fastjson<br>1.2.62</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0.23.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.62&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.11&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>RabbitMQ<br>RabbitMQ基本介绍<br>RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件），RabbitMQ服务器是用Erlang语言编写的。<br>RabitMQ官方网站:<br><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p>1.点对点(简单)的队列 2.工作(公平性)队列模式 3.发布订阅模式 4.路由模式 Routing 5.通配符模式 Topics<br>6.RPC<br><a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a><br>RabbitMQ 环境的基本安装</p><p>1.下载并安装 erlang,下载地址：<a href="http://www.erlang.org/download">http://www.erlang.org/download</a> 2.配置 erlang 环境变量信息<br>新增环境变量 ERLANG_HOME=erlang 的安装地址<br>将%ERLANG_HOME%\bin 加入到 path 中 3.下载并安装 RabbitMQ，下载地址：<a href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a><br>注意: RabbitMQ 它依赖于 Erlang,需要先安装 Erlang。<br><a href="https://www.rabbitmq.com/install-windows.html">https://www.rabbitmq.com/install-windows.html</a></p><p>Java<br>安装 RabbitMQ 环境步骤</p><p>配置 Erlang 环境变量：</p><p>如何启动 Rabbitmq</p><p>net start RabbitMQ</p><p>启动 Rabbitmq 常见问题<br>如果 rabbitmq 启动成功无法访问 管理平台页面</p><p>进入到 F:\path\rabbitmq\rabbitmq\rabbitmq_server-3.6.9\sbin&gt;<br>执行<br>rabbitmq-plugins enable rabbitmq_management<br>rabbitmqctl start_app</p><p>Rabbitmq 管理平台中心</p><p>RabbitMQ 管理平台地址 <a href="http://127.0.0.1:15672">http://127.0.0.1:15672</a><br>默认账号:guest/guest   用户可以自己创建新的账号</p><p>Virtual Hosts:<br>像 mysql 有数据库的概念并且可以指定用户对库和表等操作的权限。那 RabbitMQ 呢？<br>RabbitMQ 也有类似的权限管理。在 RabbitMQ 中可以虚拟消息服务器 VirtualHost，每<br>个 VirtualHost 相当月一个相对独立的 RabbitMQ 服务器，每个 VirtualHost 之间是相互<br>隔离的。exchange、queue、message 不能互通。</p><p>默认的端口 15672：rabbitmq 管理平台端口号<br>默认的端口 5672： rabbitmq 消息中间内部通讯的端口<br>默认的端口号 25672  rabbitmq 集群的端口号</p><p>RabbitMQ 常见名词<br>/Virtual Hosts—-分类<br>/队列 存放我们消息<br>Exchange 分派我们消息在那个队列存放起来 类似于 nginx</p><p>15672—-rabbitmq 控制台管理平台 http 协议<br>25672rabbitmq 集群通信端口号<br>Amqp 5672 rabbitmq 内部通信的一个端口号</p><p>RabbitMQ 创建账户<br>RabbitMQ 平台创建 Virtual Hosts<br>RabbitMQ 平台创建消息队列</p><p>快速入门 RabbitMQ 简单队列</p><p>首先需要再 RabbitMQ 平台创建 Virtual Hosts 和队列。<br>/meiteVirtualHosts<br>——订单队列<br>——支付队列</p><ol><li>在 RabbitMQ 平台创建一个队列；</li><li>在编写生产者代码</li><li>在编写消费者代码</li></ol><p>生产者<br>public class RabbitMQConnection {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 获取连接</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static Connection getConnection() throws IOException, TimeoutException &#123;</span><br><span class="line">    // 1.创建连接</span><br><span class="line">    ConnectionFactory connectionFactory = new ConnectionFactory();</span><br><span class="line">    // 2.设置连接地址</span><br><span class="line">    connectionFactory.setHost(&quot;127.0.0.1&quot;);</span><br><span class="line">    // 3.设置端口号:</span><br><span class="line">    connectionFactory.setPort(5672);</span><br><span class="line">    // 4.设置账号和密码</span><br><span class="line">    connectionFactory.setUsername(&quot;yushengjun&quot;);</span><br><span class="line">    connectionFactory.setPassword(&quot;123456&quot;);</span><br><span class="line">    // 5.设置VirtualHost</span><br><span class="line">    connectionFactory.setVirtualHost(&quot;/mayikt&quot;);</span><br><span class="line">    return connectionFactory.newConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>public class Producer {<br>private static final String QUEUE_NAME = “mayikt”;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">    // 1.创建连接</span><br><span class="line">    Connection connection = RabitMQConnection.getConnection();</span><br><span class="line">    // 2.设置通道</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    // 3.设置消息</span><br><span class="line">    String msg = &quot;每特教育第六期平均就业薪资破3万&quot;;</span><br><span class="line">    System.out.println(&quot;msg:&quot; + msg);</span><br><span class="line">    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>Maven 依赖</p><p>com.rabbitmq<br>amqp-client<br>3.6.5</p><p>消费者</p><p>public class Consumer {<br>private static final String QUEUE_NAME = “mayikt”;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">    // 1.创建连接</span><br><span class="line">    Connection connection = RabitMQConnection.getConnection();</span><br><span class="line">    // 2.设置通道</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">            String msg = new String(body, &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;消费者获取消息:&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 3.监听队列</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, true, defaultConsumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>RabbitMQ 如何保证消息不丢失</p><p>Mq 如何保证消息不丢失：</p><ol><li>生产者角色<br>确保生产者投递消息到 MQ 服务器端成功。<br>Ack 消息确认机制<br>同步或者异步的形式<br>方式 1：Confirms<br>方式 2：事务消息</li><li>消费者角色<br>在 rabbitmq 情况下：<br>必须要将消息消费成功之后，才会将该消息从 mq 服务器端中移除。<br>在 kafka 中的情况下：<br>不管是消费成功还是消费失败，该消息都不会立即从 mq 服务器端移除。</li><li>Mq 服务器端 在默认的情况下 都会对队列中的消息实现持久化<br>持久化硬盘。</li><li>使用消息确认机制+持久技术<br>A.消费者确认收到消息机制<br>channel.basicConsume(QUEUE_NAME, false, defaultConsumer);<br>注：第二个参数值为 false 代表关闭 RabbitMQ 的自动应答机制，改为手动应答。<br>在处理完消息时，返回应答状态，true 表示为自动应答模式。<br>channel.basicAck(envelope.getDeliveryTag(), false);<br>B.生产者确认投递消息成功 使用 Confirm 机制 或者事务消息</li></ol><p>Confirm 机制 同步或者是异步的形式</p><p>2.RabbitMQ 默认创建是持久化的</p><p>代码中设置 durable 为 true</p><p>参数名称详解：<br>durable 是否持久化 durable 为持久化、 Transient 不持久化<br>autoDelete 是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过 RabbitMQ Management，查看某个队列的消费者数量，当 consumers = 0 时队列就会自动删除 2. 使用 rabbitmq 事务消息；<br>channel.txSelect();<br>channel.basicPublish(“”, QUEUE_NAME, null, msg.getBytes());<br>//            int i = 1 / 0;<br>channel.txCommit();</p><p>相关核心代码<br>生产者<br>public class Producer {<br>private static final String QUEUE_NAME = “mayikt-queue”;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, TimeoutException, InterruptedException &#123;</span><br><span class="line">    //1.创建一个新连接</span><br><span class="line">    Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line">    //2.设置channel</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    //3.发送消息</span><br><span class="line">    String msg = &quot;每特教育6666&quot;;</span><br></pre></td></tr></table></figure><p>channel.confirmSelect();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, msg.getBytes());</span><br><span class="line">    boolean result = channel.waitForConfirms();</span><br><span class="line">    if (result) &#123;</span><br><span class="line">        System.out.println(&quot;消息投递成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;消息投递失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>消费者<br>public class Consumer {<br>private static final String QUEUE_NAME = “mayikt-queue”;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, TimeoutException, IOException, TimeoutException &#123;</span><br><span class="line">    // 1.创建连接</span><br><span class="line">    Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line">    // 2.设置通道</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">            String msg = new String(body, &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;消费者获取消息:&quot; + msg);</span><br><span class="line">            // 消费者完成 消费该消息</span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 3.监听队列</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, false, defaultConsumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>RabbitMQ 五种消息模式</p><p>RabitMQ 工作队列<br>默认的传统队列是为均摊消费，存在不公平性；如果每个消费者速度不一样的情况下，均摊消费是不公平的，应该是能者多劳。</p><p>采用工作队列<br>在通道中只需要设置 basicQos 为 1 即可，表示 MQ 服务器每次只会给消费者推送 1 条消息必须手动 ack 确认之后才会继续发送。<br>channel.basicQos(1);<br>RabbitMQ 交换机类型</p><p>Direct exchange（直连交换机）<br>Fanout exchange（扇型交换机）<br>Topic exchange（主题交换机）<br>Headers exchange（头交换机）<br>/Virtual Hosts—-区分不同的团队<br>——队列 存放消息<br>——交换机 路由消息存放在那个队列中 类似于 nginx<br>—-路由 key 分发规则</p><p>RabbitMQ Fanout 发布订阅<br>生产者发送一条消息，经过交换机转发到多个不同的队列，多个不同的队列就多个不同的消费者。</p><p>原理：</p><ol><li>需要创建两个队列 ，每个队列对应一个消费者；</li><li>队列需要绑定我们交换机</li><li>生产者投递消息到交换机中，交换机在将消息分配给两个队列中都存放起来；</li><li>消费者从队列中获取这个消息。</li></ol><p>生产者代码<br>import com.mayikt.rabbitmq.RabbitMQConnection;<br>import com.rabbitmq.client.Channel;<br>import com.rabbitmq.client.Connection;</p><p>import java.io.IOException;<br>import java.util.concurrent.TimeoutException;</p><p>public class ProducerFanout {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 定义交换机的名称</span><br><span class="line"> */</span><br><span class="line">private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">    //  创建Connection</span><br><span class="line">    Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line">    // 创建Channel</span><br><span class="line">    Channel channel = connection.createChannel();</span><br><span class="line">    // 通道关联交换机</span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;, true);</span><br><span class="line">    String msg = &quot;每特教育6666&quot;;</span><br><span class="line">    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, msg.getBytes());</span><br><span class="line">    channel.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>消费者代码<br>邮件消费者<br>import com.mayikt.rabbitmq.RabbitMQConnection;<br>import com.rabbitmq.client.*;</p><p>import java.io.IOException;<br>import java.util.concurrent.TimeoutException;</p><p>public class MailConsumer {<br>/**</p><ul><li>定义邮件队列<br>*/<br>private static final String QUEUE_NAME = “fanout_email_queue”;<br>/**</li><li>定义交换机的名称<br>*/<br>private static final String EXCHANGE_NAME = “fanout_exchange”;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">    System.out.println(&quot;邮件消费者...&quot;);</span><br><span class="line">    // 创建我们的连接</span><br><span class="line">    Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line">    // 创建我们通道</span><br><span class="line">    final Channel channel = connection.createChannel();</span><br><span class="line">    // 关联队列消费者关联队列</span><br><span class="line">    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line">    DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">            String msg = new String(body, &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;邮件消费者获取消息:&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 开始监听消息 自动签收</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, true, defaultConsumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>短信消费者</p><p>public class SmsConsumer {<br>/**</p><ul><li>定义短信队列<br>*/<br>private static final String QUEUE_NAME = “fanout_email_sms”;<br>/**</li><li>定义交换机的名称<br>*/<br>private static final String EXCHANGE_NAME = “fanout_exchange”;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException, TimeoutException &#123;</span><br><span class="line">    System.out.println(&quot;短信消费者...&quot;);</span><br><span class="line">    // 创建我们的连接</span><br><span class="line">    Connection connection = RabbitMQConnection.getConnection();</span><br><span class="line">    // 创建我们通道</span><br><span class="line">    final Channel channel = connection.createChannel();</span><br><span class="line">    // 关联队列消费者关联队列</span><br><span class="line">    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);</span><br><span class="line">    DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123;</span><br><span class="line">            String msg = new String(body, &quot;UTF-8&quot;);</span><br><span class="line">            System.out.println(&quot;短信消费者获取消息:&quot; + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 开始监听消息 自动签收</span><br><span class="line">    channel.basicConsume(QUEUE_NAME, true, defaultConsumer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><p>Direct 路由模式<br>当交换机类型为 direct 类型时，根据队列绑定的路由建转发到具体的队列中存放消息</p><p>生产者<br>消费者</p><p>Topic 主题模式<br>当交换机类型为 topic 类型时，根据队列绑定的路由建模糊转发到具体的队列中存放。 #号表示支持匹配多个词； *号表示只能匹配一个词</p><p>SpringBoot 整合 RabbitMQ</p><p>Maven 依赖</p><p>org.springframework.boot<br>spring-boot-starter-parent<br>2.0.0.RELEASE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- springboot-web组件 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- 添加springboot对amqp的支持 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--fastjson --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.49&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置类</p><p>import org.springframework.amqp.core.Binding;<br>import org.springframework.amqp.core.BindingBuilder;<br>import org.springframework.amqp.core.FanoutExchange;<br>import org.springframework.amqp.core.Queue;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.stereotype.Component;</p><p>/**</p><ul><li><a href="/ClassName">@ClassName </a> RabbitMQConfig</li><li><a href="/Author">@Author </a> 蚂蚁课堂余胜军 QQ644064779 www.mayikt.com</li><li><a href="/Version">@Version </a> V1.0<br><strong>/<br><a href="/Component">@Component </a><br>public class RabbitMQConfig {<br>/</strong><ul><li>定义交换机<br>*/<br>private String EXCHANGE_SPRINGBOOT_NAME = “/mayikt_ex”;</li></ul></li></ul><p>/**</p><ul><li>短信队列<br>*/<br>private String FANOUT_SMS_QUEUE = “fanout_sms_queue”;<br>/**</li><li>邮件队列<br>*/<br>private String FANOUT_EMAIL_QUEUE = “fanout_email_queue”;</li></ul><p>/**</p><ul><li><p>配置 smsQueue<br>-</p></li><li><p><a href="/return">@return </a><br>*/<br><a href="/Bean">@Bean </a><br>public Queue smsQueue() {<br>return new Queue(FANOUT_SMS_QUEUE);<br>}</p></li></ul><p>/**</p><ul><li><p>配置 emailQueue<br>-</p></li><li><p><a href="/return">@return </a><br>*/<br><a href="/Bean">@Bean </a><br>public Queue emailQueue() {<br>return new Queue(FANOUT_EMAIL_QUEUE);<br>}</p></li></ul><p>/**</p><ul><li><p>配置 fanoutExchange<br>-</p></li><li><p><a href="/return">@return </a><br>*/<br><a href="/Bean">@Bean </a><br>public FanoutExchange fanoutExchange() {<br>return new FanoutExchange(EXCHANGE_SPRINGBOOT_NAME);<br>}</p></li></ul><p>// 绑定交换机 sms<br><a href="/Bean">@Bean </a>public Binding bindingSmsFanoutExchange(Queue smsQueue, FanoutExchange fanoutExchange) {<br>return BindingBuilder.bind(smsQueue).to(fanoutExchange);<br>}<br>// 绑定交换机 email<br><a href="/Bean">@Bean </a>public Binding bindingEmailFanoutExchange(Queue emailQueue, FanoutExchange fanoutExchange) {<br>return BindingBuilder.bind(emailQueue).to(fanoutExchange);<br>}<br>}</p><p>配置文件<br>application.yml<br>spring:<br>rabbitmq: ####连接地址<br>host: 127.0.0.1 ####端口号<br>port: 5672 ####账号<br>username: guest ####密码<br>password: guest</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p>virtual-host: /meiteVirtualHosts</p><p>生产者<br>import org.springframework.amqp.core.AmqpTemplate;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RestController;</p><p>/**</p><ul><li><a href="/ClassName">@ClassName </a> FanoutProducer</li><li><a href="/Author">@Author </a> 蚂蚁课堂余胜军 QQ644064779 www.mayikt.com</li><li><p><a href="/Version">@Version </a> V1.0<br><strong>/<br><a href="/RestController">@RestController </a><br>public class FanoutProducer {<br><a href="/Autowired">@Autowired </a><br>private AmqpTemplate amqpTemplate;<br>/</strong></p><ul><li><p>发送消息<br>-</p></li><li><p><a href="/return">@return </a><br><em>/<br>@RequestMapping(“/sendMsg”)<br>public String sendMsg(String msg) {<br>/** - 1.交换机名称 - 2.路由 key 名称 - 3.发送内容</em>/<br>amqpTemplate.convertAndSend(“/mayikt_ex”, “”, msg);<br>return “success”;<br>}<br>}</p></li></ul></li></ul><p>消费者</p><p>import lombok.extern.slf4j.Slf4j;<br>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>import org.springframework.stereotype.Component;</p><p>/**</p><ul><li><a href="/ClassName">@ClassName </a> FanoutEmailConsumer</li><li><a href="/Author">@Author </a> 蚂蚁课堂余胜军 QQ644064779 www.mayikt.com</li><li><a href="/Version">@Version </a> V1.0<br>**/<br><a href="/Slf4j">@Slf4j </a><br><a href="/Component">@Component </a><br><a href="/RabbitListener(queues">@RabbitListener(queues </a> = “fanout_email_queue”)<br>public class FanoutEmailConsumer {<br><a href="/RabbitHandler">@RabbitHandler </a><br>public void process(String msg) {<br>log.info(“&gt;&gt;邮件消费者消息 msg:{}&lt;&lt;”, msg);<br>}<br>}</li></ul><p>import lombok.extern.slf4j.Slf4j;<br>import org.springframework.amqp.rabbit.annotation.RabbitHandler;<br>import org.springframework.amqp.rabbit.annotation.RabbitListener;<br>import org.springframework.stereotype.Component;</p><p>/**</p><ul><li><a href="/ClassName">@ClassName </a> fanout_sms_queue</li><li><a href="/Author">@Author </a> 蚂蚁课堂余胜军 QQ644064779 www.mayikt.com</li><li><a href="/Version">@Version </a> V1.0<br>**/<br><a href="/Slf4j">@Slf4j </a><br><a href="/Component">@Component </a><br><a href="/RabbitListener(queues">@RabbitListener(queues </a> = “fanout_sms_queue”)<br>public class FanoutSmsConsumer {<br><a href="/RabbitHandler">@RabbitHandler </a><br>public void process(String msg) {<br>log.info(“&gt;&gt;短信消费者消息 msg:{}&lt;&lt;”, msg);<br>}<br>}</li></ul><p>生产者如何获取消费结果</p><ol><li>根据业务来定<br>消费者消费成功结果： 1.能够在数据库中插入一条数据</li><li>Rocketmq 自带全局消息 id，能够根据该全局消息获取消费结果<br>原理： 生产者投递消息到 mq 服务器，mq 服务器端在这时候返回一个全局的消息 id，<br>当我们消费者消费该消息成功之后，消费者会给我们 mq 服务器端发送通知标记该消息<br>消费成功。<br>生产者获取到该消息全局 id，每隔 2s 时间调用 mq 服务器端接口查询该消息是否<br>有被消费成功。</li><li>异步返回一个全局 id，前端使用 ajax 定时主动查询；</li><li>在 rocketmq 中，自带根据消息 id 查询是否消费成功</li></ol><p>RabbitMQ 实战解决方案</p><p>RabbitMQ 死信队列<br>死信队列产生的背景<br>RabbitMQ 死信队列俗称，备胎队列；消息中间件因为某种原因拒收该消息后，可以转移到死信队列中存放，死信队列也可以有交换机和路由 key 等。<br>产生死信队列的原因</p><ol><li>消息投递到 MQ 中存放 消息已经过期   消费者没有及时的获取到我们消息，消息如果存放到 mq 服务器中过期之后，会转移到备胎死信队列存放。</li><li>队列达到最大的长度 （队列容器已经满了）</li><li>消费者消费多次消息失败，就会转移存放到死信队列中</li></ol><p>代码整合 参考 mayikt-springboot-rabbitmq|#中 order-dead-letter-queue 项目</p><p>死信队列的架构原理<br>死信队列和普通队列区别不是很大<br>普通与死信队列都有自己独立的交换机和路由 key、队列和消费者。<br>区别： 1.生产者投递消息先投递到我们普通交换机中，普通交换机在将该消息投到<br>普通队列中缓存起来，普通队列对应有自己独立普通消费者。 2.如果生产者投递消息到普通队列中，普通队列发现该消息一直没有被消费者消费<br>的情况下，在这时候会将该消息转移到死信（备胎）交换机中，死信（备胎）交换机<br>对应有自己独立的 死信（备胎）队列 对应独立死信（备胎）消费者。</p><p>死信队列应用场景<br>1.30 分钟订单超时设计<br>A. Redis 过期 key ：<br>B. 死信延迟队列实现：<br>采用死信队列，创建一个普通队列没有对应的消费者消费消息，在 30 分钟过后<br>就会将该消息转移到死信备胎消费者实现消费。<br>备胎死信消费者会根据该订单号码查询是否已经支付过，如果没有支付的情况下<br>则会开始回滚库存操作。</p><p>RabbitMQ 消息幂等问题<br>RabbitMQ 消息自动重试机制</p><ol><li>当我们消费者处理执行我们业务代码的时候，如果抛出异常的情况下<br>在这时候 mq 会自动触发重试机制，默认的情况下 rabbitmq 是无限次数的重试。<br>需要人为指定重试次数限制问题</li><li>在什么情况下消费者需要实现重试策略？</li></ol><p>A.消费者获取消息后，调用第三方接口，但是调用第三方接口失败呢？是否需要重试？<br>该情况下需要实现重试策略，网络延迟只是暂时调用不通，重试多次有可能会调用通。<br>数据库连接超时，可以进行重试，重试多次有可能会调用通。<br>B.<br>消费者获取消息后，因为代码问题抛出数据异常，是否需要重试？<br>该情况下是不需要实现重试策略，就算重试多次，最终还是失败的。<br>可以将日志存放起来，后期通过定时任务或者人工补偿形式。<br>如果是重试多次还是失败消息，需要重新发布消费者版本实现消费<br>可以使用死信队列</p><p>Mq 在重试的过程中，有可能会引发消费者重复消费的问题。<br>Mq 消费者需要解决 幂等性问题<br>幂等性 保证数据唯一</p><p>方式 1：<br>生产者在投递消息的时候，生成一个全局唯一 id，放在我们消息中。<br>Msg id=123456</p><p>Msg id=123456<br>Msg id=123456</p><p>消费者获取到我们该消息，可以根据该全局唯一 id 实现去重复。<br>全局唯一 id 根据业务来定的   订单号码作为全局的 id<br>实际上还是需要再 db 层面解决数据防重复。<br>业务逻辑是在做 insert 操作 使用唯一主键约束<br>业务逻辑是在做 update 操作 使用乐观锁</p><ol><li>当消费者业务逻辑代码中，抛出异常自动实现重试 （默认是无数次重试）</li><li>应该对 RabbitMQ 重试次数实现限制，比如最多重试 5 次，每次间隔 3s；重试多次还是失败的情况下，存放到死信队列或者存放到数据库表中记录后期人工补偿<br>如何合理选择消息重试</li><li>消费者获取消息后，调用第三方接口，但是调用第三方接口失败呢？是否需要重试 ？</li><li>消费者获取消息后，应该代码问题抛出数据异常，是否需要重试？</li></ol><p>总结：如果消费者处理消息时，因为代码原因抛出异常是需要从新发布版本才能解决的，那么就不需要重试，重试也解决不了该问题的。存放到死信队列或者是数据库表记录、后期人工实现补偿。</p><p>Rabbitmq 如何开启重试策略</p><p>spring:<br>rabbitmq: ####连接地址<br>host: 127.0.0.1 ####端口号<br>port: 5672 ####账号<br>username: guest ####密码<br>password: guest</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p>virtual-host: /meite_rabbitmq<br>listener:<br>simple:<br>retry: ####开启消费者（程序出现异常的情况下会）进行重试<br>enabled: true ####最大重试次数<br>max-attempts: 5 ####重试间隔次数<br>initial-interval: 3000</p><p>消费者重试过程中，如何避免幂等性问题</p><p>重试的过程中，为了避免业务逻辑重复执行，建议提前全局 id 提前查询，如果存在<br>的情况下，就无需再继续做该流程。<br>重试的次数最好有一定间隔次数，在数据库底层层面保证数据唯一性，比如加上唯一 id。</p><p>SpringBoot 开启消息确认机制</p><p>配置文件新增<br>spring:<br>rabbitmq: ####连接地址<br>host: 127.0.0.1 ####端口号<br>port: 5672 ####账号<br>username: guest ####密码<br>password: guest</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p>virtual-host: /meiteVirtualHosts<br>listener:<br>simple:<br>retry: ####开启消费者（程序出现异常的情况下会）进行重试<br>enabled: true ####最大重试次数<br>max-attempts: 5 ####重试间隔次数<br>initial-interval: 3000<br>acknowledge-mode: manual<br>datasource:<br>url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8<br>username: root<br>password: root<br>driver-class-name: com.mysql.jdbc.Driver</p><p>消费者 ack 代码</p><p><a href="/Slf4j">@Slf4j </a><br><a href="/Component">@Component </a><br><a href="/RabbitListener(queues">@RabbitListener(queues </a> = “fanout_order_queue”)<br>public class FanoutOrderConsumer {</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private OrderManager orderManager;</span><br><span class="line">@Autowired</span><br><span class="line">private OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">@RabbitHandler</span><br><span class="line">public void process(OrderEntity orderEntity, Message message, Channel channel) throws IOException &#123;</span><br></pre></td></tr></table></figure><p>//        try {<br>log.info(“&gt;&gt;orderEntity:{}&lt;&lt;”, orderEntity.toString());<br>String orderId = orderEntity.getOrderId();<br>if (StringUtils.isEmpty(orderId)) {<br>log.error(“&gt;&gt;orderId is null&lt;&lt;”);<br>return;<br>}<br>OrderEntity dbOrderEntity = orderMapper.getOrder(orderId);<br>if (dbOrderEntity != null) {<br>log.info(“&gt;&gt;该订单已经被消费过，无需重复消费!&lt;&lt;”);<br>// 无需继续重试<br>channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);<br>return;<br>}<br>int result = orderManager.addOrder(orderEntity);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;&gt;&gt;插入数据库中数据成功&lt;&lt;&quot;);</span><br><span class="line">if (result &gt;= 0) &#123;</span><br><span class="line">    // 开启消息确认机制</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//        int i = 1 / 0;<br>//        } catch (Exception e) {<br>//            // 将失败的消息记录下来，后期采用人工补偿的形式<br>//        }<br>}<br>}</p><h4 id="息确认机制"><a href="#息确认机制" class="headerlink" title="息确认机制"></a>息确认机制</h4><h5 id="配置文件新增"><a href="#配置文件新增" class="headerlink" title="配置文件新增"></a>配置文件新增</h5><p>| ```xml<br>spring:</p><p>rabbitmq:</p><h4 id="连接地址"><a href="#连接地址" class="headerlink" title="连接地址"></a>连接地址</h4><p>host: 127.0.0.1</p><pre><code>####端口号port: 5672####账号username: guest####密码password: guest### 地址virtual-host: /meiteVirtualHostslistener:</code></pre><p>simple:</p><p>retry:</p><h4 id="开启消费者（程序出现异常的情况下会）进行重试"><a href="#开启消费者（程序出现异常的情况下会）进行重试" class="headerlink" title="开启消费者（程序出现异常的情况下会）进行重试"></a>开启消费者（程序出现异常的情况下会）进行重试</h4><p>enabled: true</p><pre><code>####最大重试次数max-attempts: 5####重试间隔次数initial-interval: 3000acknowledge-mode: manualdatasource:url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=UTF-8</code></pre><p>username: root</p><pre><code>password: rootdriver-class-name: com.mysql.jdbc.Driver</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> |</span><br><span class="line">| --- |</span><br><span class="line"></span><br><span class="line">##### 消费者ack代码</span><br><span class="line"></span><br><span class="line">| ```java</span><br><span class="line">@Slf4j</span><br><span class="line"></span><br><span class="line">    @Component</span><br><span class="line"></span><br><span class="line">    @RabbitListener(queues = &quot;fanout_order_queue&quot;)</span><br><span class="line"></span><br><span class="line">    public class FanoutOrderConsumer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @Autowired</span><br><span class="line"></span><br><span class="line">        private OrderManager orderManager;</span><br><span class="line"></span><br><span class="line">        @Autowired</span><br><span class="line"></span><br><span class="line">        private OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @RabbitHandler</span><br><span class="line"></span><br><span class="line">        public void process(OrderEntity orderEntity, Message message, Channel channel) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">            //        try &#123;</span><br><span class="line"></span><br><span class="line">            log.info(&quot;&gt;&gt;orderEntity:&#123;&#125;&lt;&lt;&quot;, orderEntity.toString());</span><br><span class="line"></span><br><span class="line">            String orderId = orderEntity.getOrderId();</span><br><span class="line"></span><br><span class="line">            if (StringUtils.isEmpty(orderId)) &#123;</span><br><span class="line"></span><br><span class="line">                log.error(&quot;&gt;&gt;orderId is null&lt;&lt;&quot;);</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            OrderEntity dbOrderEntity = orderMapper.getOrder(orderId);</span><br><span class="line"></span><br><span class="line">            if (dbOrderEntity != null) &#123;</span><br><span class="line"></span><br><span class="line">                log.info(&quot;&gt;&gt;该订单已经被消费过，无需重复消费!&lt;&lt;&quot;);</span><br><span class="line"></span><br><span class="line">                // 无需继续重试</span><br><span class="line"></span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line"></span><br><span class="line">                return;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int result = orderManager.addOrder(orderEntity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            log.info(&quot;&gt;&gt;插入数据库中数据成功&lt;&lt;&quot;);</span><br><span class="line"></span><br><span class="line">            if (result &gt;= 0) &#123;</span><br><span class="line"></span><br><span class="line">                // 开启消息确认机制</span><br><span class="line"></span><br><span class="line">                channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //        int i = 1 / 0;</span><br><span class="line"></span><br><span class="line">            //        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            //            // 将失败的消息记录下来，后期采用人工补偿的形式</span><br><span class="line"></span><br><span class="line">            //        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>| |<br>| |</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2022/12/24/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/24/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、redis入门"><a href="#一、redis入门" class="headerlink" title="一、redis入门"></a>一、redis入门</h2><h3 id="redis介绍"><a href="#redis介绍" class="headerlink" title="redis介绍"></a>redis介绍</h3><p>是什么？</p><ul><li>基于内存的K/V存储中间件</li><li>NoSQL键值对数据库</li></ul><p>redis不仅是数据库，他还可以做消息队列</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661837971044-8d4a7ce9-a2da-4d15-bf7b-a5e38d5009b0.png?x-oss-process=image%2Fresize%2Cw_700%2Climit_0#averageHue=%23f5eeee&amp;from=url&amp;id=uwr5K&amp;originHeight=303&amp;originWidth=700&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>关系型SQL和NoSQL的对比<br />其中应用场景：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661838712523-ef4a9938-379e-4633-90cd-04fedfa53af4.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f3f1f1&amp;from=url&amp;id=PgkG4&amp;originHeight=367&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="Redis特征"><a href="#Redis特征" class="headerlink" title="Redis特征"></a>Redis特征</h3><ol><li>支持各种数据类型</li><li>单线程，每个命令的执行具备原子性,中途不会执行其他命令</li><li>高性能，低延迟</li><li>支持数据持久化</li><li>支持主从、分片集群</li><li>支持多语言客户端</li></ol><h3 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h3><p>Redis的命令根据数据结构分为多个组<br />1）redis 命令集 <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a><br />2）redis-cli help 命令查看，help[command]可以查看某个具体命令，help@xxx可以查看某个分组下的命令</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661860409628-60998ca7-81bc-427b-84ec-25ca927cacc7.png?x-oss-process=image%2Fresize%2Cw_618%2Climit_0#averageHue=%23152737&amp;from=url&amp;id=u5l36&amp;originHeight=330&amp;originWidth=618&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li>set key value</li><li>get key</li><li>key pattern 模糊搜索多个Key</li><li>del key…</li><li>exists key 判断key是否存在</li><li>expire key 设置过期时间</li><li>ttl key 查询剩余存活时间，未设置过期时间则为-1</li></ul><h3 id="Redis-基本数据类型"><a href="#Redis-基本数据类型" class="headerlink" title="Redis 基本数据类型"></a>Redis 基本数据类型</h3><h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><p>支持存储字符串、数字、浮点数<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661862706289-0d131c29-9848-41e9-89a9-4dd0e07d78ca.png#averageHue=%23cbcbc9&amp;from=url&amp;id=ZawBP&amp;originHeight=310&amp;originWidth=1420&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />单key的value最大不能超过512M<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661861550219-c870a6c5-c3b8-45c2-a98c-d40ee9da54cc.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f2f2f2&amp;from=url&amp;id=PlH8O&amp;originHeight=465&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>实际使用时，通常用冒号连接多个次来拼接key，比如【项目名】:【业务名】:【类名】:【id】<br />在使用GUI时，会自动根据冒号来划分层级，浏览更方便</p><h4 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h4><p>值是一个Hash结构(类似于java的HashMap)<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661862400679-42bd43d3-c014-4bef-84c6-cfda891a1e10.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23cececc&amp;from=url&amp;id=yXI2g&amp;originHeight=299&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>常用命令:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661862672521-cda7532d-f7df-45f8-afcd-05d711768631.png?x-oss-process=image%2Fresize%2Cw_760%2Climit_0#averageHue=%23f3f3f3&amp;from=url&amp;id=VOweh&amp;originHeight=442&amp;originWidth=760&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h4><p>理解为Java的LinkList 双向链表，特点是有序、插入删除快、但查询性能一般：<br />常见命令如下:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661863091505-4e936f4b-4bd9-4725-a3fe-3af79521b3b5.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f6f6f6&amp;from=url&amp;id=GsMpk&amp;originHeight=391&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h4><p>集合：类似于java的HashSet，特点是单set内集合不能重复，查找性能高<br />常见命令如下:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661863589046-7495e388-5607-4a74-8579-70110e2bcabf.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f1f0ef&amp;from=url&amp;id=uWNNe&amp;originHeight=354&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h4><p>有序集合，在set的基础上给每个元素多存了一个分数，类似于value类型为整形的Hashmap<br />特点：有序、查询性能高、适合于排行榜、统计TopN<br />常用命令:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661864069819-a212e48e-6847-402f-9c8b-c49da2035fd5.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f1f1f1&amp;from=url&amp;id=sZxwX&amp;originHeight=396&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="Redis-客户端"><a href="#Redis-客户端" class="headerlink" title="Redis 客户端"></a>Redis 客户端</h3><h4 id="主流客户端"><a href="#主流客户端" class="headerlink" title="主流客户端"></a>主流客户端</h4><p>可以在官网查看所有客户的以及推荐的客户端:<a href="https://redis.io/docs/clients">https://redis.io/docs/clients</a><br />对于Java主要以下几种：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661864923846-67ea2b28-c325-4086-af4a-bbc3edd04de4.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fef9f8&amp;from=url&amp;id=CZnv4&amp;originHeight=612&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />其中jedis的命令和原生redis命令行命令一致，学习成本最低（线程不安全，需要搭配连接池使用），letture和spring兼容型最好（spring Data Redis默认集成），基于netty性能最高，Redisson提供了和java集合一致的分布式集合，适用于更复杂的业务场景</p><h4 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h4><p>spring Data 封装了一系列数据访问操作，spring Data Redis则是封装了Jedis 、 Lettuce 两个Redis 客户端的操作，提供了统一的Redis Template 来操作Redis。<br />RedisTemplate 针对不同的Redis数据结构提供了不同的API，划分更明确：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661871634006-05f40eaf-65ce-4995-8f50-dc4e05294aaf.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23e6e6e3&amp;from=url&amp;id=C5nBx&amp;originHeight=249&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>注意：在使用spring Data Redis中使用Lettuce 线程池的话，要额外引入apache commons-pool2 依赖。</p><h4 id="RedisTemplate-序列化"><a href="#RedisTemplate-序列化" class="headerlink" title="RedisTemplate 序列化"></a>RedisTemplate 序列化</h4><p>RedisTemplate 默认使用JDK原生序列化器，可读性差、内存占用大、因此可以使用以下两种方式改变序列化机制：</p><ol><li>自定义RedisTemplate，指定key和value的序列化器</li><li>使用自带的StringRedisTemplate，key和value使用默认的String序列化器，仅支持写入String类型的key和value，因此需要将对象序列化为String来写入redis，从redis读取时也要反序列化。</li></ol><h3 id="共享Session（单点登录）"><a href="#共享Session（单点登录）" class="headerlink" title="共享Session（单点登录）"></a>共享Session（单点登录）</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>为什么要共享session？<br />防止多个后端服务器存储不一致，导致用户访问时出现未登录的情况</p><p>如何实现共享Session<br />使用独立的内存存储来实现Session</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661921616087-778dd8bf-63cc-4796-b1c3-677122547928.png?x-oss-process=image%2Fresize%2Cw_940%2Climit_0#averageHue=%23f7f6f6&amp;from=url&amp;id=eA3eN&amp;originHeight=427&amp;originWidth=940&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>key如何设计<br />为了安全性，随机生成Token，而不是拼接用户信息，防止恶意伪造或爆破</p><h4 id="选用何种value数据结构放入用户信息"><a href="#选用何种value数据结构放入用户信息" class="headerlink" title="选用何种value数据结构放入用户信息"></a>选用何种value数据结构放入用户信息</h4><p>string还是hash？有两种方案：<br />1、先在程序中将对象进行Json序列化，再以String类型写入<br />2、直接以Hash结构写入</p><p>因为用户信息时对象，建议选择hash数据结构，占用内存更少、且支持对单个字段的增删改查<br />具体流程：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661922180950-6aa9be44-d6cb-4753-a2c7-0b808e6de6ca.png?x-oss-process=image%2Fresize%2Cw_916%2Climit_0#averageHue=%23f1eeee&amp;from=url&amp;id=wqMa5&amp;originHeight=481&amp;originWidth=916&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>写入Redis的数据一定设置过期时间</li><li>存入redis的数据尽量保证精简安全，比如存入用户信息时移除密码等敏感数据</li><li>已登陆的用户访问系统后，记得刷新token过期时效，并且访问任何路径时都要刷新token，而不仅是登录的路径，可以新增一层的拦截器来实现token刷新，如下图：</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661923370328-3c051d77-234c-4553-a207-a0f897bd2779.png?x-oss-process=image%2Fresize%2Cw_955%2Climit_0#averageHue=%23e5d4d3&amp;from=url&amp;id=GUq5c&amp;originHeight=479&amp;originWidth=955&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>什么是缓存？<br />临时存放数据的缓冲区</p><p>缓存无处不在：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661923818451-afd131ec-3f5e-4147-af3d-2bcf310a0112.png?x-oss-process=image%2Fresize%2Cw_903%2Climit_0#averageHue=%23fafafa&amp;from=url&amp;id=faN9S&amp;originHeight=455&amp;originWidth=903&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>为什么需要缓存？<br />提前准备好数据，便于更快读写</p><p>缓存不是银弹，要权衡利弊！<br />优点：</p><ul><li>降低后端节点负载</li><li>提高数据读取性能</li></ul><p>缺点：</p><ul><li>额外引入中间间，增加运维成本</li><li>额外开发和解决缓存带来的问题，提高开发成本</li><li>需要保证数据一致性</li></ul><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>关键流程</p><ol><li>暂无缓存，从数据库读取，然后设置缓存</li><li>已有缓存，直接读取</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661924258122-ccc9a1d4-16a8-46bb-9e44-cd4d4a85ae42.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f2f2f2&amp;from=url&amp;id=z95iH&amp;originHeight=381&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><p>几种常见的策略，一般选择主动更新+超时剔除兜底：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661924949521-2c030516-1fe7-4685-85e4-c6b686b5a0fe.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23ecebeb&amp;from=url&amp;id=QBJBx&amp;originHeight=377&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>主动更新缓存的几种方法：</p><ol><li>cache aside ：通过人工编码，在更新数据库的同时更新缓存</li><li>write/read through ：使用现成的数据写入服务，原理就是将缓存和数据库整合为一套服务，让服务来维护数据库和缓存的一致性，我们只需要写数据即可，写完数据后缓存就有，我们不用关心数据一致性问题。</li><li>write behind cache：只更新缓存，通过异步线程定期将缓存的数据持久化到数据库</li></ol><p>是选择删除缓存还是更新缓存？<br />建议选择删除缓存，等待下次查询时自动设置缓存，做到随用随取，可以避免每次更新数据库后都更新缓存的无效操作</p><p>多线程情况下，如何保证缓存和数据库的一致性？</p><ol><li>单机：使用本地事务</li><li><p>分布式，使用TCC等分布式事务</p><p><br />先删除缓存还是先操作数据库<br />下图为两种方式在多线程下可能存在的问题：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661925752772-983448c9-25a2-486a-98fd-a723ea56ca82.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f4f3f3&amp;from=url&amp;id=bMsHT&amp;originHeight=390&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />两种方案都不能做到百分百一致性，但是建议选择先操作数据库，再删除缓存，出现问题的概率会更低，可以配合延时双删保证缓存一定被删除</p></li></ol><h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>客户端请求的数据在缓存和数据库中都不存在的，这样缓存永远不会生效，这些请求都会打到数据库。<br />解决方案：</p><ol><li>缓存空值：比如向redis中塞一个空字符串，注意可以给空对象设置一个短的过期时间，或者在新增数据时，强制清除下对应的缓存，防止查出来的为null；</li><li>布隆过滤</li></ol><p>初始化布隆过滤器：在Redis中，可以使用BitSet数据结构来实现位数组。可以使用SETBIT命令初始化位数组，将所有位都设置为0。<br />插入缓存数据：在缓存中存储正常的数据。对于每个要插入的数据，使用多个不同的哈希函数计算出多个哈希值，并将对应的位数组位置设置为1，表示该数据存在。<br />判断请求是否合法：当有请求到达时，先使用相同的多个哈希函数计算出对应的哈希值，并检查位数组中对应的位置是否都为1。如果有任何一个位置为0，则说明该请求的数据一定不存在，可以直接返回缓存未命中的结果，避免访问数据库。<br />处理缓存未命中：如果布隆过滤器判断请求的数据可能存在（即所有位置都为1），则继续从缓存中查询数据。如果缓存中也不存在该数据，则返回缓存未命中的结果。<br />通过使用布隆过滤器，可以在O(1)的时间复杂度内快速判断请求是否合法，减少对数据库的不必要访问，从而提高系统性能和安全性。然而，需要注意的是，布隆过滤器是一个概率型数据结构，存在一定的误判率。因此，在使用布隆过滤器时，需要根据实际情况进行调整，以平衡误判率和空间开销。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661944372353-2f44d70a-6207-42b5-8602-bdfb0330d159.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f5f5f5&amp;from=url&amp;id=LSlsY&amp;originHeight=328&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>预防做法：</p><ol><li>增加对请求数据的校验 ，比如id&gt;0</li><li>增加对数据格式的控制，比如id设置为10位，不为10位的请求直接拒绝</li><li>增加用户权限校验</li><li>通过限流来保护数据库</li></ol><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指在同一时间大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p><p>解决思路：</p><ol><li>不让key同时失效（可以为key设置时间时添加后缀，使到期时间相差几分钟，防止同一时间大量key失效）</li><li>Redis集群，提高服务可用性，不同Redis之间可以实现数据同步</li><li>为缓存添加多级缓存（nginx，redis，jvm等，最后查询数据库）</li><li>给缓存业务添加降级限流策略</li><li>尽量不让redis宕机</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661945589442-a88fd882-3452-461e-9adb-9bfa2a577eb6.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f3f0f0&amp;from=url&amp;id=yvVER&amp;originHeight=329&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿问题也叫热点key问题，就是一个被高并发访问并且缓存重建<br />业务较复杂的key失效，无数的请求在瞬间给数据库带来了巨大冲击</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661945757372-9427691c-56bc-4521-b996-e93c7351afe0.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f4f4f3&amp;from=url&amp;id=Hpp8s&amp;originHeight=369&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />两种解决方案：</p><ol><li>互斥锁：只有一个线程负责缓存重建，其他线程拿不到锁，就等待</li><li>逻辑过期：key设置为永不过期，在value中记录过期时间，业务中根据这个时间判断缓存是否有效，如果缓存已过期，只有一个线程抢到锁，然后再次判断缓存是否存在，开启独立的线程去更新缓存，然后立即返回过期数据，其他抢不到锁的线程也立即返回过期数据，不用等着释放。</li></ol><p>如图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661946415976-1cc6c5fa-f333-4088-9efe-a8431b857d43.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23eeeded&amp;from=url&amp;id=E9NeB&amp;originHeight=385&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>两种方式都使用了互斥锁来降低重建的开销。<br />方案优缺点对比:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1661946774577-4368f0a8-419c-42a4-87cd-6e3c8c81f957.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f8f8f6&amp;from=url&amp;id=k4abM&amp;originHeight=305&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>以上几种缓存常见问题的解决方案都是和业务无关的，因此可以封装自己的缓存操作封装类。</p><p>互斥锁解决思路：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1685064819205-654deccf-6b1f-4d73-8ad5-c65dc4887b9e.png#averageHue=%23f7f2f1&amp;clientId=u2541892d-404e-4&amp;from=paste&amp;height=469&amp;id=u936233a4&amp;originHeight=516&amp;originWidth=703&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=133210&amp;status=done&amp;style=none&amp;taskId=u19c0b384-1484-4792-be05-a37e8c2ffcd&amp;title=&amp;width=639.090895238987" alt="756IK1DE(17S%X`TTI{_N$7.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TbShop <span class="title function_">quarywithStuck</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> CACHE_QUERYSHOP_ID;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key + id);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> JSONUtil.toBean(json, TbShop.class);</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> tbShop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据为空值，因此该店铺不存在!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span> (!aBoolean) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            quarywithStuck(id);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        查库</span></span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">byId</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">if</span> (Optional.ofNullable(byId).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stringRedisTemplate.opsForValue().set(Key + id, JSONUtil.toJsonStr(byId));</span><br><span class="line">                stringRedisTemplate.expire(Key + id, CACHE_QUERYSHOP_ID_TTL, TimeUnit.MINUTES);</span><br><span class="line">                log.info(<span class="string">&quot;通过数据库查询数据并写入缓存!&quot;</span>);</span><br><span class="line">                relaseLock(LOCK_SHOP_KEY + id);</span><br><span class="line">                <span class="keyword">return</span> byId;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;缓存写入失败!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(Key + id, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            stringRedisTemplate.expire(Key + id, CACHE_QUERYSHOP_ID_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            log.info(<span class="string">&quot;通过数据库查询数据不存在，并写空值到缓存中!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>逻辑过期解决思路：<br />![L(3XY$%$`A~)%[MN)Q9GS<a href="https://cdn.nlark.com/yuque/0/2023/png/33551426/1685064766656-f3a27e75-9533-48b4-ac42-a8a754443aaa.png#averageHue=%23f8f3f3&amp;clientId=u2541892d-404e-4&amp;from=paste&amp;height=488&amp;id=u83297854&amp;originHeight=537&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=170563&amp;status=done&amp;style=none&amp;taskId=u89ee9c75-438c-4b37-8da5-2bd96afa702&amp;title=&amp;width=910.9090711656685">7.png</a><br />具体代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        缓存穿透解决方案</span></span><br><span class="line"><span class="comment">//        TbShop tbShop = quarywithNull(id);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        利用互斥锁解决缓存击穿</span></span><br><span class="line"><span class="comment">//        TbShop tbShop = quarywithStuck(id);</span></span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> quarywithLocalExpire(id);</span><br><span class="line">        <span class="keyword">if</span> (Optional.ofNullable(tbShop).isPresent()) &#123;</span><br><span class="line">            Result.fail(<span class="string">&quot;该店铺不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(tbShop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">50</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExpre</span><span class="params">(Long id, Long expireSecond)</span> &#123;</span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> <span class="built_in">this</span>.getById(id);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(tbShop);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSecond));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_QUERYSHOP_ID + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CHCHE_REBUTLD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑过期解决缓存击穿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TbShop <span class="title function_">quarywithLocalExpire</span><span class="params">(Long id)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> CACHE_QUERYSHOP_ID;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key + id);</span><br><span class="line"><span class="comment">//        未命中 为空，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        命中，判断是否过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">TbShop</span> <span class="variable">tbShop</span> <span class="operator">=</span> JSONUtil.toBean(data, TbShop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line"><span class="comment">//        未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> tbShop;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        已过期，尝试获取互斥锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> tryLock(LOCK_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">if</span> (!aBoolean) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;未获取到锁&quot;</span>);</span><br><span class="line"><span class="comment">//        获取失败，返回旧数据</span></span><br><span class="line">            <span class="keyword">return</span> tbShop;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//        获取成功，开启独立线程，返回旧数据</span></span><br><span class="line">            log.info(<span class="string">&quot;已获取到锁&quot;</span>);</span><br><span class="line">            CHCHE_REBUTLD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.setExpre(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//               释放锁</span></span><br><span class="line">                    relaseLock(LOCK_SHOP_KEY + id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tbShop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h4><p>引入模块:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>解决问题（缓存穿透（空值）、缓存击穿(逻辑过期)）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.BooleanUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.StrUtil;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.xiaozhang.entity.domain.TbShop;</span><br><span class="line"><span class="keyword">import</span> com.xiaozhang.exception.BusinessException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xiaozhang.utils.RedisConstants.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xiaozhang.utils.RedisConstants.LOCK_SHOP_KEY;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:22603</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>:2023/5/27 13:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisClient</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setwithLocalExpire</span><span class="params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(value);</span><br><span class="line">        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存穿透利用空值解决</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  &lt;R, ID&gt; R <span class="title function_">quarywithNull</span><span class="params">(String keyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbfallck, Long time, TimeUnit unit,Long cacheWithNull,TimeUnit unitWithNull)</span> &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> keyPrefix + id;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(json)) &#123;</span><br><span class="line">            <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(json, type);</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (json != <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;通过缓存查询数据为空值!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        查库</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> dbfallck.apply(id);</span><br><span class="line">        <span class="keyword">if</span> (Optional.ofNullable(result).isPresent()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.set(Key, result, time, unit);</span><br><span class="line">                log.info(<span class="string">&quot;通过数据库查询数据并写入缓存!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, <span class="string">&quot;缓存写入失败!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//            将空值写入redis</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(Key, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            stringRedisTemplate.expire(Key, cacheWithNull, unitWithNull);</span><br><span class="line">            log.info(<span class="string">&quot;通过数据库查询数据不存在，并写空值到缓存中!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean <span class="title function_">tryLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="string">&quot;1&quot;</span>, <span class="number">50</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(aBoolean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">relaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立线程池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CHCHE_REBUTLD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑过期解决缓存击穿</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;R,ID&gt; R <span class="title function_">quarywithLocalExpire</span><span class="params">(String keyPrefix,String lockeyPrefix, ID id, Class&lt;R&gt; type, Function&lt;ID, R&gt; dbfallck, Long time, TimeUnit unit)</span> &#123;</span><br><span class="line"><span class="comment">//        设置key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">Key</span> <span class="operator">=</span> keyPrefix+id;</span><br><span class="line"><span class="comment">//        查缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(Key);</span><br><span class="line"><span class="comment">//        未命中 为空，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(json)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        命中，判断是否过期</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(json, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(data, type);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line"><span class="comment">//        未过期，直接返回店铺信息</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        已过期，尝试获取互斥锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">aBoolean</span> <span class="operator">=</span> tryLock(lockeyPrefix + id);</span><br><span class="line">        <span class="keyword">if</span> (!aBoolean) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;未获取到锁&quot;</span>);</span><br><span class="line"><span class="comment">//        获取失败，返回旧数据</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//        获取成功，开启独立线程，返回旧数据</span></span><br><span class="line">            log.info(<span class="string">&quot;已获取到锁&quot;</span>);</span><br><span class="line">            CHCHE_REBUTLD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(lockeyPrefix + id);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> dbfallck.apply(id);</span><br><span class="line">                    <span class="built_in">this</span>.setwithLocalExpire(Key,result,time,unit);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(ErrorCode.SYSTEM_ERROR, e.toString());</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//               释放锁</span></span><br><span class="line">                    relaseLock(lockeyPrefix + id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="分布式全局ID生成"><a href="#分布式全局ID生成" class="headerlink" title="分布式全局ID生成"></a>分布式全局ID生成</h3><p>为什么需要分布式全局ID生成器?<br />1.对于订单这种数据，数据库自增的规律性太明显，会暴露一些信息（比如根据昨日和今日的订单号差值看出销<br />量)<br />2．数据量过大时，不同表的id分别自增，容易出现id冲突</p><p>分布式全局ID生成应满足的特点:<br />1．唯一:整个系统每个id都是唯一的<br />2．递增:虽然不连续，但整体ID保持递增，有利于数据库创建索引(也符合自然规律)<br />3．安全:不能通过id看出敏感业务信息<br />4．高可用:作为核心服务，不能挂掉，否则会影响新数据的生成5．高性能:作为频繁调用的服务，性能—定要高</p><p>几种常见的ID生成方法，建议根据自己的实际需求选择和设计算法:</p><ul><li>雪花算法:性能更高，引入机器序号，但依赖全局时钟</li><li>数据库自增:单独的自增表，所有id全从这个表取。但性能没有Redis高</li><li>UUID:随机生成十六进制字符串，性能高，但是乱序、字符串会占用更多空间</li><li>Redis自增ID:利用incr命令实现单key的自增</li></ul><p>Redis自增ID完全可以满足以上几个分布式全局ID的特点。</p><h4 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h4><p>以下是一种ID生成的设计，使用Long类型存储ID<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1685174529136-c1643a46-bf91-43de-baa6-3a59afc22dd8.png#averageHue=%23f6f4f4&amp;clientId=ud5f11d0f-88e8-4&amp;from=paste&amp;height=516&amp;id=u416a5458&amp;originHeight=568&amp;originWidth=1172&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=162891&amp;status=done&amp;style=none&amp;taskId=ua1273b1b-761b-4b35-996c-309a0a8cf88&amp;title=&amp;width=1065.4545223614407" alt="T]6]UP)NBR)~0HR2H68`_%G.png"></p><p>使用Redis的incr命令，可以实现后32位的原子性递增。<br />Redis的key可以设计为[业务]:[类型]:[日期],这样每天都会从1开始生成序列。如果用单key，可能出现生成的序号数溢出2^32的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1685318400L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="优惠券秒杀流程"><a href="#优惠券秒杀流程" class="headerlink" title="优惠券秒杀流程"></a>优惠券秒杀流程</h3><p>秒杀业务的核心流程是:判断日期和库存、扣减库存、创建订单<br />如下图:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662008375039-1a71b20d-1d87-4607-b7e0-c29b05808d41.png?x-oss-process=image%2Fresize%2Cw_615%2Climit_0#averageHue=%23fbfafa&amp;from=url&amp;id=lvLMK&amp;originHeight=488&amp;originWidth=615&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>注意，秒杀库存信息和商品信息最好是独立的两张表，不要放在一起影响性能。</p><h3 id="订单超卖问题"><a href="#订单超卖问题" class="headerlink" title="订单超卖问题"></a>订单超卖问题</h3><p>出现的原因：有多个人同时下单，在库存扣减前大家查库存都大于0，都触发了减库存的操作</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662008722698-a9549270-6dc2-4ede-b081-07e0e6ba0456.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f5f5f5&amp;from=url&amp;id=d6i0q&amp;originHeight=402&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>解决方法：</p><p>1）悲观锁:假定每次并发都会冲突，所以干脆给操作整体加锁，将并发改为同步执行。可以通过synchronized关键字实现。<br />优点是实现简单，缺点是严重影响性能(大家可以同时抢购)。</p><p>2)乐观锁:假定并发不一定会冲突，所以不加锁，而是通过判断数据是否在查出来之后被其他线程修改过，来决定是否允许操作。</p><p>乐观锁主要有版本号法和CAS两种实现方式。</p><p>版本号法:<br />给数据增加一个版本号字段，每次修改操作版本号＋1，就可以通过版本号来判断数据是否有被修改。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662009330789-7326c51e-3039-456c-8f3d-b4530e53445b.png?x-oss-process=image%2Fresize%2Cw_945%2Climit_0#averageHue=%23faf9f9&amp;from=url&amp;id=Z296U&amp;originHeight=431&amp;originWidth=945&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>CAS是对乐观锁的简化，即直接用一个每次都会查询和更新的字段来代替版本号，比如库存stock 字段:<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662009326982-7488a52c-d95d-4d88-85a0-29d5884b28f0.png?x-oss-process=image%2Fresize%2Cw_935%2Climit_0#averageHue=%23fbfafa&amp;from=url&amp;id=bzJgq&amp;originHeight=420&amp;originWidth=935&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>优点:性能好<br />缺点:存在成功率低的问题(很多人查到的版本号是一样的，结果只能有一个人操作成功)，可以使用分段锁来改进。比如将100个库存分为10份，大家分别抢这10份。</p><p>对于以上这种场景，其实不用判断stock是否变化，可以直接判断stock &gt; 0，从而保障成功率。</p><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>对应视频P54，这集封神<br />优惠券或者秒杀活动的目的是为了吸引新用户，因此不能让一个用户把所有东西都抢走了。所以需要额外判断用户当前下单数是否&gt; 0。<br />这一步操作在多线程场景下依然会出现问题:新用户第一次进来同时抢10次，结果判断下单数都是0，然后就都抢成功了。<br />所以还是需要加锁，因为订单是新创建的数据，所以无法使用乐观锁，使用悲观锁实现。</p><h4 id="单机实现"><a href="#单机实现" class="headerlink" title="单机实现"></a>单机实现</h4><p>单机部署后端服务器时，可以使用java自带的synchronized关键字作为悲观锁<br />要注意几个细节问题：<br />1）synchronized的范围不能太大，不能锁住整个对象，会严重影响性能，因为是一人一单 ，所有可以每个用户独立的一把锁。<br />注意:锁住 对象时要用toString().intern()，保证同id的用户始终是同一个用户，单单tostring，会new一个String，相当于一个新对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">synchronized</span> (id.toString().intern()) &#123;</span><br><span class="line"><span class="comment">//            获取事务代理对象</span></span><br><span class="line">            <span class="type">TbVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>2)synchronized必须在使用@Transactional注解的方法外层使用，因为@Transactional是使用代理对象，，在方法执行完才能提交事务，如果把synchronized写在事务方法里，提交事务前释放锁，但此时数据未更新，其他线程依然能获取锁并顺利执行，依然会存在线程问题<br />3）调用事务方法不能用this对象，因为@Transactional注解实际是调用spring生成的代理对象方法，如果调用this对象，会无法使用事务功能，所以要获取代理对象并调用。<br />代码实现：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662011259738-a6a16663-4e36-438d-9e78-f40063cd67c4.png?x-oss-process=image%2Fresize%2Cw_717%2Climit_0#averageHue=%23f1f4eb&amp;from=url&amp;id=IHVIc&amp;originHeight=141&amp;originWidth=717&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="分布式实现"><a href="#分布式实现" class="headerlink" title="分布式实现"></a>分布式实现</h4><p>synchronized只对单个jvm有效，多机部署可能同时有多个不同的jvm线程访问已加锁的方法。<br />具体原理：<br />单机条件下，只有一个tomcat，一个tomcat服务器相当于有一个全新的jvm，在jvm内部维护了一个锁监视器对象，在Id相同的情况下，只能存放一个线程，其他线程进来时不允许访问，维护的是同一个用户。在集群模式下，会有多个jvm存在，每个jvm内部有自己的锁，每个锁相互独立，多个线程同时运行，会存在线程安全问题。<br />如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662030241202-f47dd469-1d9b-4df5-9f26-092d2730d984.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23efeded&amp;from=url&amp;id=WdnrZ&amp;originHeight=341&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>因此，我们不能把锁存储在单个服务器上，而是应该使用一个集中的存储来管理锁，所以进程都能读到他，这就需要分布式锁。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁：满足分布式系统或者集群模式下多个进程可见并且互斥的锁</p><p>分布式锁的两个基本特征：</p><ol><li>多进程（线程）可见（读写）</li><li>互斥</li></ol><p>还具备的特征：</p><ol><li>高可用：不能挂机，不能经常出现问题</li><li>高性能（并发）：读写快</li><li>安全性：不能出现死锁<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4>注意有三种：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662031300272-0956bc6b-69e4-48f5-87fe-47b7e5df15d8.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f8f2f0&amp;from=url&amp;id=O5br0&amp;originHeight=318&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />其中，mysql的实现成本最低、redis性能最高，Zookeeper可以实现，但是不推荐（保证的是强一致性而不是性能和高可用性，cp模式）</li></ol><h4 id="Redis-分布式锁实现"><a href="#Redis-分布式锁实现" class="headerlink" title="Redis 分布式锁实现"></a>Redis 分布式锁实现</h4><p>获取锁：</p><ul><li>使用setnx命令设置lock（本质是键值对），保证只有一个线程取锁成功。并执行业务逻辑，其他线程可以重试或返回失败</li><li>必须setnx指定lock、过期时间（满足安全性）</li></ul><p>注意事项：</p><ol><li>为了防止setnx后宕机导致死锁，必须使用set 【key】 ex nx 的原子命令，保证每个lock都有过期时间</li><li>锁的key建议设计包含userid，保证多个用户可以并发执行，而不是多个用户抢同一把锁。</li></ol><p>释放锁：</p><ul><li>主动是否：业务执行完删除key，注意释放锁的逻辑放在finlly中</li><li>超时自动释放（key过期）</li></ul><p>流程：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662031740955-361196d9-008c-430f-96c9-968da059d16e.png#averageHue=%23f8f6f6&amp;from=url&amp;id=WjNSy&amp;originHeight=822&amp;originWidth=598&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="误删情况"><a href="#误删情况" class="headerlink" title="误删情况"></a>误删情况</h4><h5 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h5><p>如果线程A执行业务时间过长，锁提前过期了，另一个线程B拿到锁并执行业务流程，这是A突然又执行完了，结果误删了线程B加的锁，会导致新的线程C又可以拿到锁，从而又出现线程安全问题<br /> <img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662052166859-f38be15f-b57d-40e9-ba2c-1fb638039954.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23faf9f9&amp;from=url&amp;id=QMusl&amp;originHeight=314&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="情况1解决方案"><a href="#情况1解决方案" class="headerlink" title="情况1解决方案"></a>情况1解决方案</h5><p>在获取锁的时候value中存入【本机标识+当前线程id】，释放锁时检测value必须等于该值，是自己的锁才可以释放。<br />注意：不能只在value中存入线程id，因为多个机器的线程id可能是一样的，仍然可能出现问题，因此可以给每个机器生成一个唯一标识，再拼接id</p><p>流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662051386701-c39bfd2a-1e7a-43fb-8af2-cb6380ddc4db.png?x-oss-process=image%2Fresize%2Cw_322%2Climit_0#averageHue=%23f1edea&amp;from=url&amp;id=V0xeE&amp;originHeight=383&amp;originWidth=322&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h5><p>假设线程A释放锁时判断了是自己的锁，但这时jvm触发了stop the world，线程A卡住了，然后锁超时释放了，线程B拿到了锁的执行业务，这时，线程A醒来了，删除了锁key，线程c正好进来啦，拿到了锁并执行，又出现了线程安全问题。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662051917992-256924ba-49b7-4eeb-bff8-0db968eea18d.png?x-oss-process=image%2Fresize%2Cw_657%2Climit_0#averageHue=%23f9f8f8&amp;from=url&amp;id=fyRJ7&amp;originHeight=382&amp;originWidth=657&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="情况2-解决方案"><a href="#情况2-解决方案" class="headerlink" title="情况2 - 解决方案"></a>情况2 - 解决方案</h5><p>问题的本质是判断锁value和删除锁是两个动作，不具备原子性！<br />可以使用redis lua脚本，将多个redis 命令放到一个脚本中，整个脚本的执行具有原子性。<br />Lua语言是轻量级脚本语言，很方便嵌入各种应用程序中。<br /><a href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a><br />Lua脚本可以使用redis.call 调用redis命令，并支持传递动态参数：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662052994671-0557ed25-ed75-4aec-8341-e91371d3647c.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23d1d6ca&amp;from=url&amp;id=KRx2S&amp;originHeight=380&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>用Lua脚本释放锁脚本如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662093874892-f64e6e31-c729-45af-83c1-e5a4b04363b0.png?x-oss-process=image%2Fresize%2Cw_546%2Climit_0#averageHue=%230f2332&amp;from=url&amp;id=VppHF&amp;originHeight=132&amp;originWidth=546&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="Redis分布式锁的实现思路"><a href="#Redis分布式锁的实现思路" class="headerlink" title="Redis分布式锁的实现思路"></a>Redis分布式锁的实现思路</h5><ul><li>利用set nx ex 获取锁，nx确保互斥，只有一个线程能拿到锁，ex兜底，过期锁自动删除</li><li>释放锁时先判断线程标识是否和自己一致，一致则删除。</li></ul><p>特性：</p><ul><li>利用set nx ex 满足互斥性</li><li>利用set ex保证故障时依然可以释放，避免死锁</li><li>利用Redis集群保证高可用和高并发<h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><h5 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h5>除了误删之外，现在的分布式锁实现还存在以下几个问题:</li></ul><ol><li>不可重入:同一个线程无法获取同一把锁（递归调用或调用的子函数抢同一把锁时就会出现死锁)</li><li>不可重试:没抢到锁就失败了</li><li>超时释放:业务未执行完，锁就超时释放了</li><li>主从一致性:主节点设置锁成功，还未及时同步到从节点，这时主节点宕机，从节点被选为主节点。但此时从</li></ol><p>节点还没有锁，仍可以抢锁成功。</p><p>要自己解决这些问题，非常麻烦，所以我们一般会选择现成的类库，比如Redisson。</p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson 是java的Redis高级客户端，提供了各种现成的分布式工具类方便我们使用Redis<br />中文文档：<a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></p><p>1）引入独立的Redisson包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>2)创建一个Redisson客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaozhang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redisson 配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 22603</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">redisAddress</span> <span class="operator">=</span> String.format(<span class="string">&quot;redis://%s:%s&quot;</span>, host, port);</span><br><span class="line">        config.useSingleServer().setAddress(redisAddress).setPassword(password).setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2. 创建实例</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>3)使用Redisson的lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + id);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line"><span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许同一用户重复下单!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">TbVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="如何实现可重入锁？"><a href="#如何实现可重入锁？" class="headerlink" title="如何实现可重入锁？"></a>如何实现可重入锁？</h5><p>目的：保证同一个线程可以多次获取同一把锁<br />解决思路：在锁的value中额外保存当前线程获取锁的次数，每次获取锁+1，释放锁-1，当次数为0时真正可以了删除key</p><p>Redisson 底层也是通过lua脚本实现可重入锁</p><p>采用hash结构来存储锁信息：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662098121346-c34758fa-9b99-412a-9b42-6fe8cd30bda3.png#averageHue=%23e0e0e2&amp;from=url&amp;id=bFEXY&amp;originHeight=232&amp;originWidth=450&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>流程：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662097922411-4ba1a8d5-e402-4ddf-8596-b19f13a5f216.png?x-oss-process=image%2Fresize%2Cw_389%2Climit_0#averageHue=%23e8dddb&amp;from=url&amp;id=iMT3a&amp;originHeight=417&amp;originWidth=389&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>注意：</p><ol><li>所有的判断和操作都需要使用Lua脚本来保证原子性</li><li>每次获取和释放锁时要重置锁的有效期，就像抢到新锁一样，给业务充分的执行时间</li></ol><p>获取锁的Lua脚本:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--获取锁的key</span></span><br><span class="line"><span class="keyword">local</span> key=key[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--获取线程唯一标识</span></span><br><span class="line"><span class="keyword">local</span> thread =ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--所得自动释放时间</span></span><br><span class="line"><span class="keyword">local</span> releaseTime= ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">--判断锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;exists&#x27;</span>,key)==<span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--不存在，获取锁</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hset&#x27;</span>,key,thread,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">--设置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,key,releaseTime)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--若锁存在  判断锁是否为自己的</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>,key,thread)==<span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--是自己的，则统计数+1</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>,key,thread,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="comment">--设置有效期</span></span><br><span class="line">    redis.call(<span class="string">&#x27;expire&#x27;</span>,key,releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">--返回结果</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>释放锁的Lua脚本<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---释放</span></span><br><span class="line"><span class="comment">--- Generated by Luanalysis</span></span><br><span class="line"><span class="comment">--- Created by 22603.</span></span><br><span class="line"><span class="comment">--- DateTime: 2023/6/10 9:34</span></span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="comment">---获取key</span></span><br><span class="line"><span class="keyword">local</span> key = Key[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--获取唯一标识</span></span><br><span class="line"><span class="keyword">local</span> thread = ARGV[<span class="number">1</span>];</span><br><span class="line"><span class="comment">--获取锁的自动释放时间</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>];</span><br><span class="line"><span class="comment">--判断锁是否为自己的锁</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, thread) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--是自己的锁，则冲入次数-1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, thread, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">--如果</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, Key, releaseTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;DEL&#x27;</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h5 id="如何实现重试获取锁？"><a href="#如何实现重试获取锁？" class="headerlink" title="如何实现重试获取锁？"></a>如何实现重试获取锁？</h5><p>基于redis pub/sub发布订阅机制，如果获取锁失败，则阻塞订阅释放所得消息，当锁被释放时，会触发推送（告诉其他线程我释放锁），然后其他线程再重试获取，如此以往，直到超时。</p><h5 id="如何防止锁提前释放？"><a href="#如何防止锁提前释放？" class="headerlink" title="如何防止锁提前释放？"></a>如何防止锁提前释放？</h5><p>基于看门狗机制，如果不手动设置释放时间，默认设置30s过期，并且给当前锁注册一个定时任务，该定时任务每隔1/3的锁释放时间（一般是10s），会重置锁的过期时间（递归调用，一次续期完了再）。</p><p>需要考虑两个问题：</p><ol><li>如何保证同一个锁只注册一个定时任务？</li><li>如何防止无线续期？</li></ol><p>要解决这些问题，使用全局ConcurrentHashMap来管理锁=&gt;任务信息，key为锁的id，从而保证唯一，当某个锁释放时，从全局ConcurrentHashMap中取处定时任务并取消，然后把锁的消息从Map中删除即可。</p><p>最终，完整的分布式锁流程如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662120120114-c6cb6b96-0d32-4d1d-9d70-63f20fdc1ace.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fcfcfc&amp;from=url&amp;id=Ksuix&amp;originHeight=354&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="Redisson主从一致性问题"><a href="#Redisson主从一致性问题" class="headerlink" title="Redisson主从一致性问题"></a>Redisson主从一致性问题</h5><p>如果使用主从复制的多台redis集群，可能出现主从节点设置的锁状态不一致的问题。<br />可以使用Redisson的MultiLock（联锁）来解决，核心思想是开启多个独立的Redis主节点，设置锁时必须在所有的主节点都写入成功，才算设置成功。</p><p>这样做哪怕有部分节点挂掉，其他线程也无法setnx全部成功，就不会出现重复执行业务的问题。</p><p>如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662135970012-219beab6-83e4-47f2-b6c3-490875f31be3.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f0ece3&amp;from=url&amp;id=tGbsi&amp;originHeight=285&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />实现MultiLock的几个关键：</p><ol><li>遍历所有节点，依次设置锁，并使用列表记录所有主节点的锁是否设置成功。</li><li>只要有一个节点设置不成功，就要释放锁，从头来过。</li><li>因为不同节点设置成功的时间不同，所以所有锁设置成功后，要统一设置过期时间（但如果leaseTime=-1就不用设置，因为开启了看门狗机制会自动续期）</li><li>释放锁时间（leasetime）必须要大于抢锁最大等待时间（waitTime），否则可能出现第一个节点抢到锁，最后一个节点还没抢到锁，之前的锁已经超时释放了，所有如果指定了waitTime和leaseTime，默认leasetime=waitTime*2</li></ol><p>MultiLock最安全，但同样会带来很大的运维成本。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686564559708-ccbd6909-113b-4f75-919f-c3fed1d2d1e8.png#averageHue=%23ebebeb&amp;clientId=uaaefd9b4-4e39-4&amp;from=paste&amp;height=353&amp;id=u897e08d6&amp;originHeight=530&amp;originWidth=633&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=120131&amp;status=done&amp;style=none&amp;taskId=u72602ece-0e50-40f4-afaf-ab2d7877c36&amp;title=&amp;width=422" alt="1686564553020.png"></p><h3 id="秒杀业务优化"><a href="#秒杀业务优化" class="headerlink" title="秒杀业务优化"></a>秒杀业务优化</h3><p>优化思路：</p><ul><li>串行改并行：原本由一个线程的操作改为由两个或多个线程同时执行，比如一个线程负责判断秒杀资格，一个线程负责减库存+创建订单（写操作）</li><li>同步改异步：判断完秒杀资格后，就可以返回订单id给前端，其余的写操作可以异步执行。</li><li>提高判断秒杀资格的性能：读DB改为读redis</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662138152995-d16f2727-c4d9-40da-bf39-065150d7ed0a.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fcfcfc&amp;from=url&amp;id=Xr5II&amp;originHeight=347&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>优化后的流程如下：<br />1）将库存信息提前缓存到redis中，并使用set来记录用户是否下单，实现仅在redis里判断秒杀资格<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662170418646-2bafd7db-ad02-43c9-a0e6-724fee09823c.png#averageHue=%23e5e6e5&amp;from=url&amp;id=D4uww&amp;originHeight=150&amp;originWidth=1416&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />2）将判断秒杀资格的逻辑封装为Lua脚本，保证原子性，原业务流程调用即可、<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686620752062-bb46f036-193d-4a86-bdaa-2041cb9bde4e.png#averageHue=%23f0efef&amp;clientId=uaaefd9b4-4e39-4&amp;from=paste&amp;height=253&amp;id=ua1d0de2c&amp;originHeight=379&amp;originWidth=551&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=72363&amp;status=done&amp;style=none&amp;taskId=u3c4aa951-9ddf-41fb-acae-fe8f5005ce8&amp;title=&amp;width=367.3333333333333" alt="1686620746821.png"><br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 优惠卷id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 缓存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 1、判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 1.1 不充足直接返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 1.2 充足</span></span><br><span class="line"><span class="comment">-- 1.2.1 判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 买过返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 未买过返回 扣库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>,stockKey,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">--下单</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>,orderKey,userId);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>3）确认有秒杀资格后，将订单信息传递给阻塞队列，单个独立线程串行从队列中取出信息并异步下单<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662170512882-07909c3b-932c-4f8f-bbf8-16f5f6d9d83d.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f6f6f6&amp;from=url&amp;id=hED9d&amp;originHeight=288&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />这样一来，可以大大提高性能。<br />阻塞队列可以使用jdk原生的BlockingQueue实现，记得指定队列容量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> TbSeckillVoucherService tbSeckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdWorker redisIdWorker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;TbVoucherOrder&gt; blockingDeque = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  提供了一系列方法来管理线程池和执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_SERVICE</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类加载完成后执行初始化任务</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHander</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化代理对象</span></span><br><span class="line">    <span class="keyword">private</span> TbVoucherOrderService proxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    开启一个独立的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHander</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">TbVoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> blockingDeque.take();</span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;异步抢购失败:&quot;</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠卷秒杀优化</span></span><br><span class="line"><span class="comment">     * 串行改并行：原本由一个线程的操作改为由两个或多个线程同时执行</span></span><br><span class="line"><span class="comment">     * 比如一个线程负责判断秒杀资格，一个线程负责减库存+创建订单（写操作）</span></span><br><span class="line"><span class="comment">     * 同步改异步：判断完秒杀资格后，就可以返回订单id给前端，其余的写操作可以异步执行。</span></span><br><span class="line"><span class="comment">     * 提高判断秒杀资格的性能：读DB改为读redis</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//        1、执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">                SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString()</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//        2、判断结果为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//        2.1 不为0，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(value == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2.2 为0 ，有资格，把下单信息保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        2. 保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        获取代理对象</span></span><br><span class="line">        proxy = (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        tbVoucherOrder.setId(order);</span><br><span class="line">        tbVoucherOrder.setVoucherId(voucherId);</span><br><span class="line">        tbVoucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line"><span class="comment">//        将订单添加到阻塞队列中</span></span><br><span class="line">        blockingDeque.add(tbVoucherOrder);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleVoucherOrder</span><span class="params">(TbVoucherOrder tbVoucherOrder)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        1.获取对象</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> tbVoucherOrder.getUserId();</span><br><span class="line"><span class="comment">//        2.获取锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + userId);</span><br><span class="line"><span class="comment">//        3.获取锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1L</span>, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//        4.失败返回</span></span><br><span class="line">        <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        5.代理对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proxy.createVoucherOrder2(tbVoucherOrder);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder2</span><span class="params">(TbVoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">//      获取订单数量</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> voucherOrder.getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, id).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;重复购买&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      扣减</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tbSeckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).ge(<span class="string">&quot;voucher_id&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.save(voucherOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="优惠卷秒杀"><a href="#优惠卷秒杀" class="headerlink" title="优惠卷秒杀"></a>优惠卷秒杀</h4><h5 id="原始方法"><a href="#原始方法" class="headerlink" title="原始方法"></a>原始方法</h5><p>流程图：<br /><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/33551426/1686628797776-88c48a66-791d-4ee2-b01e-6afd10874035.jpeg" alt=""></p><p>代码逻辑：</p><ol><li>判断秒杀是否开始</li><li>判断库存</li><li>单机情况下为解决超卖问题，为确保原子性，将获取订单数量、判断是否购买、扣减、保存订单信息等和数据库相关的写操作加悲观锁</li><li>分布式情况下，为实现带来的数据不一致性问题，采用分布式锁实现<img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662030241202-f47dd469-1d9b-4df5-9f26-092d2730d984.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0%2Fresize%2Cw_750%2Climit_0#averageHue=%23efeded&amp;from=url&amp;id=NbM4S&amp;originHeight=341&amp;originWidth=750&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></li></ol><p>代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">TbSeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> tbSeckillVoucherService.getById(voucherId);</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀未开始&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seckillVoucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="comment">//      ① synchronized 单机实现   锁的整个方法</span></span><br><span class="line"><span class="comment">//        synchronized (id.toString().intern()) &#123;</span></span><br><span class="line"><span class="comment">//            获取事务代理对象</span></span><br><span class="line"><span class="comment">//            TbVoucherOrderService proxy = (TbVoucherOrderService) AopContext.currentProxy();</span></span><br><span class="line"><span class="comment">//            return proxy.createVoucherOrder1(voucherId);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//          ② 分布式实现  锁的整个方法</span></span><br><span class="line"><span class="comment">//        SimpleRedisLock simpleRedisLock = new SimpleRedisLock(&quot;order:&quot; + id, stringRedisTemplate);</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:order:&quot;</span> + id);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tryLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1L</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="keyword">if</span> (!tryLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不允许同一用户重复下单!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">TbVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">            <span class="keyword">return</span> proxy.createVoucherOrder1(voucherId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式解决优惠卷秒杀</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">createVoucherOrder1</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//      获取订单数量</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, id).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;该用户已购买一次!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      扣减</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tbSeckillVoucherService.update().setSql(<span class="string">&quot;stock=stock-1&quot;</span>).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).ge(<span class="string">&quot;voucher_id&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        tbVoucherOrder.setId(order);</span><br><span class="line">        tbVoucherOrder.setVoucherId(voucherId);</span><br><span class="line">        tbVoucherOrder.setUserId(UserHolder.getUser().getId());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.save(tbVoucherOrder)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h5 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h5><ol><li>将秒杀功能中对优惠卷信息 、订单信息缓存到redis中，为了数据的原子性，通过使用Lua脚本，来进行对redis中优惠卷以及订单信息的判断，最终，若用户首次购买，则将优惠卷信息添加到阻塞队列中，然后返回订单id。</li><li><p>异步开启一个独立的线程，去读取阻塞队列中的优惠卷信息，然后进行减库存以及保存订单信息等对数据库的写操作。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>jdk阻塞队列可能存在哪些问题？</p></li><li><p>服务器宕机，内存队列的订单信息全部丢失</p></li><li>线程处理错误，已读出单个订单信息，但是没有入库</li><li>受单个jvm内存限制</li></ol><p>所有，我们需要一个独立的队列来存管订单信息，也就是消息队列。</p><h4 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h4><p>存管消息的队列，也是一种开发常用的中间件。<br />消息队列包括三个角色：</p><ol><li>消息队列：用于存放消息，类似于快递柜</li><li>生产者：发送消息到队列，类似快递员</li><li>消费者：从队列取走消息，类似于取快递的人</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662173544679-5086e788-493d-49ee-9ec3-81094b25119f.png#averageHue=%23a2b96c&amp;from=url&amp;id=sjkEg&amp;originHeight=180&amp;originWidth=1596&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>使用消息队列的优点：</p><ul><li>可以确保消息的安全、不丢失（快递柜上锁）</li><li>可以解藕生产者和消费者（不用立刻去取快递）</li><li>独立组件，不影响jvm</li><li>可以保证消息一定被接受，避免线程处理错误后订单丢失的问题</li><li>消息是有序的</li></ul><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="Redis-List实现"><a href="#Redis-List实现" class="headerlink" title="Redis List实现"></a>Redis List实现</h5><p>使用Redis List 的结构作为消息队列，使用LPush模拟生产者发送消息入队，使用BRPOP模拟消费者取出消息，没有消息时会保持阻塞状态，从而实现类似jvm阻塞队列的效果</p><p>可以满足消息队列的安全性（redis的持久化机制）、有序、独立内存的要求。<br />缺点：</p><ol><li>只能存在单消费者</li><li>消息获取之后就删除了，无法保证业务一定办理成功</li></ol><h5 id="Redis-Pub-Sub"><a href="#Redis-Pub-Sub" class="headerlink" title="Redis Pub/Sub"></a>Redis Pub/Sub</h5><p>使用Redis的订阅发布模式，生产者可以将消息推送给某个channel，多个消费者可以订阅该频道，从而同时得到消息。<br />用的命令是：</p><ul><li>Publish 推送</li><li>SubScribe 订阅</li><li>PSubScribe 订阅某个表达式匹配的多个频道</li></ul><p>这样就可以实现多生产、多消费。也很灵活，一条消息可以发送给一个消费者，也可以发送给多个消费者。<br />缺点：</p><ol><li>Pub/Sub是一次性的，Redis不会保存发过的消息，没人收消息就会丢失。</li><li>因为上一点，无法做到持久化</li><li>客户端虽然可能会缓存收到的消息，但是也有上限，可能还是会丢失消息</li></ol><p><strong>不建议使用</strong><br /><strong> </strong></p><h5 id="Redis-Stream"><a href="#Redis-Stream" class="headerlink" title="Redis Stream"></a>Redis Stream</h5><p>redis 5.0 新推出的数据结构，可以实现单向的消息队列。<br />核心命令：</p><ul><li>XADD：添加消息/创建队列，消息会自动持久化，不用担心丢失，每隔消息都有唯一的全局唯一id</li><li>XRead：消息可回溯，支持多消费者读，可以指定消息id开始读，支持阻塞读最新消息，有漏读风险。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686735365106-bf4c07a6-f9ba-45c1-a20d-f9c99fb09f5a.png#averageHue=%23122a3d&amp;clientId=u1469bab5-7119-4&amp;from=paste&amp;height=192&amp;id=uffd1de90&amp;originHeight=211&amp;originWidth=1024&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=234565&amp;status=done&amp;style=none&amp;taskId=u6408a1e3-4094-42cc-a3b3-15e57f9b323&amp;title=&amp;width=930.9090707321802" alt="4_QC8`J7$%BO_57N$%CO)]8.png"><br />只有这两个命令不够，因为目前只支持阻塞读最新消息，假设处理消息过程又来几条消息，可能出现漏读情况。<br />为解决上述问题，可以使用Stream的以下特性：</p><ul><li>消费组：同组的多个消费者可以竞争消费，从而提升消费能力。对应命令为XGROUP、XREADGROUP</li><li>消费标识：自动记录消费进度，支持从上次未消费的地方开始接着消费，保证每个消息都能按顺序消费</li><li>消息确认机制：默认消费的消息未pending状态，会放到每个消费者的pending list中，只有消息由消费者确认(ACK)，才会从pending list移除，这样如果消费业务处理异常，可以从pending list开头依次读取未确认的消息，重试处理。（也需要避免无线重试，实在处理不成功，就强制ACK+业务记录日志）</li></ul><p>整个消费流程：<br /><img src="https://cdn.nlark.com/yuque/0/2023/png/33551426/1686735706416-d04cc86a-5092-4121-b21a-6e39008aa0e4.png#averageHue=%23eeeff3&amp;clientId=u1469bab5-7119-4&amp;from=paste&amp;height=487&amp;id=u987986b6&amp;originHeight=536&amp;originWidth=591&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;size=125950&amp;status=done&amp;style=none&amp;taskId=u5340fbbd-5fe4-4a21-b424-8daf60da509&amp;title=&amp;width=537.2727156276547" alt="0)ZOX05G0VUWU~Q~ZRA~SQU.png"><br />在java中操作Redis Strean 两种方法：</p><ol><li>调用Lua脚本</li><li>使用Redis Template 的 opsForStrean（）</li></ol><p>方案对比：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662187826716-5ff99aa2-fb34-49b8-9795-acb6f925a4b1.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f9f7f4&amp;from=url&amp;id=BvmOl&amp;originHeight=331&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>注意，redis 虽然可以实现较为完备的消息队列，但还是不如专业的消息队列Kafka，RabbitMQ，RocketMQ专业，比如持久化能力差，不支持生产确认，顺序消费性等。</p><h5 id="抢购优惠卷业务终极版"><a href="#抢购优惠卷业务终极版" class="headerlink" title="抢购优惠卷业务终极版"></a>抢购优惠卷业务终极版</h5><ol><li><p>redis创建消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接redis服务器</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment">// 认证</span></span><br><span class="line">redis-cli -h &lt;<span class="number">124.221</span><span class="number">.169</span><span class="number">.181</span>&gt; -p &lt;<span class="number">3306</span>&gt;</span><br><span class="line"><span class="comment">// 创建消息队列</span></span><br><span class="line">XGROUP CREATE Stream.orders orders <span class="number">0</span> MKSTREAM</span><br><span class="line"><span class="comment">// 查看消息队列信息</span></span><br><span class="line">XINFO STREAM Stream.orders</span><br></pre></td></tr></table></figure></li><li><p>lua脚本，将判断库存，判断用户下单等操作封装到lua脚本中，如果用户没有下单就在redis中扣库存，把订单消息存储到redis中，同时将这个消息发送到队列中，队列采用的是Stream模式，然后返回</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.参数列表</span></span><br><span class="line"><span class="comment">-- 1.1.优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 1.2.用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">-- 1.3.订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.数据key</span></span><br><span class="line"><span class="comment">-- 2.1.库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">-- 2.2.订单key6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3.脚本业务</span></span><br><span class="line"><span class="comment">-- 3.1.判断库存是否充足 get stockKey</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.2.库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 3.3.存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 3.4.扣库存 incrby stockKey -1</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>, stockKey, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 3.5.下单（保存用户）sadd orderKey userId</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span></span><br><span class="line">redis.call(<span class="string">&#x27;xadd&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>在java逻辑代码中，首先进入seckillVoucher接口，然后先执行lua脚本，对于返回结果判断，无购买资格则返回，有购买资格则获取代理对象后返回，通过在类加载完成后初始化的异步线程中，获取消息失败则循环监听消息队列，获取消息队列中的消息后，解析其中的订单信息，然后进行下单，下单成功后返回通过ack消息确认机制进行确认后，将订单消息从队列中删除，抢购失败，则打印日志并获取消息队列中的失败的消息，再次进行消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;seckill.lua&quot;</span>));</span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    创建阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;TbVoucherOrder&gt; blockingDeque = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化代理对象</span></span><br><span class="line">    <span class="keyword">private</span> TbVoucherOrderService proxy;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  提供了一系列方法来管理线程池和执行任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_SERVICE</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">VoucherOrderHander</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    获取消息队列中的消息</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream()</span><br><span class="line">                            .read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>), StreamReadOptions.empty()</span><br><span class="line">                                    .count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)), StreamOffset.create(queueName, ReadOffset.lastConsumed()));</span><br><span class="line"><span class="comment">//                    判断是否获取成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    解析消息 中的订单信息</span></span><br><span class="line">                    Map&lt;Object, Object&gt; value = list.get(<span class="number">0</span>).getValue();</span><br><span class="line">                    <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//                    如果成功 可以下单</span></span><br><span class="line">                    handleVoucherOrder(tbVoucherOrder);</span><br><span class="line"><span class="comment">//                    ack确认</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, list.get(<span class="number">0</span>).getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;异步抢购失败:&quot;</span> + e);</span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    获取消息队列中的消息</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream()</span><br><span class="line">                            .read(Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>), StreamReadOptions.empty()</span><br><span class="line">                                    .count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)), StreamOffset.create(queueName, ReadOffset.from(<span class="string">&quot;0&quot;</span>)));</span><br><span class="line"><span class="comment">//                    判断是否获取成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//                       失败说明pendinglist中没有消息，直接结束</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    解析消息 中的订单信息</span></span><br><span class="line">                    Map&lt;Object, Object&gt; value = list.get(<span class="number">0</span>).getValue();</span><br><span class="line">                    <span class="type">TbVoucherOrder</span> <span class="variable">tbVoucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="keyword">new</span> <span class="title class_">TbVoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//                    如果成功 可以下单</span></span><br><span class="line">                    handleVoucherOrder(tbVoucherOrder);</span><br><span class="line"><span class="comment">//                    ack确认</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, list.get(<span class="number">0</span>).getId());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;异步抢购失败:&quot;</span> + e);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                        ex.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠卷秒杀优化</span></span><br><span class="line"><span class="comment">     * 串行改并行：原本由一个线程的操作改为由两个或多个线程同时执行</span></span><br><span class="line"><span class="comment">     * 比如一个线程负责判断秒杀资格，一个线程负责减库存+创建订单（写操作）</span></span><br><span class="line"><span class="comment">     * 同步改异步：判断完秒杀资格后，就可以返回订单id给前端，其余的写操作可以异步执行。</span></span><br><span class="line"><span class="comment">     * 提高判断秒杀资格的性能：读DB改为读redis</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">long</span> <span class="variable">order</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line"><span class="comment">//        1、执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(), voucherId.toString(), userId.toString(), String.valueOf(order));</span><br><span class="line"><span class="comment">//        2、判断结果为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//        2.1 不为0，代表没有购买资格</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(value == <span class="number">1</span> ? <span class="string">&quot;库存不足&quot;</span> : <span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        2.2 为0 ，有资格，把下单信息保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        2. 保存到阻塞队列</span></span><br><span class="line"><span class="comment">//        获取代理对象</span></span><br><span class="line">        proxy = (TbVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">        <span class="keyword">return</span> Result.ok(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类加载完成后执行初始化任务</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_SERVICE.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHander</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h5><p>流程：</p><ol><li>判断用户是否已经点赞</li><li>更新DB点赞和点赞关系</li></ol><p>如果全部数据库操作，性能不高，可以把判断是否已经点赞、维护点赞关系的逻辑移至redis，只用更新数据库点赞即可</p><p>可以使用redis set结构，比如key=like:[帖子id],value为去重的已点赞用户id列表，就可以判断是否已经点赞了。</p><blockquote><p>点赞功能的实现可能存在同时点赞的情况，可以参考秒杀优化的逻辑，使用分布式锁、或者lua脚本解决、操作DB的部分可以使用异步、队列之类的机制。</p></blockquote><p>使用分布式锁解决：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">// 1.获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">// 2.判断当前登录用户是否已经点赞</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">       <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;lock:like:&quot;</span> + userId);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (lock.tryLock(<span class="number">0</span>, -<span class="number">1</span>, TimeUnit.MICROSECONDS)) &#123;</span><br><span class="line">               <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">               <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 3.如果未点赞，可以点赞</span></span><br><span class="line">                   <span class="comment">// 3.1.数据库点赞数 + 1</span></span><br><span class="line">                   <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">                   <span class="comment">// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class="line">                   <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                       stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 4.如果已点赞，取消点赞</span></span><br><span class="line">                   <span class="comment">// 4.1.数据库点赞数 -1</span></span><br><span class="line">                   <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">                   <span class="comment">// 4.2.把用户从Redis的set集合移除</span></span><br><span class="line">                   <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                       stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> Result.ok();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (lock.isHeldByCurrentThread()) &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Result.fail(<span class="string">&quot;点赞功能繁忙,请稍后重试!&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h5 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h5><p>示例需求:展示最先给某个帖子点赞的TopN用户<br />实现:使用Redis SortedSet(自动按score排序的数据结构)，把用户点赞时间作为score即可，使用ZRange范围查询TopN。</p><p>点赞排行榜存在的坑：</p><ol><li>将点赞用户按时间戳插入redis的zset中时，存在sorce分数高的排在上面，分数低的自动往后移，这里查找了网上关于zset的教程，查询排名时以升序排序（ score 越大排名越靠后），这里是因为quickredis自动排序了（踩了很久的坑），</li><li>从redis的Zset集合中拿到返回值后，原本的顺序就是点赞的顺序，但是在mapper文件中使用in以及 foreach标签时，会自动对集合中的数据进行排序后，再进行查询，就会导致排行榜点赞顺序与我们的预期不符，在mapper中写sql时通过order by find_in_set(id, #{idStr})实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">bloglikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> BLOG_LIKED_KEY + id;</span><br><span class="line">      Set&lt;String&gt; range = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> (!Optional.ofNullable(range).isPresent())&#123;</span><br><span class="line">          <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;Integer&gt; ids = range.stream().map(Integer::valueOf).collect(Collectors.toList());</span><br><span class="line">      List&lt;UserDTO&gt; userDTOS = userMapper.getTopfiveByIds(ids).stream()</span><br><span class="line">.map(tbUser -&gt; BeanUtil.copyProperties(tbUser, UserDTO.class))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">      <span class="keyword">return</span> Result.ok(userDTOS);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getTopfiveByIds&quot; resultType<span class="operator">=</span>&quot;com.xiaozhang.entity.domain.TbUser&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">select</span> <span class="operator">&lt;</span>include refid<span class="operator">=</span>&quot;Base_Column_List&quot;<span class="operator">&gt;</span><span class="operator">&lt;</span><span class="operator">/</span>include<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="keyword">in</span></span><br><span class="line">    <span class="operator">&lt;</span>foreach collection<span class="operator">=</span>&quot;ids&quot; item<span class="operator">=</span>&quot;id&quot; <span class="keyword">open</span><span class="operator">=</span>&quot;(&quot; separator<span class="operator">=</span>&quot;,&quot; <span class="keyword">close</span><span class="operator">=</span>&quot;)&quot;<span class="operator">&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> find_in_set(id, #&#123;idStr&#125;)</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h5 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a>共同关注</h5><p>需求:计算两个人共同关注的所有用户思路:本质就是求两个用户关注集合的交集<br />实现:使用Redis Set数据结构，每个key保存1个用户的关注集合(取关时从集合中移除对应用户)，最后对2个用户对应的set进行intersect取交集操作即可</p><h4 id="Feed流关注推送"><a href="#Feed流关注推送" class="headerlink" title="Feed流关注推送"></a>Feed流关注推送</h4><p>up主发布新内容，系统给粉丝发送消息</p><p>何为feed流？<br />feed流是指无线下拉刷新的内容列表，给用户沉浸式的体验</p><p>两种模式：</p><ol><li>Timeline 时间线模式：所有内容按时间顺序展示，比如朋友圈</li><li>智能排序模式：根据一定算法推荐用户感兴趣的内容，比如现在的视频网站</li></ol><p>解决问题：如何将关注用户的新内容展示到Feed流中？</p><h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><p>1）拉模式：用户上线打开Feed流时，再获取up推送的内容（主动拉取，比较耗时）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199526960-ad74c98d-869d-454a-88be-06f0bbf6e236.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fcfcfc&amp;from=url&amp;id=N4ZjD&amp;originHeight=381&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />2）推模式：up主发布内容时，直接把内容推送到所有粉丝内容列表里，（粉丝多的大up主写入时很占资源）<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199531728-ab03c11f-4c34-4758-85c0-d97db0eb17a1.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fdfdfd&amp;from=url&amp;id=IfDjO&amp;originHeight=473&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>3）推拉结合<br />推模式：粉丝少的up、推送给活跃用户<br />拉模式：粉丝多的up&amp;&amp;推给非活跃用户<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199536976-2a8e6360-4eb0-45b4-8d5d-ac35579b2271.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23fbfbfb&amp;from=url&amp;id=pBlrT&amp;originHeight=408&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>各种方式的优缺点：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662199523680-8bbeeea1-d638-420b-be70-4c7aa72b6e3f.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0#averageHue=%23f8f5f3&amp;from=url&amp;id=zTLoY&amp;originHeight=330&amp;originWidth=750&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>一般系统的用户量级小的时候采用推模式，系统用户量大的时候采用推拉结合模式。</p><h5 id="推模式Redis实现"><a href="#推模式Redis实现" class="headerlink" title="推模式Redis实现"></a>推模式Redis实现</h5><p>因为推送是按照时间排序的，所有可以使用sortedSet数据结构来保存，每一个key表示一个用户的收件箱，value为推送id，sorce为推送时间戳。</p><p>分页问题：<br />每条消息都会动态变化，导致数据重复查询，如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662258685043-daec4891-e0b5-4034-b784-e41dd23aaef6.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f9f8f8&amp;from=url&amp;id=F6TOy&amp;originHeight=486&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />因此，可以使用滚动分页，记录每次当前时间戳的下一条开始查询，如图：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662258695058-1cf81cf7-601e-4aeb-8941-bb97f89cc444.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f9f9f8&amp;from=url&amp;id=fIn1U&amp;originHeight=497&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""><br />可以使用sortedset的zrevrangeBysorce 命令实现，每次查询指定时间戳范围（0，当前最大时间戳）的指定条数的数据。示例命令：<br />ZRevRangeByScore key 0 maxTimeStamp offset limit。<br />注意有个问题，可能出现相同时间戳的数据，因此第一次查询时 offset 为 0（从第一条开始查），之后每次查询，offset 为上一页中时间戳最小值的数量，保证不查出重复数据。<br />比如 score 列表为：5, 4, 4, 3, 2, 1。每页 3 条。<br />第一次查询 ZRevRangeByScore key 0 9999999 0 3 查出 5、4、4，最小值 4 重复 2 次，即下一次的最大值为 4、offset 为 2。<br />所以第二次查询为 ZRevRangeByScore key 0 4 2 3 查出 3、2、1</p><h4 id="GEO-地理坐标计算"><a href="#GEO-地理坐标计算" class="headerlink" title="GEO 地理坐标计算"></a><br />GEO 地理坐标计算</h4><p><br />P88 - P90<br />Redis 支持 GEO 数据结构，可用于存储多个地理坐标、计算坐标间的距离，计算某坐标半径范围内的其他点和距离（实现附近的人）。<br />GEO 底层是 SortedSet 类型<br />支持以下命令：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662259856441-adec18e0-f19f-4839-8138-0e207f66fdaa.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f1f1f1&amp;from=url&amp;id=Ag5GV&amp;originHeight=391&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="查附近"><a href="#查附近" class="headerlink" title="查附近"></a>查附近</h5><p><br />需求：查询你附近所有的小姐姐，以及每个小姐姐和你的距离，并且按照距离由近到远排序<br />实现：<br />1使用 GEOADD 添加所有小姐姐的 id 和位置到一个 key 中<br />2使用 GEOSEARCH 查询以你当前坐标为中心、指定距离内的所有小姐姐，默认返回的就是由近及远的 SortedSet（value 为 id、score 为和你的距离）<br />小技巧：<br />如果我们要根据分类来计算同组内的距离及排名，可以每个类别一个独立的 key，如图：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662261432855-a5b54817-a81d-42a7-9864-7d3a7a52d6de.png?x-oss-process=image%2Fresize%2Cw_533%2Climit_0#averageHue=%23b8beb4&amp;from=url&amp;id=lwz8E&amp;originHeight=280&amp;originWidth=533&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h4 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a><br /><br />BitMap</h4><p><br />多个二进制位组成的数据结构，每个二进制位对应一个业务的两种互斥状态。比如：10010011。<br />BitMap 的优点是可以用最小的代码（1 个 bit）来保存业务含义，从而大幅节省空间、实现高效运算等。比如可以把某个二进制位从 0 改为 1。<br />底层是 string 类型，以字节为单位存储，所以 bit 的长度为 8 的倍数</p><p>命令：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662263399913-82c17736-6b4f-4bbc-910f-392b016a86ce.png?x-oss-process=image%2Fresize%2Cw_937%2Climit_0#averageHue=%23f2f2f2&amp;from=url&amp;id=eZvuB&amp;originHeight=428&amp;originWidth=937&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="签到功能"><a href="#签到功能" class="headerlink" title="签到功能"></a><br /><br />签到功能</h5><p><br />这是 BitMap 的一个经典应用场景。<br />如果使用传统数据库来记录用户某日签到状态，每次签到对应 1 行数据，那么将占用几百 byte 的空间。用户量大了后，占用的内存不可估量。<br />而使用 BitMap，可以用每一个二进制位表示当天的签到状态，0 表示用户已签到、1 表示用户未签到，如下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662263817244-d2e78caf-38b9-490f-8b9b-756d4cdec63f.png#averageHue=%23faf9f9&amp;from=url&amp;id=erBjw&amp;originHeight=352&amp;originWidth=1442&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>只用 31 bit，就能表示某用户 1 个月的签到状态。<br />其原理就类似于签到卡，用户可以在一张签到卡上同时对多个不同的日期进行签到，从而避免了重复的用户签名、重复去写日期。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662264055714-e9977747-f48d-4e69-96b5-06189f31394e.png?x-oss-process=image%2Fresize%2Cw_225%2Climit_0#averageHue=%23dbd9aa&amp;from=url&amp;id=dUM08&amp;originHeight=408&amp;originWidth=225&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h5 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a><br /><br />基本实现</h5><h5 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h5><p><br />用 BITSET 设置某一天对应位置的 bit 值即可，需要查询签到状态时可以用 BITFIELD GET 取出整个 BitMap 的十进制值，再用 位运算 将十进制值转为业务需要的格式。</p><h5 id="统计连续签到天数"><a href="#统计连续签到天数" class="headerlink" title="统计连续签到天数"></a><br />统计连续签到天数</h5><p><br />可以先用 BITFIELD GET 取出整个 BitMap 的十进制值。然后循环右移，依次用 1 去和 BitMap 的最后一位进行 <strong>与运算</strong>，即可得知当前位数是否为 1（已签到），配合计数器完成连续 1 的统计。<br />示例代码如下：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662265366088-f364fe64-cc67-427b-a9d9-7e216c6c7bc8.png?x-oss-process=image%2Fresize%2Cw_790%2Climit_0#averageHue=%23f4f8f1&amp;from=url&amp;id=ifTpB&amp;originHeight=346&amp;originWidth=790&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>注意，循环右移一定要用 &gt;&gt;&gt;（无符号右移，高位补 0），否则可能会死循环。</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><br />HyperLogLog</h4><p><br />HyperLogLog（HLL）是 Redis 的高级数据结构，使用概率学算法实现，可以用极低的内存实现不重复元素个数的统计。<br />用法和集合类似，插入元素、求不重复元素个数、合并多个 HLL 等：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/398476/1662270538754-0a2ec2e5-c32c-42cc-9cfc-d5650fbc7c0f.png?x-oss-process=image%2Fresize%2Cw_840%2Climit_0#averageHue=%23102136&amp;from=url&amp;id=MHeHm&amp;originHeight=281&amp;originWidth=840&amp;originalType=binary&amp;ratio=1.100000023841858&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>优点：占用内存极低，不会超过 16 Kb<br />缺点：基于概率统计，存在 &lt; 0.81% 的误差<br />因此，它很适合用于 UV、PV 等数据量大、精度要求不高的统计。</p><h5 id="UV-PV-统计"><a href="#UV-PV-统计" class="headerlink" title="UV / PV 统计"></a><br />UV / PV 统计</h5><p><br />只需要把用户 id 用 PFADD 添加到 HLL 中，用 PFCOUNT 求值即可；还可以用 PFMERGE 合并多天的统计，来估算整月的 UV。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql笔记</title>
      <link href="/2021/09/24/Mysql/"/>
      <url>/2021/09/24/Mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="展示所有数据库"><a href="#展示所有数据库" class="headerlink" title="展示所有数据库"></a>展示所有数据库</h2><p>SHOW DATABASES;</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>CREATE  DATABASE if not EXISTS 名称;</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>drop DATABASE if exists 名称;</p><h2 id="修改数据库编码"><a href="#修改数据库编码" class="headerlink" title="修改数据库编码"></a>修改数据库编码</h2><p>ALTER DATABASE test CHARACTER set utf8</p><h2 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h2><p>use +  数据库名称</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>— 创建表<br>create table if not EXISTS Student(<br>    sid int,<br>    name VARCHAR(20),<br>    gender VARCHAR(20),<br>    age int,<br>    birth date,<br>    address VARCHAR(20),<br>    sorce double<br>);</p><h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>drop table 表名称</p><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>tinyint unsigned</p><p>tinyint 表示小整数值类型 （有符号   -128到127）无符号（0-255）</p><p>unsigned 表示无符号</p><h2 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h2><p>date      准确到天</p><p>datetime     准确到当前时间</p><p>timestamp     准确到当前时区秒</p><h2 id="查看数据库中的表"><a href="#查看数据库中的表" class="headerlink" title="查看数据库中的表"></a>查看数据库中的表</h2><p>—  查看当前数据库所有的表<br>show tables;<br>— 查看指定表的创建语句<br>show create table student;</p><p>结果如下：</p><p>CREATE TABLE <code>student</code> (<br>  <code>sid</code> int(11) DEFAULT NULL,<br>  <code>name</code> varchar(20) DEFAULT NULL,<br>  <code>gender</code> varchar(20) DEFAULT NULL,<br>  <code>age</code> int(11) DEFAULT NULL,<br>  <code>birth</code> date DEFAULT NULL,<br>  <code>address</code> varchar(20) DEFAULT NULL,<br>  <code>sorce</code> double DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8</p><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><p>desc 表名称;</p><h2 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h2><p>1、为指定的列添加数据（括号里面一一对应）</p><p>insert into student (sid,name,age) values (1,’zxq’,16);</p><p>2、为所有列添加数据</p><p>insert into student values (1,’sss’,’85’,25,’2002-06-09’,’河南省济源市’,85.5);</p><p>添加数据时可以一次添加多个数据</p><p>insert into student (sid,name,age) values (1,’zxq’,16)，</p><p>(1,’zxq’,16)，(1,’zxq’,16)，(1,’zxq’,16);</p><h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>— 添加限制修改<br>update student set name=’cgx’ where name=’sss’;<br>— 所有数据修改<br>update student set name=’大王的’;</p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>— 限制 删除<br>delete from student where age=16;<br>— 删除表中所有数据<br>delete from student;</p><p>truncate student;</p><p>delete与truncate 原理不同，delete时单纯的删除表中数据，truncate是删除所有数据再创建一个新表</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>1、select <em>from student where sid = 1;<br>select </em>from student;</p><p>2、查询某一列</p><p>select 列 from 表名</p><p>3、别名查询，使用关键字as（as可以省略）</p><p>select * from 表名 as 别名</p><p>select * from 表名   别名  </p><p>别名在多表查询会用到</p><p>4、列别名</p><p>select  name as ‘名字’ , salary as ‘价钱’ from employee</p><p>5、去掉重复值查询</p><p>distinct 关键字查询</p><p>select distinct name from employee</p><p>多条一摸一样的数据会进行剔除查询</p><p>select distinct * from employee</p><p>6、查询结果表达式</p><p>select name ‘名字’,salary+10 new_price from employee</p><h2 id="设置主键（唯一不为空）"><a href="#设置主键（唯一不为空）" class="headerlink" title="设置主键（唯一不为空）"></a>设置主键（唯一不为空）</h2><p>create table if not exists employee(<br>    id int primary key,   设置主键<br>    name varchar(10),<br>    gender varchar(10),<br>    salary double,<br>— constraint pk1 primary key(id)  设置主键 constraint pk1可以省略<br>);</p><h2 id="添加联合主键"><a href="#添加联合主键" class="headerlink" title="添加联合主键"></a>添加联合主键</h2><p> primary key(字段1，字段2) </p><p>联合主的各列都不能为空！！！</p><p>alter table employee add primary key(id,name);</p><h2 id="删除（联合）主键"><a href="#删除（联合）主键" class="headerlink" title="删除（联合）主键"></a>删除（联合）主键</h2><p>alter table 表名 drop primary key;</p><h2 id="主键自动增长"><a href="#主键自动增长" class="headerlink" title="主键自动增长"></a>主键自动增长</h2><p>id int primary key auto_increment</p><p>从一开始增长</p><h2 id="自增长约束初始化"><a href="#自增长约束初始化" class="headerlink" title="自增长约束初始化"></a>自增长约束初始化</h2><p>两种方式，一种是在创建表时候添加</p><p>create table if not exists employee(<br>    id int primary key auto_increment,<br>    name varchar(10),<br>    gender varchar(10),<br>    salary double<br>—     constraint pk1 primary(id)  设置主键 constraint pk1可以省略<br>)auto_increment=100;</p><p>另一种是创建完表之后添加</p><p>alter table employee auto_increment=200;</p><h2 id="自增长下删除数据"><a href="#自增长下删除数据" class="headerlink" title="自增长下删除数据"></a>自增长下删除数据</h2><p><strong>delete 会从自动增长的断点开始，truncate 是删除表后重新从1开始，无论主键默认值是什么</strong></p><h2 id="添加非空约束"><a href="#添加非空约束" class="headerlink" title="添加非空约束"></a>添加非空约束</h2><p>两种方式：</p><p>1、在创建表时候在字段后面添加not null</p><p>2、在创建表后设置，即</p><p>alter table employee modify name varchar(10) not null;</p><h2 id="删除非空约束"><a href="#删除非空约束" class="headerlink" title="删除非空约束"></a>删除非空约束</h2><p>alter table employee modify name varchar(10) ；</p><p>即去掉后面的not null</p><h2 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h2><p>1、在创建表时候在字段后面添加unique</p><p>2、在创建表后添加</p><p>alter table employee add constraint 约束名（自己起）unique(gender);</p><p>删除唯一约束：</p><p>alter table employee drop index 约束名;</p><h2 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h2><p>— 添加默认值<br>alter table employee modify salary double default 18;</p><p>注意添加数据指明</p><p>insert into employee(id,name,gender) values(3,’ss’,’dd’);</p><h2 id="条件查找"><a href="#条件查找" class="headerlink" title="条件查找"></a>条件查找</h2><p>1、不等于</p><p>！=    或者    &lt;&gt;  或者   NOT （查询条件）</p><p>2、两者之间</p><p>between  and  或者  and  或者  &amp;&amp;</p><p>3、二者其一</p><p>in (200,800)  或者  条件  or  条件   或者   条件||条件</p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>1、select max(列名)  from  表名     </p><!--最大值--><p>2、select min(列名)  from  表名     </p><!--最小值--><p>3、select count(*)  from  表名     </p><!--求数据个数--><p>4、select sum(列名)  from  表名     </p><!--最和--><p>5、select avg(列名)  from  表名     </p><!--最平均值--><p>select max(age) from student;</p><p>select sum(sorce) from student;</p><p>select avg(sorce) from student;</p><p>— 根据性别分组去求平均值<br>select gender,avg(sorce),count(<em>) from student GROUP BY gender;<br>— 加上约束<br>select gender,avg(sorce),count(</em>) from student where sorce &lt;&gt;99.8 GROUP BY gender;<br>— having用法<br>select gender,avg(sorce),count(<em>) from student where sorce &lt;&gt;99.8 group by gender having count(</em>)=1;</p><p>执行顺序：  where&gt;聚合函数&gt; having</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>— 分页查询<br>select * from student limit 0,3;</p><p>下标从0开始，每页开头下标计算公式为  ：（当前页码-1）*每页展示内容数量</p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>— 模糊查询<br>select * from student where address like ‘%济源%’;</p><h2 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a>添加外键</h2><p>ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;外键名&gt; FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);</p><h2 id="删除外键"><a href="#删除外键" class="headerlink" title="删除外键"></a>删除外键</h2><p>ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>内查询，即两个表的交集</p><p>外查询</p><h2 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h2><p>显式内连接：</p><p>select * from 表名 inner join 表名 on 表名.列名=表名.列名</p><p>隐式内连接：</p><p>select *from 表名 ，表名 where 表名.列名=表名.列名</p><p>起别名：</p><p>select    新命名.列名，新命名.列名  from 表名  新命名，表名 新命名 where 新命名.列名=新命名.列名</p><p>左外连接：</p><p>select *from 表名 left join 表名 on 表名.列名=表名.列名</p><p>右外连接：</p><p>select *from 表名 right join 表名 on 表名.列名=表名.列名</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>即嵌套查询，根据查询结果不同，作用也不同。</p><p>单行单列：作为条件值，使用=！=&gt;&lt;等进行条件判断</p><p>select 字段列表 from 表 where 字段名=（子查询）</p><p>多行单列：作为条件值，使用in等关键字进行判断</p><p>select 字段列表 from 表 where 字段名 in （子查询）</p><p>多行多列：作为虚拟表</p><p>select 字段列表 from （子查询） where 条件</p><h2 id="UNION-和-UNION-ALL-操作符"><a href="#UNION-和-UNION-ALL-操作符" class="headerlink" title="UNION 和 UNION ALL 操作符"></a>UNION 和 UNION ALL 操作符</h2><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p><p>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p><p>UNION会将数据集合中数据按照第一个列升序排列，UNION ALL不会排序</p><p>并集编写时的注意点</p><p>1).前后数据集合的列的个数和数据类型应一致<br>2).UNION 会按照第一个列升序排列<br>3).最终的数据结果显示以第一个数据集合中的列的名称显示</p><h2 id="SQL中if函数使用技巧"><a href="#SQL中if函数使用技巧" class="headerlink" title="SQL中if函数使用技巧"></a>SQL中if函数使用技巧</h2><p>语法：IF(expr1,expr2,expr3)</p><p>其中，expr1是判断条件，expr2和expr3是符合expr1的自定义的返回结果。</p><p>用处：当从数据库中查询出来的结果需要转换成中文或是其他自定义的格式显示在网页上的时候，可以直接在sql中处理</p><h2 id="SQL中EXTRACT-函数"><a href="#SQL中EXTRACT-函数" class="headerlink" title="SQL中EXTRACT() 函数"></a>SQL中EXTRACT() 函数</h2><p><a href="http://www.w3school.com.cn/sql/func_extract.asp"><strong>EXTRACT()</strong>(</a>“提取”的意思) 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 SELECT EXTRACT(YEAR FROM OrderDate) AS OrderYear,</span><br><span class="line">2 EXTRACT(MONTH FROM OrderDate) AS OrderMonth,</span><br><span class="line">3 EXTRACT(DAY FROM OrderDate) AS OrderDay</span><br><span class="line">4 FROM Orders</span><br></pre></td></tr></table></figure><h2 id="SQL-ORDER-BY-子句"><a href="#SQL-ORDER-BY-子句" class="headerlink" title="SQL ORDER BY 子句"></a>SQL ORDER BY 子句</h2><h3 id="ORDER-BY-语句"><a href="#ORDER-BY-语句" class="headerlink" title="ORDER BY 语句"></a>ORDER BY 语句</h3><p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p><p>ORDER BY 语句默认按照升序对记录进行排序。</p><p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p><h2 id="SQL-GROUP-BY-语句"><a href="#SQL-GROUP-BY-语句" class="headerlink" title="SQL GROUP BY 语句"></a>SQL GROUP BY 语句</h2><p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p><h2 id="sql-Case-语句"><a href="#sql-Case-语句" class="headerlink" title="sql Case 语句"></a><strong>sql Case</strong> 语句</h2><p><a href="https://blog.csdn.net/m0_53222768/article/details/120101414">https://blog.csdn.net/m0_53222768/article/details/120101414</a></p><p>1.简单Case函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CASE sex</span><br><span class="line">     WHEN &#x27;1&#x27; THEN &#x27;男&#x27;</span><br><span class="line">     WHEN &#x27;2&#x27; THEN &#x27;女&#x27; ELSE &#x27;其他&#x27; END</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>2.Case搜索函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN sex = &#x27;1&#x27; THEN &#x27;男&#x27;</span><br><span class="line">     WHEN sex = &#x27;2&#x27; THEN &#x27;女&#x27;ELSE &#x27;其他&#x27; END</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>3.简单case函数 VS case搜索函数</p><ul><li>这两种方式，可以实现相同的功能。简单Case函数的写法相对比较简洁，但是和Case搜索函数相比，功能方面会有些限制，比如写判断式。</li><li>还有一个需要注意的问题，Case函数只返回第一个符合条件的值，剩下的Case部分将会被自动忽略。</li><li>–比如说，下面这段SQL，你永远无法得到”第二类”这个结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">WHEN col_1 IN ( &#x27;a&#x27;, &#x27;b&#x27;) THEN &#x27;第一类&#x27;</span><br><span class="line">WHEN col_1 IN (&#x27;a&#x27;)  THEN &#x27;第二类&#x27;</span><br><span class="line">ELSE&#x27;其他&#x27; END</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>4.使用Case函数都能做些什么事。</p><p>4.1：已知数据按照另外一种方式进行分组、分析。</p><ul><li>有如下数据:(为了看得更清楚，我并没有使用国家代码，而是直接用国家名作为Primary Key)<br><img src="https://img-blog.csdnimg.cn/2190129ac3ba49629d627c6ab4009f45.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA6LSk5LiN56m_5bCP6Z6L,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></li><li>根据这个国家人口数据，统计亚洲和北美洲的人口数量。应该得到下面这个结果。<br><img src="https://img-blog.csdnimg.cn/8965df41ee0048e9a08a9905729fd9ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA6LSk5LiN56m_5bCP6Z6L,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></li><li>想要解决这个问题，你会怎么做？生成一个带有洲Code的View，是一个解决方法，但是这样很难动态的改变统计的方式。</li><li>如果使用Case函数，SQL代码如下:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT   SUM(population),</span><br><span class="line">  CASE country</span><br><span class="line">       WHEN &#x27;中国&#x27;     THEN &#x27;亚洲&#x27;</span><br><span class="line">       WHEN &#x27;印度&#x27;     THEN &#x27;亚洲&#x27;</span><br><span class="line">       WHEN &#x27;日本&#x27;     THEN &#x27;亚洲&#x27;</span><br><span class="line">       WHEN &#x27;美国&#x27;     THEN &#x27;北美洲&#x27;</span><br><span class="line">       WHEN &#x27;加拿大&#x27;  THEN &#x27;北美洲&#x27;</span><br><span class="line">       WHEN &#x27;墨西哥&#x27;  THEN &#x27;北美洲&#x27; ELSE &#x27;其他&#x27; END</span><br><span class="line">FROM     Table_A</span><br><span class="line">GROUP BY CASE country</span><br><span class="line">        WHEN &#x27;中国&#x27;     THEN &#x27;亚洲&#x27;</span><br><span class="line">       WHEN &#x27;印度&#x27;     THEN &#x27;亚洲&#x27;</span><br><span class="line">       WHEN &#x27;日本&#x27;     THEN &#x27;亚洲&#x27;</span><br><span class="line">       WHEN &#x27;美国&#x27;     THEN &#x27;北美洲&#x27;</span><br><span class="line">       WHEN &#x27;加拿大&#x27;  THEN &#x27;北美洲&#x27;</span><br><span class="line">       WHEN &#x27;墨西哥&#x27;  THEN &#x27;北美洲&#x27; ELSE &#x27;其他&#x27; END</span><br><span class="line">12345678910111213141516</span><br></pre></td></tr></table></figure><ul><li>同样的，我们也可用来判断工资的等级，并统计每一等级的人数。SQL代码如下；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT   CASE WHEN salary &lt;= 500 THEN &#x27;1&#x27;    </span><br><span class="line">              WHEN salary &gt; 500 AND salary &lt;= 600  THEN &#x27;2&#x27;         </span><br><span class="line">              WHEN salary &gt; 600 AND salary &lt;= 800  THEN &#x27;3&#x27;          </span><br><span class="line">              WHEN salary &gt; 800 AND salary &lt;= 1000 THEN &#x27;4&#x27;     </span><br><span class="line">         ELSE NULL END</span><br><span class="line">  salary_class,  COUNT(*)  FROM    Table_A  </span><br><span class="line">GROUP BY  CASE  WHEN salary &lt;= 500 THEN &#x27;1&#x27; </span><br><span class="line">              WHEN salary &gt; 500 AND salary &lt;= 600  THEN &#x27;2&#x27; </span><br><span class="line">              WHEN salary &gt; 600 AND salary &lt;= 800  THEN &#x27;3&#x27; </span><br><span class="line">              WHEN salary &gt; 800 AND salary &lt;= 1000 THEN &#x27;4&#x27;</span><br><span class="line">          ELSE NULL END;</span><br><span class="line">1234567891011</span><br></pre></td></tr></table></figure><p>4.2：用一个SQL语句完成不同条件的分组。</p><ul><li>有如下数据<br><img src="https://img-blog.csdnimg.cn/85628bb8017b41e8af97bc5751528a89.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA6LSk5LiN56m_5bCP6Z6L,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></li><li>按照国家和性别进行分组，得出结果如下<br><img src="https://img-blog.csdnimg.cn/f1926b5917574181bded7680431d0e9b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA6LSk5LiN56m_5bCP6Z6L,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></li><li>普通情况下，用UNION也可以实现用一条语句进行查询。但是那样增加消耗(两个Select部分)，而且SQL语句会比较长。</li><li>下面是一个是用Case函数来完成这个功能的例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT country,</span><br><span class="line">SUM( CASE WHEN sex = &#x27;1&#x27; THEN  population ELSE 0 END),  --男性人口</span><br><span class="line">        SUM( CASE WHEN sex = &#x27;2&#x27; THEN  population ELSE 0 END)   --女性人口</span><br><span class="line">FROM   Table_A  </span><br><span class="line">GROUP BY country;</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><ul><li>这样我们使用Select，完成对二维表的输出形式，充分显示了Case函数的强大。</li></ul><p>4.3：在Check中使用Case函数。</p><ul><li>在Check中使用Case函数在很多情况下都是非常不错的解决方法。可能有很多人根本就不用Check，那么我建议你在看过下面的例子之后也尝试一下在SQL中使用Check。</li><li>下面我们来举个例子<br>公司A，这个公司有个规定，女职员的工资必须高于1000块。如果用Check和Case来表现的话，如下所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT check_salary </span><br><span class="line">CHECK  ( </span><br><span class="line">CASE WHEN sex = &#x27;2&#x27;  THEN </span><br><span class="line">CASE WHEN salary &gt; 1000  THEN 1 </span><br><span class="line">ELSE 0 </span><br><span class="line">ENDELSE 1 END = 1 )</span><br><span class="line">123456</span><br></pre></td></tr></table></figure><ul><li>如果单纯使用Check，如下所示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT check_salary </span><br><span class="line">CHECK  ( sex = &#x27;2&#x27; AND salary &gt; 1000 )</span><br><span class="line">12</span><br></pre></td></tr></table></figure><ul><li>女职员的条件倒是符合了，男职员就无法输入了。</li></ul><p>例子：根据 book表中的库存量显示每本书的库存信息，当库存量大于100时，显示库京充民,否皿显示库存量低,并按照库存量顺序显示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Book.bookName,Publisher.PublisherName,stocks, <span class="keyword">case</span> <span class="keyword">when</span> Book.stocks<span class="operator">&gt;</span><span class="number">100</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">then</span> <span class="string">&#x27;库存充足&#x27;</span> <span class="keyword">when</span> Book.stocks<span class="operator">&lt;</span><span class="number">100</span> <span class="keyword">then</span> <span class="string">&#x27;库存不足&#x27;</span> <span class="keyword">end</span> <span class="keyword">from</span> Book,Publisher </span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> Book.PublisherID<span class="operator">=</span>Publisher.PublisherID</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识</title>
      <link href="/2021/09/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/09/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h1><h2 id="java转义字符"><a href="#java转义字符" class="headerlink" title="java转义字符"></a>java转义字符</h2><p>\t制表位;</p><p>\n换行；</p><p>\\:一个斜杠</p><p>\r：一个回车</p><h2 id="java常见错误"><a href="#java常见错误" class="headerlink" title="java常见错误"></a>java常见错误</h2><p><strong>1、找不到文件</strong></p><p><strong>2、文件名或类错误</strong></p><p><strong>3、缺少分号</strong></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>1、单行注释：//</p><p>2、多行注释：/<em>    </em>/</p><p>快捷注释：ctrl+shift+c</p><h2 id="文档注释："><a href="#文档注释：" class="headerlink" title="文档注释："></a><strong>文档注释：</strong></h2><p>/**</p><ul><li><p>@author 人名</p></li><li><p>@version 你好</p><p>**/</p></li></ul><h2 id="java代码规范"><a href="#java代码规范" class="headerlink" title="java代码规范"></a>java代码规范</h2><p>1、类，方法的注释，要以javadoc的方式来写</p><p>2、非javadoc的注释，往往是给代码的维护者看的</p><h2 id="DOS原理："><a href="#DOS原理：" class="headerlink" title="DOS原理："></a>DOS原理：</h2><p>控制台输入指令—&gt;发送给dos系统—&gt;</p><p>1、接受指令2、解析指令3、执行指令</p><p>—&gt;windows进行执行</p><h2 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h2><p>1、查看当前目录下有什么内容：dir    dir d:abc2\test200</p><p>2、cd ..\..\ABC\test200 或者  cd  D：abc2\test200</p><p>3、cd \  直接跳转到当前最起始目录</p><p>4、查看目录下所有内容  ：tree d:</p><p>5、清屏：cls</p><p>6、创建目录：md marry100</p><p>7、删除目录：rd marry100</p><p>8、创建文件：echo 填写内容 &gt; 文件名</p><p>9、删除文件：del 文件名</p><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>double num1=1.1f;<br>    float num=1.1f;<br>    double num2=.52;<br>    System.out.println(num2);<br>    System.out.println(num);</p><p><strong>*</strong>2.7近似相等与8.1/3</p><p>double c=2.7;<br>    double b=8.1/3;<br>    System.out.println(c);<br>    System.out.println(b);</p><p>结果：</p><p>2.7<br>2.6999999999999997</p><p>解决方案：</p><p>if(Math.abs(c-b)&lt;0.001)<br>        System.out.println(“两个数近似相等”);<br>    }</p><p>使用Math函数下的abs 进行判断两个数的差值</p><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>1、字符常量用单引号（’ ‘）括起来的单个字符，例如：char c1=’a‘</p><p>2、java中允许使用转义字符’\n’来将其后的字符转变为特殊字符性常量，例如： char c3=’\n’;//‘\n’表示换行符</p><p>3、char的本质是一个整数，在输出时，是对应的unicode吗对应的字符</p><p>4、、可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</p><p>5、char类型是可以i进行运算的，相当于一个整数，因为它都对应有unicode码</p><h2 id="字符型本质"><a href="#字符型本质" class="headerlink" title="字符型本质"></a>字符型本质</h2><p>存储：char a-&gt;97-&gt;(二进制)1100001-&gt;进行存储</p><p>读取：二进制-&gt;97====-&gt;”a”=-&gt;显示</p><h2 id="ASCLL表"><a href="#ASCLL表" class="headerlink" title="ASCLL表"></a>ASCLL表</h2><p>ASCLL表一个字节表示，一共有128个字符，实际上一个字节可以表示256个字符，只有了128个</p><h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><p>unicode编码表使用两个字节表示字符，字母和汉字统一都是占两个字节，这样浪费空间（广泛，容易造成资源浪费）</p><p><strong>unicode兼容ascll</strong></p><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><p>字母用一个字节，汉字用三个字节（范围大）</p><h2 id="gbk"><a href="#gbk" class="headerlink" title="gbk"></a>gbk</h2><p>字母用一个字节，汉字用两个字节（范围小）</p><p>gb2312《gbk</p><p>49</p><h2 id="boolean（布尔类型）"><a href="#boolean（布尔类型）" class="headerlink" title="boolean（布尔类型）"></a>boolean（布尔类型）</h2><p>boolean ispass=true;<br>    if(ispass==true)<br>    {<br>        System.out.println(“两个数近似相等”);</p><pre><code>&#125;else &#123;    System.out.println(&quot;两个数不相等&quot;);&#125;</code></pre><p>结果：两个数近似相等</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>数据类型按精度容量大小排序为：</p><p>char-&gt;int-&gt;long-&gt;float-&gt;double-</p><p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><p>int a=’c‘   double d=80  都是正确的</p><p>​        int n1 = 10;<br>​        float d1 = n1 + 1.1;<br>​        System.out.println(d1);（x）</p><p><strong>byte ：-128—127（byte和short、char之间不会像相互转换）</strong></p><p>​    byte b1=10;<br>​    int n2=1;<br>​    byte b2=n2;            （X）</p><p>如果是变量赋值，判断类型</p><p><strong>1、多种类型的数据混合运算时，系统首先自动将所有数据转换成容量大的那种数据，然后再进行计算</strong></p><p>2、<strong>byte short char三者不会相互转换</strong></p><p>3、<strong>byte 1个字节，1属于  -128-127之间，n2为4个字节，把n2赋值给一个字节的byte类型就会报错</strong> </p><p>4、<strong>byte short char他们三者可以计算，在计算时首先转换为int类型</strong></p><p>5、<strong>Boolean类型不参与转换</strong></p><p> 6、<strong>自动提升原则：表达式结果的类型自动提升为操作数种最大的类型</strong></p><p>  7、<strong>强制类型转换过程可能会会造成精度降低或溢出，要格外注意！</strong></p><p>​       double q = 2.9;<br>​        System.out.println((int) q);(精度溢出)<br>​        byte w = (byte) n1;<br>​        System.out.println(w);（溢出）</p><p>结果:</p><p>2<br>-24</p><h2 id="基本数据类型和string类型转换"><a href="#基本数据类型和string类型转换" class="headerlink" title="基本数据类型和string类型转换"></a>基本数据类型和string类型转换</h2><p><strong>基本类型转string：</strong></p><p>语法：1、将基本类型的值+“ ”即可</p><p>​        2、String s2=String.valueOf(100);//对于所有数据类型都适用<br>​                System.out.println(s2);</p><p><strong>string类型转基本数据类型：</strong></p><p>通过基本类型的包装类调用parseXX方法即可</p><p>​       String s5 = “123”;<br>​        int num1 = Integer.parseInt(s5);<br>​        double num2 = Double.parseDouble(s5);<br>​        float num3 = Float.parseFloat(s5);<br>​        long num4 = Long.parseLong(s5);<br>​        byte num5 = Byte.parseByte(s5);<br>​        boolean num6 = Boolean.parseBoolean(s5);<br>​        short num7 = Short.parseShort(s5);<br>​        System.out.println(num1);<br>​        System.out.println(num2);<br>​        System.out.println(num3);<br>​        System.out.println(num4);<br>​        System.out.println(num5);<br>​        System.out.println(num6);</p><p>结果：</p><p>123<br>123.0<br>123.0<br>123<br>123<br>false<br>123</p><h2 id="算术运算符难点"><a href="#算术运算符难点" class="headerlink" title="算术运算符难点"></a>算术运算符难点</h2><p><strong>先加后增：</strong></p><p>​       int i = 1;<br>​        i = i++;<br>​        System.out.println(i);</p><p>结果：1</p><p>先用再加实质：temp=i;i=i+1;i=temp;采用临时变量最后将temp的值重新赋给i；</p><p><strong>先增后加：</strong></p><pre><code>    int i = 1;    i = ++i;    System.out.println(i);</code></pre><p>结果：2</p><p>先加后用实质：i=i++;temp=i;i=temp;</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>a&amp;b  和 a&amp;&amp;b  a|b 和 a||b意思相同</p><p>a^b叫逻辑异或，当ab 不同时，结果为true  ，否则为false</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>a++      byte  b=2; b+=i -&gt;b=b+i   实质为：b=(byte)(b+i)</p><p>java中会有一个类型的强制转换</p><h2 id="数组使用注意事项和细节"><a href="#数组使用注意事项和细节" class="headerlink" title="数组使用注意事项和细节"></a>数组使用注意事项和细节</h2><p>1、数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</p><p>2、数组创建后，不进行赋值，有默认值，int 0,shrot 0,byte 0,long 0,float 0,double 0.0,char \u000,boolean false,String null</p><p>3、使用数组步骤：1、声明数组并开辟空间，2、给数组各个元素赋值3、使用数组。</p><p>4、数组下标从0开始</p><p>5、数组下标必须在指定范围内使用，否则会报错</p><p><strong>6、数组属于引用类型，数组类型是对象（object）</strong></p><p><strong>7、数组在默认情况下是引用传递，赋的值 是地址，赋值方式为引用</strong></p><p><strong>ps：int []arr1={1,2,3}; int []arr2=arr1;</strong></p><p><strong>是把arr1的地址赋给arr2，arr2的变化会影响arr1</strong></p><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>1、<strong>引用传递</strong></p><p>对象和数组传递属于引用传递，</p><p><strong>main函数中：</strong></p><p>​    B b=new B();</p><p>​    int []arr={1,2,3};//arr在栈区，数据123在堆区有存放地址</p><p>​    b.test(arr);</p><p><code>属于栈区部分，调用test()函数后，会重新在栈区新开辟一部分空间</code></p><p><code>在新开辟的栈区中，新的数组同样指向arr的地址，在其中修改arr中的数据，会影响main函数中arr数组中的数据</code></p><p><strong>代码示例：</strong></p><p>public class yinyongchaundi {</p><pre><code>public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    B b = new B();    int[] arr = &#123; 1, 2, 3 &#125;;    b.test100(arr);    for (int i = 0; i &lt; arr.length; i++) &#123;        System.out.println(arr[i] + &quot;\t&quot;);    &#125;    System.out.println();&#125;</code></pre><p>}<br>class B {<br>    public void test100(int[] a) {<br>        a[0] = 200;<br>        for (int i = 0; i &lt; a.length; i++) {<br>            System.out.println(a[i] + “\t”);<br>        }<br>        System.out.println();<br>    }</p><p>}</p><p>结果：</p><p>200<br>2<br>3    </p><p>200<br>2<br>3    </p><p><strong>示例代码2：</strong></p><p>public class yinyongchaundi {</p><pre><code>public static void main(String[] args) &#123;    nihao P=new nihao();    P.age=18;    P.name=&quot;zhangxinqi&quot;;    B b = new B();    b.print(P);    System.out.println(&quot;main:p.age=&quot;+P.age+&quot;,p.name=&quot;+P.name);&#125;</code></pre><p>}<br>class B {<br>    public void print(nihao a) {<br>        a.age=20;//改变对象P对应的数据<br>        a=null;//将新在栈区开辟的空间中的对象a（实际就是指向P）指向的数据地址置为空，<br>        //但并不影响main原始空间中对象P指向的数据<br>        a =new nihao();<br>        a.name=”lizhihui”;<br>        //同理，new一个新的对象，在堆区新开一个空间用来存储新初始化的值，对象a指向新地址<br>        //与原地址毫无任何关系，初始化后不再使用就会自动回收该新在堆区开辟的空间</p><pre><code>&#125;</code></pre><p>}<br>class nihao{<br>    int age;<br>    String name;<br>}</p><p>结果：main:p.age=20,p.name=zhangxinqi</p><h2 id="递归调用（迷宫问题，罗汉塔，八个皇后）-p222-p227-老韩java"><a href="#递归调用（迷宫问题，罗汉塔，八个皇后）-p222-p227-老韩java" class="headerlink" title="递归调用（迷宫问题，罗汉塔，八个皇后）(p222-p227)老韩java"></a><u>递归调用</u>（迷宫问题，罗汉塔，八个皇后）(p222-p227)老韩java</h2><p><strong>1、执行一个方法，会创建一个新的受保护的独立空间（栈空间）2、方法的局部变量是独立的，不会互相影响，比如n变量（即形参）</strong></p><p><strong>3、如果方法中使用的是引用类型变量（比如数组，对象），就会共享该引用类型的数据</strong></p><p><strong>4、递归必须向退出递归的条件逼近，否则就无限递归</strong></p><p><strong>5、当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</strong></p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h2><p>1、函数名相同</p><p>2、参数个数、类型、顺序不同</p><p>3、对函数返回值无要求</p><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>1、在java中，主要的变量就是属性（方法变量）和局部变量</p><p>2、局部变量一般是指在成员方法中定义的变量</p><p>3、java中的作用域分类：</p><p>全局变量：也就是属性，作用域为整个类体 cat类cry eat等方法使用属性</p><p>4、全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值，因为没有默认值（main函数中属于局部变量，类中属性和代码块属于相对全局变量，注意类中方法定义属于局部变量）</p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>1、属性和局部变量可以重名，访问遵循就近原则</p><p>ps：class cat{</p><pre><code>    int age=10;       public static void test()&#123;     int age=20;</code></pre><p>​         System.out.println(age);//20  就近原则</p><p>​    }</p><p>}</p><p>2、在同一个作用域中，比如在同一个成员方法中，两个局部变量不能重名//即不能定义两个一样的变量</p><p>3、属性生命周期较长，盘随着对象的创建而创建，伴随着对象的销毁而销毁，局部变量，生命周期较短，伴随着他的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。</p><p>4、作用域范围不同</p><p>​    全局变量/属性：可以被本类使用，或被其他类使用</p><p>​    局部变量：只能在本类中对应的方法中使用</p><p>5、修饰符不同</p><p>​    全局变量/属性可以加修饰符</p><p>​    局部变量不可以加修饰符</p><p><strong>6、内存位置不同，成员变量是在堆内存，局部变量是在栈内存</strong></p><p><strong>7、成员变量是在类中方法外，局部变量方法内或者方法声明上</strong></p><p><strong>8、成员变量有默认的初始化值，局部变量没有初始化值，必须先定义赋值</strong></p><h2 id="构造函数-构造器"><a href="#构造函数-构造器" class="headerlink" title="构造函数/构造器"></a>构造函数/构造器</h2><p>【修饰符】方法名（形参列表）{</p><pre><code>         方法体；</code></pre><p>}</p><p>1、构造器的修饰可以是默认的，也可以是 public protected private</p><p>2、构造器没有返回值</p><p>3、方法名和类名必须要一样</p><p>4、参数列表和成员方法一样的规则</p><p>5、构造器的调用系统完成 </p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、一个类可以定义多个不同的构造器，即构造器重载</p><p>2、构造器必须和类名相同</p><p>3、构造器没有返回值</p><p>4、构造器是完成对象的初始化，并不是创建对象</p><p>5、在创建对象时，系统自动的调用该类的构造方法</p><p>6、如果程序猿没有定义构造器，系统会自动生成一个无参构造器，也是默认构造器</p><p>7、一旦定义了自己的构造器，默认的构造器就覆盖了，不能再使用默认的无参构造器，除非显式定义一个；</p><h2 id="string以及StringBuilder"><a href="#string以及StringBuilder" class="headerlink" title="string以及StringBuilder"></a>string以及StringBuilder</h2><p>1、字符数组转化为字符串</p><p>​        char a[]= {‘a’,’b’,’c’};<br>​        String aString=new String(a);<br>​        System.out.println(aString)；</p><h2 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h2><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">方法描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">insert(int offset, String str) 将 <code>str</code> 参数的字符串插入此序列中。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td></tr></tbody></table></div><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>在应用程序要求线程安全的情况下，必须要使用stringBuffer类型</p><h2 id="string与stringbuilder之间的转换"><a href="#string与stringbuilder之间的转换" class="headerlink" title="string与stringbuilder之间的转换"></a>string与stringbuilder之间的转换</h2><p>1、stringbuilder转换为string</p><p>​        StringBuilder A=new StringBuilder();<br>​        A.append(100).append(“nihao”).append(“java”);//                链式编程</p><p>​        String a=A.toString();<br>​        System.out.println(a);</p><p>2、string转换为stringbuilder</p><p>​        构造方法</p><pre><code>     StringBuilder B=new StringBuilder(a);        System.out.println(B);</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的底层是一个可变数组，ArrayList："><a href="#集合的底层是一个可变数组，ArrayList：" class="headerlink" title="集合的底层是一个可变数组，ArrayList："></a>集合的底层是一个可变数组，ArrayList<E>：</h3><p>1、可调整大小的数组实现</p><p>2、<E>:是一种特殊的数据类型，泛型</p><p>如何使用：</p><p>​                在出现E的地方我们使用引用数据类替换即可</p><p>​                举例：ArrayList<String>,ArrayList<Student></p><h3 id="ArrayList构造方法和添加方法"><a href="#ArrayList构造方法和添加方法" class="headerlink" title="ArrayList构造方法和添加方法"></a>ArrayList构造方法和添加方法</h3><p>1、public ArrayList()    //创建一个空的集合对象</p><p>2、public boolean add(E e) //将制定的数据追加到集合的末尾</p><p>3、public void add(int index,E element)//在此集合的指定位置插入指定的元素</p><h3 id="ArrayList常用方法"><a href="#ArrayList常用方法" class="headerlink" title="ArrayList常用方法"></a>ArrayList常用方法</h3><p>1、public boolean remove(Object o) //删除指定的元素，返回删除是否成功</p><p>2、public E remove(int index)//删除指定索引处的元素,返回被删除的元素，E代表被删除数据的类型</p><p>3、public E set(int index,E element)//修改指定索引处的元素，返回被修改的元素</p><p>4、public E get(int index)//返回指定索引处的元素</p><p>5、public int size()//返回集合中的元素个数 </p><p>//System.out.println(arrayList.set(0, “xiugai”));//修改指定索引处的元素，返回被修改的元素<br>   // System.out.println(arrayList.remove(“world”));</p><p> //System.out.println(arrayList.remove(0));//没</p><p>有就会返回false<br>    //System.out.println(arrayList.get(0));//返回指定索引处的元素<br>    //System.out.println(arrayList.size());//返回集合中的元素个数 </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="1、在子类方法中访问一个变量"><a href="#1、在子类方法中访问一个变量" class="headerlink" title="1、在子类方法中访问一个变量"></a>1、在子类方法中访问一个变量</h3><p>（1）在子类方法中找（2）在子类成员属性中找（3）在父类成员属性中找</p><h3 id="2、super关键字"><a href="#2、super关键字" class="headerlink" title="2、super关键字"></a>2、super关键字</h3><p>this 代表本类对象的引用</p><p>super 代表父类对象的引用</p><p>1、调用父类中的成员方法super.test();</p><p>2、调用父类中的成员属性super.nums</p><p>3、调用父类中的构造函数</p><p>public  guanjianzi_super() {<br>        super();//必须写在第一行<br>    }</p><h3 id="3、继承中构造方法的访问特点"><a href="#3、继承中构造方法的访问特点" class="headerlink" title="3、继承中构造方法的访问特点"></a>3、继承中构造方法的访问特点</h3><p>1、子类中所有的构造方法默认都会访问父类中无参的构造方法</p><p>2、调用有参构造方法需要在子类构造函数中super(参数);</p><p>传进去一个参数即可调用父类的有参构造函数</p><h3 id="4、继承中成员方法的访问特点"><a href="#4、继承中成员方法的访问特点" class="headerlink" title="4、继承中成员方法的访问特点"></a>4、继承中成员方法的访问特点</h3><p>（1）在子类成员范围中找</p><p>（2）在父类成员范围中找</p><p>（3）如果都没有就报错</p><h3 id="5、方法重写注意事项"><a href="#5、方法重写注意事项" class="headerlink" title="5、方法重写注意事项"></a>5、方法重写注意事项</h3><p>1、父类中的私有方法，子类无法继承和重写</p><p>2、子类重写父类方法时只要不比父类低即可</p><p>即：父类如果是public  子类必须为 public</p><p>​        父类若是默认的，子类可以是默认，也可以是public</p><h3 id="6、继承注意事项"><a href="#6、继承注意事项" class="headerlink" title="6、继承注意事项"></a>6、继承注意事项</h3><p>1、单一继承，不支持多继承，但支持继承体系、多层继承，例如:父亲继承爷爷，孙子继承父亲。</p><h2 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h2><p>1、同一个项目中使用别的包需要引入</p><p>例如：import 包名称.类名；</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>1、private 只能在本类中访问，默认和保护和公共可以被其他无关的类访问</p><p>2、不同类中，另一个类不可以访问该类的私有方法</p><p>3、不同包中，只能访问另一个包的一个中类中的公共的方法</p><p>4、final 关键字是最终的意思，可以修饰成员方法，成员变量，类</p><p>​        最终方法不可以被重写</p><p>​        最终类不可以被继承</p><p>​        最终修饰基本类型变量不可以被重新赋值，引用类型可以被重新赋值，原理是final修饰引用类型是地址不可以被改变，但是里面的值是可以改变的.</p><pre><code>        final Cat aCat=new Cat();        aCat =new Cat();//会报错        final Cat aCat=new Cat();        aCat.age=5;//不报错        aCat.name=&quot;加菲猫&quot;;//不报错</code></pre><p>5、static    </p><p>（1）、被所有对象共享的成员用static修饰，建议通过类名进行访问（2）、被类的所有成员共享，这也是我们判断是否使用静态关键字的条件</p><p>访问特点：</p><p>（1）、非静态成员方法可以访问所有静态成员和非静态成员变量</p><p>（2）、静态成员方法只能访问静态成员变量和静态成员方法，main方法也是静态的，所以可以调用。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的前提和体现"><a href="#多态的前提和体现" class="headerlink" title="多态的前提和体现"></a>多态的前提和体现</h3><p>1、有继承/实现关系2、有方法重写3、有父类引用指向子类对象</p><h3 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h3><p>1、成员变量：编译和执行都看父类</p><p>2、成员方法：编译看父类中有没有，执行是执行子类中重写的此方法</p><p>原因：成员方法有重些，成员变量无重写</p><p>例如：</p><p>​        Animal animal=new Cat();<br>​        System.out.println(animal.age);//父类中的成员变量<br>​        animal.TextStyle();//子类中的成员方法</p><h3 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h3><p> 好处：多个类继承同一个父类时，可以写一个方法，使用参数为父类型，在使用的时候，使用具体的子类形参与操作，从而调用该子类的成员方法（可以调用的是子类中重写的方法）</p><p>例如：</p><pre><code>private static void test( Animal a) &#123;    // 传进来的子类对象    //原理为：Animal a=new 子类();    //即父类引用指向子类对象    a.TextStyle();//此方法多个子类进行重写&#125;</code></pre><p>弊端：调用的方法只能是所有继承该父类的子类进行重写</p><p>的成员方法，不能调用某个子类中特有的方法</p><h3 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a>多态的转型</h3><p>向上转型：即为有父类引用指向子类对象</p><p>向下转型：即父类引用转为子类对象</p><p>例如：</p><p>​        Animal animal=new <strong>Cat</strong>();  //向上转型<br>​        <strong>Cat</strong> bCat=(<strong>Cat</strong>)animal;  //向下转型，注意黑体加粗部分<br>​        bCat.catwork1();</p><p>注意：</p><p>向下转型中转型的对象必须与new 类型名 相符</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类的特点</strong>：抽象类和抽象方法必须用abstract关键字修饰</p><p>​            public abstract class 类名{}</p><p>​            public abstract void eat();</p><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p><p>抽象类不能实例化对象，可以参照多态的方式，通过子类对象实例化对象</p><p>抽象类的子类要么重写抽象类的所有抽象方法，要么他本身就是一个抽象类</p><p><strong>抽象类的成员特点</strong></p><p>成员变量：可以是变量也可以是常量</p><p>构造方法：有构造方法，但是不能实例化，通过子类访问父类的数据</p><p>成员方法：可以有抽象的方法来限定子类必须完成某些操作</p><p>也可以有非抽象方法提高代码复用性</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>接口用关键字interface修饰：</p><p>​        public interface 接口名 {}</p><p>类实现接口用implements 表示</p><p>​        public class 类名  implements  接口名{}</p><p>接口不能实例化，参照多态的方式，通过实现类对象实例化，这叫接口多态（具体类多态，抽象类多态，接口多态）</p><p><strong>多态的前提：有继承或者实现关系，有方法重写，有父类引用指向子类对象</strong></p><p>接口的实现类：</p><p>​            要么重写接口中的所有抽象方法</p><p>​            要么是抽象类</p><p><strong>接口的成员特点</strong>        </p><p>变量默认是公共、静态、最终的，静态即可以通过接口名访问，最终即值无法改变</p><p>接口中无构造方法，因为接口主要是对行为进行抽象，是没有具体存在，一个类如果没有父类，默认继承Object类</p><p>成员方法</p><p>​        只能是抽象方法，默认修饰符：public abstract</p><p><strong>接口和类的区别:</strong></p><p>​        接口不能被实例化对象，类可以；</p><p>​        接口没有构造方法；</p><p>​        接口中所有方法是抽象的；</p><p>​        接口中不能有变量，除了final和static修饰的变量；</p><p>​        接口不是被继承了，而是被实现了；</p><p>​        多个类可以同时实现同一个接口；</p><h2 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h2><p>类和类的关系：只能单继承，但是可以多层继承</p><p>类和接口的关系：可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p><p>接口与接口的关系：可以单继承，也可以多继承</p><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>成员区别：</p><p>​                抽象类：常量，变量，有构造方法，也有抽象方法，也有非抽象方法</p><p>​                接口：   常量，抽象方法</p><p>关系区别：</p><p>​                类和类：单继承</p><p>​                类和接口：单实现、多实现</p><p>​                接口与接口：单继承、多继承</p><p><strong>设计理念区别：</strong></p><p>​                <strong>抽象类：对象抽象，包括属性、行为</strong></p><p>​                <strong>接口：对行为抽象，主要是行为</strong></p><ul><li><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li></ol></li><li><ol><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li></ol></li><li><ol><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li></ol></li><li><ol><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol></li></ul><blockquote><p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p><p><strong>注</strong>：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。更多内容可参考 <a href="https://www.runoob.com/java/java8-default-methods.html">Java 8 默认方法</a>。</p><p><strong>注</strong>：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 <a href="https://www.runoob.com/java/java9-private-interface-methods.html">Java 9 私有接口方法</a>。</p></blockquote><h2 id="接口名作为形参和返回值"><a href="#接口名作为形参和返回值" class="headerlink" title="接口名作为形参和返回值"></a>接口名作为形参和返回值</h2><p>方法的形参是接口名，其实需要的是该接口的实现类对象</p><p>方法的返回值是接口名，其实是返回的是该接口的实现类对象</p><p><strong>其实类似于抽象类，需要通过父类引用指向子类对象，创建一个子类，重写接口中的方法，通过实例化一个子类对象调用接口中的方法。</strong></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>定义：在一个类中定义一个类</p><h3 id="内部类的访问特点："><a href="#内部类的访问特点：" class="headerlink" title="内部类的访问特点："></a><strong>内部类的访问特点：</strong></h3><p><strong>内部类可以直接访问外部类的成员，包括私有</strong></p><p><strong>外部类要访问内部类的成员，必须创建对象</strong></p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>1、在类的成员位置：成员内部类</p><p>2、在类的局部位置：局部内部类</p><p>一般格式：Player.nihao a=new Player(). new nihao();（不推荐）</p><p>常用方法：通过在外部类中写一个方法实例化一个内部类对象，访问内部类方法，再通过实例化外部类对象访问该方法，间接访问内部类</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义：在外部类的一个成员方法内定义一个类</p><p>调用方法：在外部类内的方法内部定义内部类并且实例化该内部类，通过实例化外部类对象，调用外部类方法进而调用内部类</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>前提：存在一个类或者是接口，这里的类可以是具体类，也可以是抽象类</p><p>本质：是一个继承了该类或者实现了该接口的子类匿名对象</p><p>创建格式：</p><pre><code>public class neibulei &#123;    public void method() &#123;        new SpeakEnglish() &#123;        @Override        public void speak() &#123;            // TODO 自动生成的方法存根            System.out.println(&quot;说英语&quot;);        &#125;       &#125;;    &#125;&#125;</code></pre><p>调用方法：</p><pre><code>new SpeakEnglish() &#123;        @Override        public void speak() &#123;            // TODO 自动生成的方法存根            System.out.println(&quot;说英语&quot;);        &#125;    &#125;.speak();</code></pre><p>完善方法：</p><p>public class neibulei {   </p><p>​     public void method() {    </p><p>​            SpeakEnglish as=new SpeakEnglish() {          </p><p>​                     public void speak() {                </p><p>​                                System.out.println(“说英语”);    </p><p>​                                    }   </p><pre><code>                             &#125;;        </code></pre><p>​            as.speak();    }</p><script type="math/tex; mode=display">public class neibulei {    public void method() {    SpeakEnglish as=new SpeakEnglish() {            @Override            public void speak() {                // TODO 自动生成的方法存根                System.out.println("说英语");            }        };        as.speak();    }}常用APIMath</script><div class="table-container"><table><thead><tr><th><code>static double</code></th><th><code>abs(double a)</code>返回值为 <code>double</code>绝对值。</th></tr></thead><tbody><tr><td><code>static float</code></td><td><code>abs(float a)</code>返回 <code>float</code>值的绝对值。</td></tr><tr><td><code>static int</code></td><td><code>abs(int a)</code>返回值为 <code>int</code>绝对值。</td></tr><tr><td><code>static long</code></td><td><code>abs(long a)</code>返回值为 <code>long</code>绝对值。</td></tr><tr><td><code>static double</code></td><td><code>acos(double a)</code>返回值的反余弦值; 返回的角度在0.0到<em>pi</em>的范围内。</td></tr><tr><td><code>static int</code></td><td><code>addExact(int x, int y)</code>返回其参数的总和，如果结果溢出int，则抛出 <code>int</code> 。</td></tr><tr><td><code>static long</code></td><td><code>addExact(long x, long y)</code>返回其参数的总和，如果结果溢出long，则抛出 <code>long</code> 。</td></tr><tr><td><code>static double</code></td><td><code>asin(double a)</code>返回值的正弦值; 返回角度在<em>pi</em> / 2到<em>pi</em> / 2的范围内。</td></tr><tr><td><code>static double</code></td><td><code>atan(double a)</code>返回值的反正切值; 返回角度在<em>pi</em> / 2到<em>pi</em> / 2的范围内。</td></tr><tr><td><code>static double</code></td><td><code>atan2(double y, double x)</code>返回从直角坐标（转换角度 <em>theta</em> <code>x</code> ， <code>y</code> ）为极坐标 <em>（R，θ-）。</em></td></tr><tr><td><code>static double</code></td><td><code>cbrt(double a)</code>返回 <code>double</code>值的多维数据集根。</td></tr><tr><td><code>static double</code></td><td><code>ceil(double a)</code>返回大于或等于参数的最小（最接近负无穷大） <code>double</code>值，等于一个数学整数。</td></tr><tr><td><code>static double</code></td><td><code>copySign(double magnitude, double sign)</code>使用第二个浮点参数的符号返回第一个浮点参数。</td></tr><tr><td><code>static float</code></td><td><code>copySign(float magnitude, float sign)</code>使用第二个浮点参数的符号返回第一个浮点参数。</td></tr><tr><td><code>static double</code></td><td><code>cos(double a)</code>返回角度的三角余弦。</td></tr><tr><td><code>static double</code></td><td><code>cosh(double x)</code>返回的双曲余弦 <code>double</code>值。</td></tr><tr><td><code>static int</code></td><td><code>decrementExact(int a)</code>返回一个递减1的参数，如果结果溢出int，则 <code>int</code> 。</td></tr><tr><td><code>static long</code></td><td><code>decrementExact(long a)</code>将返回的参数递减1，如果结果溢出long，则 <code>long</code> 。</td></tr><tr><td><code>static double</code></td><td><code>exp(double a)</code>返回欧拉的数字 <em>e</em>提高到一个 <code>double</code>价值。</td></tr><tr><td><code>static double</code></td><td><code>expm1(double x)</code>返回 <em>e</em> x -1。</td></tr><tr><td><code>static double</code></td><td><code>floor(double a)</code>返回小于或等于参数的最大（最接近正无穷大） <code>double</code>值，等于一个数学整数。</td></tr><tr><td><code>static int</code></td><td><code>floorDiv(int x, int y)</code>返回小于或等于代数商的最大（最接近正无穷大） <code>int</code>值。</td></tr><tr><td><code>static long</code></td><td><code>floorDiv(long x, long y)</code>返回小于或等于代数商的最大（最接近正无穷大） <code>long</code>值。</td></tr><tr><td><code>static int</code></td><td><code>floorMod(int x, int y)</code>返回 <code>int</code>参数的底部模数。</td></tr><tr><td><code>static long</code></td><td><code>floorMod(long x, long y)</code>返回 <code>long</code>参数的底模数。</td></tr><tr><td><code>static int</code></td><td><code>getExponent(double d)</code>返回a的表示中使用的无偏指数 <code>double</code> 。</td></tr><tr><td><code>static int</code></td><td><code>getExponent(float f)</code>返回a的表示中使用的无偏指数 <code>float</code> 。</td></tr><tr><td><code>static double</code></td><td><code>hypot(double x, double y)</code>返回sqrt（ <em>x</em> 2 + <em>y</em> 2 ），没有中间溢出或下溢。</td></tr><tr><td><code>static double</code></td><td><code>IEEEremainder(double f1, double f2)</code>根据IEEE 754标准计算两个参数的余数运算。</td></tr><tr><td><code>static int</code></td><td><code>incrementExact(int a)</code>返回自变量1，如果结果溢出int，则 <code>int</code> 。</td></tr><tr><td><code>static long</code></td><td><code>incrementExact(long a)</code>返回一个增加1的参数，如果结果溢出long，则 <code>long</code> 。</td></tr><tr><td><code>static double</code></td><td><code>log(double a)</code>返回的自然对数（以 <em>e</em>为底） <code>double</code>值。</td></tr><tr><td><code>static double</code></td><td><code>log10(double a)</code>返回一个 <code>double</code>的基数10对数值。</td></tr><tr><td><code>static double</code></td><td><code>log1p(double x)</code>返回参数和1的和的自然对数。</td></tr><tr><td><code>static double</code></td><td><code>max(double a, double b)</code>返回两个 <code>double</code>值中的较大值。</td></tr><tr><td><code>static float</code></td><td><code>max(float a, float b)</code>返回两个 <code>float</code>的较大值。</td></tr><tr><td><code>static int</code></td><td><code>max(int a, int b)</code>返回两个 <code>int</code>值中的较大值。</td></tr><tr><td><code>static long</code></td><td><code>max(long a, long b)</code>返回两个 <code>long</code>的较大值。</td></tr><tr><td><code>static double</code></td><td><code>min(double a, double b)</code>返回两个 <code>double</code>的较小值。</td></tr><tr><td><code>static float</code></td><td><code>min(float a, float b)</code>返回两个 <code>float</code>的较小值。</td></tr><tr><td><code>static int</code></td><td><code>min(int a, int b)</code>返回两个 <code>int</code>的较小值。</td></tr><tr><td><code>static long</code></td><td><code>min(long a, long b)</code>返回两个 <code>long</code>的较小值。</td></tr><tr><td><code>static int</code></td><td><code>multiplyExact(int x, int y)</code>返回参数的乘积，如果结果溢出int，则抛出 <code>int</code> 。</td></tr><tr><td><code>static long</code></td><td><code>multiplyExact(long x, long y)</code>返回参数的乘积，如果结果溢出long，则抛出 <code>long</code> 。</td></tr><tr><td><code>static int</code></td><td><code>negateExact(int a)</code>返回参数的否定，如果结果溢出int，则 <code>int</code> 。</td></tr><tr><td><code>static long</code></td><td><code>negateExact(long a)</code>返回参数的否定，如果结果溢出long，则 <code>long</code> 。</td></tr><tr><td><code>static double</code></td><td><code>nextAfter(double start, double direction)</code>返回与第二个参数方向相邻的第一个参数的浮点数。</td></tr><tr><td><code>static float</code></td><td><code>nextAfter(float start, double direction)</code>返回与第二个参数方向相邻的第一个参数的浮点数。</td></tr><tr><td><code>static double</code></td><td><code>nextDown(double d)</code>返回与负无穷大方向相邻的 <code>d</code>的浮点值。</td></tr><tr><td><code>static float</code></td><td><code>nextDown(float f)</code>返回与负无穷大方向相邻的 <code>f</code>的浮点值。</td></tr><tr><td><code>static double</code></td><td><code>nextUp(double d)</code>返回与正无穷大方向相邻的 <code>d</code>的浮点值。</td></tr><tr><td><code>static float</code></td><td><code>nextUp(float f)</code>返回与正无穷大方向相邻的 <code>f</code>的浮点值。</td></tr><tr><td><code>static double</code></td><td><code>pow(double a, double b)</code>将第一个参数的值返回到第二个参数的幂。</td></tr><tr><td><code>static double</code></td><td><code>random()</code>返回值为 <code>double</code>值为正号，大于等于 <code>0.0</code> ，小于 <code>1.0</code> 。</td></tr><tr><td><code>static double</code></td><td><code>rint(double a)</code>返回与参数最接近值的 <code>double</code>值，并且等于数学整数。</td></tr><tr><td><code>static long</code></td><td><code>round(double a)</code>返回参数中最接近的 <code>long</code> ，其中 <code>long</code>四舍五入为正无穷大。</td></tr><tr><td><code>static double</code></td><td><code>sqrt(double a)</code>返回的正确舍入正平方根 <code>double</code>值。</td></tr></tbody></table></div><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><div class="table-container"><table><thead><tr><th><code>static long</code></th><th><code>currentTimeMillis()</code>返回当前时间（以毫秒为单位）。</th></tr></thead><tbody><tr><td><code>static void</code></td><td><code>exit(int status)</code>终止当前运行的Java虚拟机。</td></tr></tbody></table></div><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><div class="table-container"><table><thead><tr><th><strong><code>boolean</code></strong></th><th><strong><code>equals(Object obj)</code>指示一些其他对象是否等于此。</strong></th></tr></thead><tbody><tr><td><strong><code>String</code></strong></td><td><strong><code>toString()</code>返回对象的字符串表示形式。</strong></td></tr></tbody></table></div><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>arrays.toString(数组名)</strong>   //返回指定数组的内容的字符串表示形式。</p><p>arrays.sort（数组）//按升序排列数组的指定范围。</p><h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><div class="table-container"><table><thead><tr><th><code>static int</code></th><th><code>MAX_VALUE</code>一个持有最大值一个 <code>int</code>可以有2 31 -1。</th></tr></thead><tbody><tr><td><code>static int</code></td><td><code>MIN_VALUE</code>的常量保持的最小值的 <code>int</code>可以具有，-2 31。</td></tr><tr><td><code>static int</code></td><td><code>SIZE</code>用于表示二进制补码二进制形式的 <code>int</code>值的位数。</td></tr><tr><td><code>static 类&lt;Integer&gt;</code></td><td><code>TYPE``类</code>原始类型 <code>int</code>的 <code>类</code>实例。</td></tr></tbody></table></div><p>Integer nInteger=new Integer(100);//只能是数字，其他类型会报错<br>        System.out.println(nInteger);</p><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p>1、打印当前日期</p><p>​        Calendar aCalendar=Calendar.getInstance();<br>​        int year=aCalendar.get(Calendar.YEAR);<br>​        int month=aCalendar.get(Calendar.MONDAY);<br>​        int data=aCalendar.get(Calendar.DATE);<br>​        System.out.println(year+”年”+month+”月”+data+”日”);</p><p>2、添加某个数据（年月日）</p><p>​        aCalendar.add(aCalendar.MONDAY,5);//添加月份</p><p>​    通过add方法可以对日历进行修改</p><p>3、获取对应月份的天数</p><p>​        Calendar aCalendar=Calendar.getInstance();</p><p>​        Scanner aScanner =new Scanner(System.in);<br>​        int year=aScanner.nextInt();<br>​        aCalendar.set(year,1,1);<br>​        aCalendar.add(aCalendar.DATE, -1);<br>​        int data=aCalendar.get(aCalendar.DATE);<br>​        System.out.println(data);</p><p>先获取年份，然后月份下标从0开始，1代表第二月，第二月最后一天减去一天就是第一个月最后一天，就可以获取第一个月的天数</p><p>4、计算某一天是这一年的第几天</p><pre><code>import java.util.Calendar;import java.util.Scanner;Calendar aCalendar = Calendar.getInstance();Scanner aScanner = new Scanner(System.in);    int year = aScanner.nextInt();    int month = aScanner.nextInt();    int data=aScanner.nextInt();    int nums=0;for (int i = 1; i &lt; month; i++) &#123;    aCalendar.set(year,i, 1);    aCalendar.add(aCalendar.DATE, -1);nums = nums+aCalendar.get(aCalendar.DATE);        &#125;    System.out.println(nums+data);</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><pre><code>                                 Throwable</code></pre><p>​                    Error                                                Exception</p><p>​                                                   RuntimeException        非 RuntimeException </p><p>Error：严重问题，不需要处理</p><p>Exception：称为异常类，他表示程序本身可以处理的问题</p><p> RuntimeException ：在编译期是不需要检查的，出现问题后，需要回来修改代码</p><p>非 RuntimeException ：编译期间就必须处理的，否则程序不能通过编译，更不能正常运行。</p><p><img src="https://uploadfiles.nowcoder.com/images/20211028/348470426_1635431780619/6479D7BB01736CCC61B8270D41F00B17" alt="img"></p><h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p><img src="E:\sql学习资料\集合类体系结构.png" alt="集合类体系结构"></p><p><img src="https://uploadfiles.nowcoder.com/images/20161014/4552908_1476435955845_3AA2482F152044FA3EC4640FD49DAE02" alt="img"></p><h3 id="Collection-集合的常用方法："><a href="#Collection-集合的常用方法：" class="headerlink" title="Collection 集合的常用方法："></a>Collection 集合的常用方法：</h3><ul><li><ul><li>| <code>boolean</code> | <code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。 |<br>| ————- | ————————————————————————— |<br>| <code>void</code>    | <code>clear()</code>  从此集合中删除所有元素（可选操作）。    |</li></ul></li><li><ul><li>| <code>boolean</code> | <code>contains(Object o)</code>  如果此集合包含指定的元素，则返回 <code>true</code> 。 |<br>| ————- | —————————————————————————————— |<br>| <code>boolean</code> | <code>isEmpty()</code>  如果此集合不包含元素，则返回 <code>true</code> 。          |</li></ul></li><li><ul><li>| <code>Iterator&lt;E&gt;</code> | <code>iterator()</code>  返回此集合中的元素的迭代器。                   |<br>| ——————- | —————————————————————————————— |<br>| <code>boolean</code>     | <code>remove(Object o)</code>  从该集合中删除指定元素的单个实例（如果存在）（可选操作）。 |</li></ul></li><li><ul><li>| <code>int</code> | <code>size()</code>  返回此集合中的元素数。 |<br>| ——- | ———————————————— |<br>|       |                                  |</li></ul></li></ul><h3 id="collection集合的遍历"><a href="#collection集合的遍历" class="headerlink" title="collection集合的遍历"></a>collection集合的遍历</h3><pre><code>Collection&lt;String&gt;collection=new ArrayList&lt;String&gt;();    collection.add(&quot;你好&quot;);    collection.add(&quot;wode&quot;);    //collection.remove(&quot;wode&quot;);    //    System.out.println(collection);    Iterator&lt;String&gt;aIterator=collection.iterator();    while(aIterator.hasNext()) &#123;        System.out.println(aIterator.next());    &#125;</code></pre><h3 id="集合的使用步骤"><a href="#集合的使用步骤" class="headerlink" title="集合的使用步骤"></a>集合的使用步骤</h3><p>1、创建集合对象</p><p>2、添加元素</p><p>3、遍历集合</p><pre><code>    Student aStudent = new Student(&quot;12&quot;, &quot;zxq&quot;, &quot;10&quot;, &quot;henan&quot;);    Student aStudent1 = new Student(&quot;11&quot;, &quot;zhangxinqi&quot;, &quot;9&quot;, &quot;han&quot;);    Collection&lt;Student&gt; aCollection = new ArrayList&lt;Student&gt;();    aCollection.add(aStudent);    aCollection.add(aStudent1);    Iterator&lt;Student&gt; iterator = aCollection.iterator();    while (iterator.hasNext()) &#123;        Student aStudent2 = iterator.next();        System.out.println(aStudent2.getName() + &quot;,&quot; + aStudent2.getSid() + &quot;,&quot; +         aStudent2.getAge() + &quot;,&quot;                + aStudent2.getAddress());    &#125;</code></pre><h2 id="list集合概述和特点"><a href="#list集合概述和特点" class="headerlink" title="list集合概述和特点"></a>list集合概述和特点</h2><p>List集合概述：</p><p>​        有序集合，可以精准控制列表中每个元素的插入位置，通过整数索引访问</p><p>​        与set集合不同，列表通常允许重复的元素</p><p>特点：</p><p>​        有序：存储和取出的元素顺序一致</p><p>​        可重复：存储的元素可以重复</p><p>​        List<String> strList = new ArrayList&lt;&gt;();<br>​        strList.add(“nihao”);<br>​        Iterator<String>aIterable=strList.iterator();<br>​        while (aIterable.hasNext()) {<br>​            System.out.println(aIterable.next());<br>​            }</p><h3 id="使用List集合存储学生类对象信息"><a href="#使用List集合存储学生类对象信息" class="headerlink" title="使用List集合存储学生类对象信息"></a>使用List集合存储学生类对象信息</h3><pre><code>Student aStudent = new Student(&quot;12&quot;, &quot;zxq&quot;, &quot;10&quot;, &quot;henan&quot;);Student aStudent1 = new Student(&quot;11&quot;, &quot;zhangxinqi&quot;, &quot;9&quot;, &quot;han&quot;);List&lt;Student&gt; strList = new ArrayList&lt;&gt;();    strList.add(aStudent);    strList.add(aStudent1);    //迭代器输出Iterator&lt;Student&gt;aIterable=strList.iterator();    while (aIterable.hasNext()) &#123;        Student aStudent2=aIterable.next();System.out.println(aStudent2.getAge()+aStudent2.getName());    &#125;    //for循环遍历输出    for (int i = 0; i &lt; strList.size(); i++) &#123;        Student aStudent2=strList.get(i);System.out.println(aStudent2.getAge()+aStudent2.getName());    &#125;</code></pre><h3 id="List并发修改异常"><a href="#List并发修改异常" class="headerlink" title="List并发修改异常"></a>List并发修改异常</h3><p>在Java开发中Exception in thread “main” java.util.ConcurrentModificationException, 这是一个并发修改异常，迭代器是依赖于集合而存在的，在判断成功后，集合的中新添加了元素，而迭代器却不知道，所以就报错了，这个错叫并发修改异常。<br><strong>简单描述就是：迭代器遍历元素的时候，通过集合是不能修改元素的。</strong></p><pre><code>   ArrayList&lt;String&gt; array = new     ArrayList&lt;String&gt;();      // 创建并添加元素    array.add(&quot;hello&quot;);    array.add(&quot;world&quot;);    array.add(&quot;java&quot;);    // 方式1：迭代器迭代元素，迭代器修改元素// 而Iterator迭代器却没有添加功能，所以我们使用其子接口ListIterator，本质是每次修改后会把实际修改值赋值给预期修改值    // ListIterator lit = array.listIterator();    // while (lit.hasNext()) &#123;    // String s = (String) lit.next();    // if (&quot;world&quot;.equals(s)) &#123;    // lit.add(&quot;javaee&quot;);    // &#125;    // &#125;    // System.out.println(&quot;list1:&quot; + array);    // 方式2：集合遍历元素，集合修改元素(普通for)     for (int x = 0; x &lt; array.size(); x++) &#123;     String s = (String) array.get(x);     if (&quot;world&quot;.equals(s)) &#123;     array.add(&quot;javaee&quot;);     &#125;     &#125;     System.out.println(&quot;list2:&quot; + array);    &#125;&#125;</code></pre><p>提示：集合有个属性modCount，每当对集合修改一次，modCount的值就会自增，，迭代器在遍历的时候，底层会new一个Itr的内部类，初始化了一个变量记录了集合的实际修改次数modCount，变量名expectedModCount是预期修改次数。迭代器在调用next()方法时候会去比较这两个值是否相等，不相等则抛出异常</p><p>final void checkForComodification()</p><p> {</p><p>​         if (modCount != expectedModCount) throw new          ConcurrentModificationException();</p><p> }</p><h2 id="ListIterator列表迭代器-用的不多-多用Iterator"><a href="#ListIterator列表迭代器-用的不多-多用Iterator" class="headerlink" title="ListIterator列表迭代器(用的不多,多用Iterator)"></a>ListIterator列表迭代器(用的不多,多用Iterator)</h2><p>1、通过list集合的listlterator()方法得到，所以说他是List集合特有的迭代器</p><p>2、用于允许程序猿沿任意方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表迭代器的当前位置</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><ul><li><p>| <code>void</code>    | <code>add(E e)</code>  将指定的元素插入列表（可选操作）。               |<br>| ————- | —————————————————————————————— |<br>| <code>boolean</code> | <code>hasNext()</code>  返回 <code>true</code>如果遍历正向列表，列表迭代器有多个元素。 |<br>| <code>boolean</code> | <code>hasPrevious()</code>  返回 <code>true</code>如果遍历反向列表，列表迭代器有多个元素。 |<br>| <code>E</code>       | <code>next()</code>  返回列表中的下一个元素，并且前进光标位置。         |<br>| <code>int</code>     | <code>nextIndex()</code>  返回随后调用 <a href="../../java/util/ListIterator.html#next--"><code>next()</code></a>返回的元素的索引。 |<br>| <code>E</code>       | <code>previous()</code>  返回列表中的上一个元素，并向后移动光标位置。   |<br>| <code>int</code>     | <code>previousIndex()</code>  返回由后续调用 <a href="../../java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的元素的索引。 |<br>| <code>void</code>    | <code>remove()</code>  从列表中删除由 <a href="../../java/util/ListIterator.html#next--"><code>next()</code></a>或 <a href="../../java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）。 |<br>| <code>void</code>    | <code>set(E e)</code>  用 <a href="../../java/util/ListIterator.html#next--">指定的</a>元素替换由 <a href="../../java/util/ListIterator.html#next--"><code>next()</code></a>或 <a href="../../java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）。 |</p><p>while (lit.hasPrevious()) {</p><pre><code>        String string = (String) lit.previous();        System.out.println(&quot;list1:&quot; + string);    &#125;</code></pre></li></ul></li></ul><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>其底层是一个迭代器</p><p>格式：</p><pre><code>// 增强for循环写的话会报同样的错误，因为它本身就是用来替代迭代器的 // for (String s : array) &#123;    // if (&quot;world&quot;.equals(s)) &#123;    // array.add(&quot;javaee&quot;);    // &#125;    // &#125;    // System.out.println(&quot;list3:&quot; + array);    for (String s : strList) &#123;               System.out.println(s);         &#125;</code></pre><h2 id="三种遍历集合的方法"><a href="#三种遍历集合的方法" class="headerlink" title="三种遍历集合的方法"></a>三种遍历集合的方法</h2><pre><code>        Student aStudent = new Student(&quot;12&quot;, &quot;zxq&quot;, &quot;10&quot;, &quot;henan&quot;);         Student aStudent1 = new Student(&quot;11&quot;, &quot;zhangxinqi&quot;, &quot;9&quot;, &quot;han&quot;);        List&lt;Student&gt; strList = new ArrayList&lt;&gt;();         strList.add(aStudent);         strList.add(aStudent1);         Iterator&lt;Student&gt; aIterable=strList.iterator();         while (aIterable.hasNext()) &#123;             Student aStudent2=aIterable.next();             System.out.println(aStudent2.getAge());         &#125;         for (int i = 0; i &lt; strList.size(); i++) &#123;             Student aStudent2=strList.get(i);             System.out.println(aStudent2.getAge());        &#125;         for (Student aStudent2:strList) &#123;             System.out.println(aStudent2.getAge());        &#125;</code></pre><h2 id="List集合子类特点"><a href="#List集合子类特点" class="headerlink" title="List集合子类特点"></a>List集合子类特点</h2><p>ArrayList：底层数据结构是数组，查询快，增删慢</p><p>LinkedList：底层数据结构式链表，查询慢，增删快</p><h2 id="LinkedList集合的特有功能"><a href="#LinkedList集合的特有功能" class="headerlink" title="LinkedList集合的特有功能"></a>LinkedList集合的特有功能</h2><ul><li><ul><li>| <code>E</code>  | <code>get(int index)</code>  返回此列表中指定位置的元素。 |<br>| —— | ——————————————————————— |<br>| <code>E</code>  | <code>getFirst()</code>  返回此列表中的第一个元素。       |<br>| <code>E</code>  | <code>getLast()</code>  返回此列表中的最后一个元素。      |</li></ul></li><li><ul><li>| <code>E</code>  | <code>removeFirst()</code>  从此列表中删除并返回第一个元素。  |<br>| —— | ————————————————————————— |<br>|      |                                                    |<br>| <code>E</code>  | <code>removeLast()</code>  从此列表中删除并返回最后一个元素。 |</li></ul></li><li><ul><li>| <code>void</code> | <code>addFirst(E e)</code>  在该列表开头插入指定的元素。    |<br>| ——— | ———————————————————————— |<br>| <code>void</code> | <code>addLast(E e)</code>  将指定的元素追加到此列表的末尾。 |<br>| <code>void</code> | <code>clear()</code>  从列表中删除所有元素。                |</li></ul></li></ul><h2 id="Set集合的概述和特点"><a href="#Set集合的概述和特点" class="headerlink" title="Set集合的概述和特点"></a>Set集合的概述和特点</h2><p>set集合特点</p><p>1、不包含重复元素的集合</p><p>2、没有带索引的方法，所以不能使用普通for循环遍历</p><p>set集合练习</p><p>1、存储字符串遍历</p><h2 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h2><p>哈希值：是jdk根据对象的地址或者字符串或者数字计算出来的int类型的数值</p><p>Object类中有一个方法可以获取对象的哈希值</p><p>System.out.println(aStudent.hashCode());</p><p>1、同一个对象的哈希值在默认情况下是相同的，即默认Object方法</p><p>2、通过对Object方法重写可以实现不同对象有相同的哈希值</p><p> System.out.println(“重地”.hashCode());<br> System.out.println(“通话”.hashCode());</p><p>输出：</p><p>1179395<br>1179395</p><p>原因：string肯定会有一个上限，当字符长时产生的数值过大string放不下时会进行截取，一旦截取HashCode的正确性就无法保证了，所以这点可以推断出HashCode存在不相同字符拥有相同HashCode。</p><h2 id="HashSet集合的概述特点"><a href="#HashSet集合的概述特点" class="headerlink" title="HashSet集合的概述特点"></a>HashSet集合的概述特点</h2><p>1、HashSet这个类是set接口的实现类，</p><p>2、HashSet底层结构是hash表</p><p>3、不保证存储和取出的元素顺序一致</p><p>4、没有带索引的方法，所以不能使用普通for循环遍历</p><p>5、不包含重复元素的集合</p><p><strong>注意：要实现存储元素的唯一性需要重写哈希code和equals方法，自动生成即可</strong></p><h2 id="哈希表存储元素原理"><a href="#哈希表存储元素原理" class="headerlink" title="哈希表存储元素原理"></a><strong>哈希表存储元素原理</strong></h2><p>1、先对哈希值对16取余，取余的结果存储到0-15对应的位置</p><p>2、依次存储对应位置，当对应位置无元素直接存储，有元素先比较哈希值，不一样存储进去</p><p>3、哈希值一样，对元素进行比较，一样就不存储</p><h2 id="LinkerHashSet集合"><a href="#LinkerHashSet集合" class="headerlink" title="LinkerHashSet集合"></a>LinkerHashSet集合</h2><p>1、哈希表和链表实现的set接口，具有可预测的迭代次序</p><p>2、由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</p><p>3、LinkerHashSet继承于HashSet，实现于set接口</p><p>4、HashSe表保证元素的唯一性</p><h2 id="TreeSet集合（比较器）"><a href="#TreeSet集合（比较器）" class="headerlink" title="TreeSet集合（比较器）"></a>TreeSet集合（比较器）</h2><ul><li>```<br>public class TreeSet<E><br>extends AbstractSet<E><br>implements NavigableSet<E>, Cloneable, Serializable<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TreeSet间接继承于set接口，TreeSet集合可以自然排序，也可以使用比较器排序（使用什么比较方法取决于使用哪种构造器）</span><br><span class="line"></span><br><span class="line">- - | Constructor and Description                                  |</span><br><span class="line">    | ------------------------------------------------------------ |</span><br><span class="line">    | `TreeSet()`  构造一个新的，空的树组，根据其元素的自然排序进行排序。 |</span><br><span class="line">    | `TreeSet(Collection&lt;? extends E&gt; c)`  构造一个包含指定集合中的元素的新树集，根据其元素的 *自然排序进行排序* 。 |</span><br><span class="line">    | `TreeSet(Comparator&lt;? super E&gt; comparator)`  构造一个新的，空的树集，根据指定的比较器进行排序。 |</span><br><span class="line">    | `TreeSet(SortedSet&lt;E&gt; s)`  构造一个包含相同元素的新树，并使用与指定排序集相同的顺序。 |</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;Integer&gt;aSet=new TreeSet&lt;&gt;();</span><br><span class="line">    aSet.add(10);</span><br><span class="line">    aSet.add(20);</span><br><span class="line">    aSet.add(100);</span><br><span class="line">    aSet.add(625);</span><br><span class="line">    aSet.add(666);</span><br><span class="line">    aSet.add(30);</span><br><span class="line">    Iterator&lt;Integer&gt;aIterator=aSet.iterator();</span><br><span class="line">    while (aIterator.hasNext()) &#123;</span><br><span class="line">    Integer student =aIterator.next();</span><br><span class="line">    System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">注意：使用TreeSet集合存储时使用的是引用类型（基本类型的包装类类型）</span><br><span class="line"></span><br><span class="line">**测试类：**</span><br><span class="line"></span><br><span class="line">TreeSet&lt;Student&gt; aHashSet = new TreeSet&lt;Student&gt;();</span><br><span class="line">Student aStudent = new Student(&quot;1001&quot;, &quot;10&quot;, &quot;zxq&quot;, &quot;henan&quot;);</span><br><span class="line">Student bStudent = new Student(&quot;1002&quot;, &quot;11&quot;, &quot;axq&quot;, &quot;henan&quot;);</span><br><span class="line">Student cStudent = new Student(&quot;1003&quot;, &quot;12&quot;, &quot;bxq&quot;, &quot;henan&quot;);</span><br><span class="line">Student dStudent = new Student(&quot;1004&quot;, &quot;10&quot;, &quot;cxq&quot;, &quot;henan&quot;);</span><br><span class="line"></span><br><span class="line">aHashSet.add(aStudent);</span><br><span class="line">aHashSet.add(bStudent);</span><br><span class="line">aHashSet.add(cStudent);</span><br><span class="line">aHashSet.add(dStudent);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Student&gt; aIterator = aHashSet.iterator();</span><br><span class="line">while (aIterator.hasNext()) &#123;</span><br><span class="line">Student student = aIterator.next();</span><br><span class="line">System.out.println(</span><br><span class="line">student.getSid() + &quot;,&quot; + student.getAge() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAddress());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">**学生类：**</span><br><span class="line"></span><br><span class="line">若TreeSet集合中数据类型为自定义的类型（类），需要继承Comparable接口，并且需要重写compareTo方法</span><br><span class="line"></span><br><span class="line">，返回值为0，默认相同，不比较，返回值为负数，降序排列，返回值为正数，默认升序排列，比较的是存储时的第一个元素,若想按照自己的意愿按照其他方式排序，int 类型就做减法，string类型就直接调用compareTo方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Student implements Comparable&lt;Student&gt; &#123;</span><br><span class="line">String sid;</span><br><span class="line">String name;</span><br><span class="line">String age;</span><br><span class="line">String address;</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Student o) &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line"></span><br><span class="line">int num2=this.getAge().compareTo(o.getAge());</span><br><span class="line">int num=num2==0?this.getSid().compareTo(o.getSid()):num2;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getSid() &#123;</span><br><span class="line">return sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line"></span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getAddress() &#123;</span><br><span class="line">return address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSid(String sid) &#123;</span><br><span class="line">this.sid = sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(String age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAddress(String address) &#123;</span><br><span class="line">this.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(String sid, String age, String name, String address) &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">this.age = age;</span><br><span class="line">this.name = name;</span><br><span class="line">this.sid = sid;</span><br><span class="line">this.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">final int prime = 31;</span><br><span class="line">int result = 1;</span><br><span class="line">result = prime * result + ((address == null) ? 0 : address.hashCode());</span><br><span class="line">result = prime * result + ((age == null) ? 0 : age.hashCode());</span><br><span class="line">result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">result = prime * result + ((sid == null) ? 0 : sid.hashCode());</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">if (this == obj)</span><br><span class="line">return true;</span><br><span class="line">if (obj == null)</span><br><span class="line">return false;</span><br><span class="line">if (getClass() != obj.getClass())</span><br><span class="line">return false;</span><br><span class="line">Student other = (Student) obj;</span><br><span class="line">if (address == null) &#123;</span><br><span class="line">if (other.address != null)</span><br><span class="line">return false;</span><br><span class="line">&#125; else if (!address.equals(other.address))</span><br><span class="line">return false;</span><br><span class="line">if (age == null) &#123;</span><br><span class="line">if (other.age != null)</span><br><span class="line">return false;</span><br><span class="line">&#125; else if (!age.equals(other.age))</span><br><span class="line">return false;</span><br><span class="line">if (name == null) &#123;</span><br><span class="line">if (other.name != null)</span><br><span class="line">return false;</span><br><span class="line">&#125; else if (!name.equals(other.name))</span><br><span class="line">return false;</span><br><span class="line">if (sid == null) &#123;</span><br><span class="line">if (other.sid != null)</span><br><span class="line">return false;</span><br><span class="line">&#125; else if (!sid.equals(other.sid))</span><br><span class="line">return false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果：</p><p>1001,10,zxq,henan<br>1004,10,cxq,henan<br>1002,11,axq,henan<br>1003,12,bxq,henan</p><h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>Comparator 比较器和TreeSet构造器中重写Comparable方法本质一样,Comparator 本质是一个内部类</p><pre><code>TreeSet&lt;Student&gt; aSet = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;    @Override        public int compare(Student o1, Student o2) &#123;            // TODO 自动生成的方法存根            int num2 = o1.getAge().compareTo(o2.getAge());//比较年龄            int num = num2 == 0 ? o1.getSid().compareTo(o2.getSid()) : num2;//年龄相同比学号            return num;        &#125;    &#125;);    Student aStudent = new Student(&quot;1001&quot;, &quot;10&quot;, &quot;zxq&quot;, &quot;henan&quot;);    Student bStudent = new Student(&quot;1002&quot;, &quot;11&quot;, &quot;axq&quot;, &quot;henan&quot;);    Student cStudent = new Student(&quot;1003&quot;, &quot;12&quot;, &quot;bxq&quot;, &quot;henan&quot;);    Student dStudent = new Student(&quot;1004&quot;, &quot;10&quot;, &quot;cxq&quot;, &quot;henan&quot;);    aSet.add(aStudent);    aSet.add(bStudent);    aSet.add(cStudent);    aSet.add(dStudent);    Iterator&lt;Student&gt; aIterator = aSet.iterator();    while (aIterator.hasNext()) &#123;        Student student = aIterator.next();        System.out.println(                student.getSid() + &quot;,&quot; + student.getAge() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAddress());    &#125;</code></pre><h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><p>注意：学生类中成绩需要使用int类型</p><pre><code>    TreeSet&lt;Student&gt; aSet = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;        @Override        public int compare(Student o1, Student o2) &#123;            // TODO 自动生成的方法存根            int num2=o1.getAge()+o1.getSid()-o2.getAge()-o2.getSid();            int num = num2 == 0 ? o1.getSid()-o2.getSid() : num2;            int num3=num==0?o1.getName().compareTo(o2.getName()):num;            return num;        &#125;    &#125;);    Student aStudent = new Student(99, 99, &quot;zxq&quot;, &quot;henan&quot;);    Student bStudent = new Student(98, 99, &quot;axq&quot;, &quot;henan&quot;);    Student cStudent = new Student(98, 95, &quot;bxq&quot;, &quot;henan&quot;);    Student dStudent = new Student(96, 97, &quot;cxq&quot;, &quot;henan&quot;);    aSet.add(aStudent);    aSet.add(bStudent);    aSet.add(cStudent);    aSet.add(dStudent);    Iterator&lt;Student&gt; aIterator = aSet.iterator();    while (aIterator.hasNext()) &#123;        Student student = aIterator.next();        System.out.println(                student.getSid() + &quot;,&quot; + student.getAge() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAddress());    &#125;</code></pre><h2 id="随机数排序"><a href="#随机数排序" class="headerlink" title="随机数排序"></a>随机数排序</h2><pre><code>Set&lt;Integer&gt; aSet=new TreeSet&lt;Integer&gt;();    Random aRandom=new Random();    while (aSet.size()&lt;10) &#123;        int num=aRandom.nextInt(20)+1;        aSet.add(num);    &#125;    System.out.println(aSet);</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型格式：</p><p>&lt;类型&gt;：指定一种数据类型，看成是形参</p><p>&lt;类型1，类型2&gt;：指定多种类型的格式，多个类型之间用逗号隔开</p><p>好处：</p><p>1、把运行时候的问题提前到编译期间</p><p>2、避免了强制类型转换</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>测试类：</p><pre><code>    public static void main(String[] args) &#123;    // TODO 自动生成的方法存根    Teach1 &lt;String&gt;bTeach=new Teach1();    bTeach.setName(&quot;zxq&quot;);    Teach1 aTeach1=new Teach1();//未指定类型，不规范    aTeach1.setAge(30);    aTeach1.setAge(&quot;60&quot;);    System.out.println(bTeach.getName());    System.out.println(aTeach1.getAge());//    Teach1 &lt;Integer&gt;aTeach=new Teach1();//    aTeach.setAge(&quot;10&quot;);//实例化对象时指定类型，调用方法不按照指定类型就会报错&#125;</code></pre><p>老师类：</p><pre><code>public class Teach1&lt;T&gt; &#123;    private T name;    private T age;    public T getName() &#123;        return name;    &#125;    public void setName(T name) &#123;        this.name = name;    &#125;    public T getAge() &#123;        return age;    &#125;    public void setAge(T age) &#123;        this.age = age;    &#125;&#125;</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>优点：</p><p>一个对象可以多次调用同一个方法，传入的类型不同</p><p>测试类：</p><p>​        Teach1 aTeach1=new Teach1&lt;&gt;();<br>​        aTeach1.TexR(“zxq”);<br>​        aTeach1.TexR(13);<br>​        aTeach1.TexR(12.63);</p><p>泛型方法：</p><pre><code>public &lt;T&gt; void TexR(T t)&#123;    System.out.println(t);&#125;</code></pre><p><strong>注意：泛型方法不一定要写在泛型类中</strong></p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口示例：</p><p>public interface teach<T> {<br>     void show(T t);<br>}</p><p>泛型类示例：</p><pre><code>public class Teach1&lt;T&gt; implements teach&lt;T&gt; &#123;    private T name;    private T age;    public T getName() &#123;        return name;    &#125;public void setName(T name) &#123;    this.name = name;&#125;public T getAge() &#123;    return age;&#125;public void setAge(T age) &#123;    this.age = age;&#125;@Overridepublic void show(T t) &#123;    // TODO 自动生成的方法存根    System.out.println(t);    &#125;&#125;</code></pre><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p><p>类型通配符：&lt;?&gt;</p><p>List&lt;?&gt;:表示元素类型未知的List，他的元素可以匹配任何的类型</p><p>这种带有通配符的List仅表示他是各种泛型List的父类，并不能把元素添加进去</p><p>类型通配符：&lt;?&gt;</p><p>类型通配符上限:&lt;? extends 类型&gt;  List最高的类型不能超过该类型</p><p>类型通配符下限：&lt;? super 类型&gt;List最低的类型不能超过该类型</p><p>​        List&lt;?&gt; aList = new ArrayList<Object>();<br>​        List&lt;?&gt; bList = new ArrayList<Number>();<br>​        List&lt;?&gt; cList = new ArrayList<Integer>();<br>​        System.out.println(“——————————-“);<br>​        List&lt;? extends Number&gt; aList2 = new ArrayList<Number>();<br>​        List&lt;? extends Number&gt; cList2 = new ArrayList<Integer>();<br>​        // List&lt;? extends Number&gt;fList2=new ArrayList<Object>();//超过Number类型，报错<br>​        System.out.println(“——————————-“);<br>​        List&lt;? super Number&gt; dList2 = new ArrayList<Number>();<br>​        List&lt;? super Number&gt; eList2 = new ArrayList<Object>();<br>​        // List&lt;? super Number&gt;gList2=new ArrayList<Integer>();//低于Number类型，报错</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>注意事项：</p><p>1、可变参数的实参可以为0个或者任意多个</p><p>2、克变参数的实参可以为数组</p><p>3、可变参数本质就是数组</p><p>4、可变参数可以与普通类型的参数放在形参列表，但必须保证可变参数放在最后</p><p>5、一个形参列表只能出现一个可变参数</p><pre><code>public static void main(String[] args) &#123;        System.out.println(sum(1, 2, 5, 630));        System.out.println(sum(1, 2, 3, 5, 8, 4));    &#125;public static int sum(int b, int... a) &#123;    int sum = 0;    for (int i : a) &#123;        sum += i;    &#125;    return sum;&#125;</code></pre><p><strong>Arrays的一个静态方法:</strong></p><ul><li><ul><li>| <code>static &lt;T&gt; List&lt;T&gt;</code> | <code>asList(T... a)</code>  返回由指定数组支持的固定大小的列表。 |<br>| —————————— | ——————————————————————————— |<br>|                      |                                                        |</li></ul></li></ul><p>​        List<String> aList3 = Arrays.asList(“nihao”, “我好”, “大家好”);<br>​        // 不允许改变长度,但是可以修改元素<br>​        // aList3.add(“JAVA”);<br>​        // aList3.remove(0);<br>​        aList3.set(0, “javaee”);<br>​        System.out.println(aList3);</p><p><strong>List接口中的一个静态方法(JDK9以及以上)：</strong></p><p>//返回包含任意数量元素的不可变列表，不能添加修改删除</p><p>List<String>bList2=List.of(“nihao”, “我好”, “大家好”，“nihao”);</p><p><strong>Set集合中一个静态方法返回集合中任意数量元素的不可变列表</strong>（JKD9以及以上）</p><p>//返回包含任意数量元素的不可变列表，不能添加删除</p><p>Set<String>aSet=Set.of(“nihao”, “我好”, “大家好”);//set集合不能添加重复元素</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>1、Map<K, V>   k：键的类型，V：值得类型（一个键对应一个值）</p><p>2、put可以将映射的键和值相对性，即添加方法，当第一次添加一个键时是添加操作，同一个键再次赋值即为修改操作</p><h3 id="基本功能方法"><a href="#基本功能方法" class="headerlink" title="基本功能方法"></a>基本功能方法</h3><p>1、put方法添加元素</p><p>2、remove方法删除元素//（指定的key键），返回对应的V值</p><p>3、clear移除所有键值对元素</p><p>4、containsKey判断集合是否包含所指定的键</p><p>5、containsVaiue判断集合是否包含指定的值</p><p>6、isEmpty判断集合是否为空</p><p>7、size集合长度，也就是集合中键值对应的个数</p><h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><p>1、V get 根据键获取返回值</p><p>2、Set <K>keySet()  获取所有键的集合//Set<String> aMap2=aMap.keySet();</p><p>3、Collection<V>values<K,V>enterSet()获取所有键值对象的集合</p><p>//Collection<String>aCollection=aMap.values();</p><ul><li><ul><li>| <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code> | <code>entrySet()</code>  返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。 |<br>| ——————————- | —————————————————————————————— |<br>|                       |                                                              |</li></ul></li></ul><h3 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h3><p>1、方法一(获取所有的键集合，遍历键集合中每个键对应的值)</p><pre><code>Map&lt;String, String&gt; aMap = new HashMap&lt;String, String&gt;();    //创建Map集合    aMap.put(&quot;zxq&quot;, &quot;180&quot;);    aMap.put(&quot;zwq&quot;, &quot;125&quot;);    aMap.put(&quot;z6q&quot;, &quot;198&quot;);    aMap.put(&quot;zxsdq&quot;, &quot;1870&quot;);    //添加元素    Set&lt;String&gt; aMap2 = aMap.keySet();    //获取所有键的集合    for (String string : aMap2) &#123;        //增强for根据键去找值，用get（object key）方法实现        String value = aMap.get(string);        System.out.println(string+&quot;=&quot;+value);    &#125;</code></pre><p>结果：</p><p>zxq=180<br>z6q=198<br>zwq=125<br>zxsdq=1870</p><p>2、方法二（依次获取一对键值对象，分别获取键和值）</p><pre><code>Map&lt;String, String&gt; aMap = new HashMap&lt;String, String&gt;();    //创建Map集合    aMap.put(&quot;zxq&quot;, &quot;180&quot;);    aMap.put(&quot;zwq&quot;, &quot;125&quot;);    aMap.put(&quot;z6q&quot;, &quot;198&quot;);    aMap.put(&quot;zxsdq&quot;, &quot;1870&quot;);    //添加元素    Set&lt;Map.Entry&lt;String, String&gt;&gt;aSet=aMap.entrySet();    //遍历键值对对象的集合，得到每一个键值对对象    for (Map.Entry&lt;String, String&gt; map : aSet) &#123;        //根据键值对对象获取键和值        String key=map.getKey();        String value=map.getValue();        System.out.println(key+&quot;=&quot;+value);    &#125;</code></pre><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="File类的概述和构造方法"><a href="#File类的概述和构造方法" class="headerlink" title="File类的概述和构造方法"></a>File类的概述和构造方法</h3><p>File：它是文件和目录路径名的抽象表示</p><p>1、文件和目录是可以通过file封装成对象的</p><p>2、对于File而言，器封装的 并不一定是一个真正存在的文件，仅仅是一个路径名而已，可以是存在的，也可以是不存在的</p><p>将来是要通过具体的操作把这个路径的内容转换为具体存在的</p><p>File  af1=new File(“C:\java.txt”);//将指定的路径名字转换为抽象路径名来创建新的File实现</p><h3 id="File类的创建"><a href="#File类的创建" class="headerlink" title="File类的创建"></a>File类的创建</h3><ul><li><ul><li>| <code>boolean</code> | <code>createNewFile()</code>  当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件。 |<br>| ————- | —————————————————————————————— |<br>|           |                                                              |</li></ul></li><li><ul><li><p>| <code>boolean</code> | <code>mkdir()</code>  创建由此抽象路径名命名的目录。                    |<br>| ————- | —————————————————————————————— |<br>| <code>boolean</code> | <code>mkdirs()</code>  创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。 |</p><p>​        File  af1=new File(“D:\itcast\java.txt”);<br>​        System.out.println(af1.createNewFile());//创建空文件<br>​        File aFile=new File(“D:\\itcast\\javaSE”);<br>​        System.out.println(aFile.mkdir());//创建目录<br>​        File bFile=new File(“D:\\itcast\\javaSE\HTML”);<br>​        System.out.println(bFile.mkdir());//<br>​        File cFile=new File(“D:\\itcast\\javaWeb\HTML”);<br>​        System.out.println(cFile.mkdirs());//创建多级目录</p></li></ul></li></ul><p>注意：不能根据文件名称判断创建的是文件还是目录，需要根据调用方法来判断</p><h3 id="File类的删除功能"><a href="#File类的删除功能" class="headerlink" title="File类的删除功能"></a>File类的删除功能</h3><ul><li><ul><li>| <code>boolean</code> | <code>delete()</code>  删除由此抽象路径名表示的文件或目录。 |<br>| ————- | ———————————————————————— |<br>|           |                                                  |</li></ul></li></ul><p>删除目录需要先删除当前目录下的文件</p><h3 id="File类的判断和获取功能"><a href="#File类的判断和获取功能" class="headerlink" title="File类的判断和获取功能"></a>File类的判断和获取功能</h3><p>​        File file=new File(“D:\itcast\java.txt”);<br>​        //isDirectory()判断是否为目录<br>​        System.out.println(file.isDirectory());<br>​        //isFile()判断是否为文件<br>​        System.out.println(file.isFile());<br>​        //exists()判断是否存在<br>​        System.out.println(file.exists());<br>​        //获取文件的绝对路径<br>​        System.out.println(file.getAbsolutePath());<br>​        //将此抽象类的路径名转换为字符串<br>​        System.out.println(file.getPath());<br>​        //返回次抽象路径名表示的文件或者名称<br>​        System.out.println(file.getName());</p><hr><p>​        File aFile = new File(“D:\itcast”);<br>​        // String [] list();此方法有局限，获取目录中的文件和目录名称<br>​        String[] aStrings = aFile.list();<br>​        for (String string : aStrings) {<br>​            System.out.println(string);<br>​        }<br>​        // 创建一个File文件对象，在for循环中可以对file进行文件操作，例如判断文件是否存在，输出文件等等<br>​        File[] a = aFile.listFiles();<br>​        for (File file : a) {<br>​            System.out.println(file.getName());<br>​        }</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="1、字节流写数据"><a href="#1、字节流写数据" class="headerlink" title="1、字节流写数据"></a>1、字节流写数据</h3><p>字节流抽象基类：</p><p>inputStream：这个抽象类是表示字节输入流的所有类的超类</p><p>outputStream：这个抽象类是表示字节输出流的所有类的超类</p><p>子类名特点：子类名称都是以其父类作为子类名的后缀</p><p>​            1、创建字节流对象</p><p>​            2、写数据</p><p>​            3、释放资源</p><p>​        FileOutputStream aFileOutputStream = new FileOutputStream(“java.txt”);<br>​        aFileOutputStream.write(97);<br>​        aFileOutputStream.close();</p><ul><li><ul><li><p>| <code>void</code>           | <code>close()</code>  关闭此文件输出流并释放与此流相关联的任何系统资源。 |<br>| ———————— | —————————————————————————————— |<br>| <code>protected void</code> | <code>finalize()</code>  清理与文件的连接，并确保当没有更多的引用此流时，将调用此文件输出流的 <code>close</code>方法。 |<br>| <code>FileChannel</code>    | <code>getChannel()</code>  返回与此文件输出流相关联的唯一的<a href="../../java/nio/channels/FileChannel.html"><code>FileChannel</code></a>对象。 |<br>| <code>FileDescriptor</code> | <code>getFD()</code>  返回与此流相关联的文件描述符。                    |<br>| <code>void</code>           | <code>write(byte[] b)</code>  将 <code>b.length</code>个字节从指定的字节数组写入此文件输出流。 |<br>| <code>void</code>           | <code>write(byte[] b,  int off, int len)</code>  将 <code>len</code>字节从位于偏移量 <code>off</code>的指定字节数组写入此文件输出流。 |<br>| <code>void</code>           | <code>write(int b)</code>  将指定的字节写入此文件输出流。               |</p><pre><code>FileOutputStream aFileOutputStream = new FileOutputStream(&quot;java.txt&quot;);    aFileOutputStream.write(97);    byte []a=&#123;1,2,3&#125;;    aFileOutputStream.write(a);    byte []bs=&quot;12345679&quot;.getBytes();</code></pre><p>//<code>write(byte[] b)</code>  将 <code>b.length</code>个字节从指定的字节数组写入此文件输出流。 </p><pre><code>    aFileOutputStream.write(bs);</code></pre><p>//write(byte[] b,  int off, int len) 将 <code>len</code>字节从位于偏移量 <code>off</code>的指定字节数组写入此文件输出流。</p><pre><code>    aFileOutputStream.write(bs, 0, 5);    aFileOutputStream.close();</code></pre><h3 id="2、字節流写数据存在的问题"><a href="#2、字節流写数据存在的问题" class="headerlink" title="2、字節流写数据存在的问题"></a>2、字節流写数据存在的问题</h3></li></ul></li></ul><p>字节流写数据如何实现换行：</p><p>换行使用  :\n</p><p>字节流写数据如何追加写入：</p><p>追加在创建对象时对append属性：true</p><p>​    FileOutputStream aFileOutputStream = new FileOutputStream(“java.txt”, true);<br>​        for (int i = 0; i &lt; 10; i++) {<br>​            aFileOutputStream.write(“i”.getBytes());<br>​            aFileOutputStream.write(“\n”.getBytes());<br>​        }</p><h3 id="3、字节流写数据加异常处理"><a href="#3、字节流写数据加异常处理" class="headerlink" title="3、字节流写数据加异常处理"></a>3、字节流写数据加异常处理</h3><p>FileOutputStream aFileOutputStream = null;<br>        try {<br>            aFileOutputStream = new FileOutputStream(“java.txt”, true);<br>            aFileOutputStream.write(“i”.getBytes());<br>            aFileOutputStream.write(“\n”.getBytes());<br>        } catch (IOException e1) {<br>            // TODO 自动生成的 catch 块<br>            e1.printStackTrace();<br>        } finally {<br>            try {<br>                aFileOutputStream.close();<br>            } catch (IOException e) {<br>                // TODO 自动生成的 catch 块<br>                e.printStackTrace();<br>            }</p><h3 id="4、字节流读数据（一个一个读）"><a href="#4、字节流读数据（一个一个读）" class="headerlink" title="4、字节流读数据（一个一个读）"></a>4、字节流读数据（一个一个读）</h3><p>FileInputStream aFileInputStream=new FileInputStream(“java.txt”);<br>//一个一个读<br>//        int by=    aFileInputStream.read();<br>//        System.out.println(by);<br>//        System.out.println((char)by);<br>//        aFileInputStream.close();<br>            int by;<br>            while((by=aFileInputStream.read())!=-1){<br>            System.out.print((char)by);<br>        }</p><p>采用的是 int read()方法，当没有元素时返回的是-1，所以-1作为判断条件。</p><h3 id="从一个文本读数据写到另一个文本案例"><a href="#从一个文本读数据写到另一个文本案例" class="headerlink" title="从一个文本读数据写到另一个文本案例"></a>从一个文本读数据写到另一个文本案例</h3><p>1、打开源文件</p><p>2、遍历源文件</p><p>3、打开目标文件，将原文件中的数据写到目标文件中</p><p>4、关闭目标文件</p><p>5、关闭源文件</p><p>FileInputStream aFileInputStream=new FileInputStream(“D:\txt.txt”);<br>        int by;<br>        while ((by=aFileInputStream.read())!=-1) {<br>            FileOutputStream aFileOutputStream=new FileOutputStream(“java.txt”,true);<br>            System.out.print((char)by);<br>            aFileOutputStream.write(by);<br>            aFileOutputStream.close();<br>        }<br>        aFileInputStream.close();</p><h3 id="字节流读数据一次都一个数组"><a href="#字节流读数据一次都一个数组" class="headerlink" title="字节流读数据一次都一个数组"></a>字节流读数据一次都一个数组</h3><p>//        FileInputStream aFileInputStream=new FileInputStream(“java.txt”);<br>//        byte []bys=new byte[10];<br>//        //第一次读取<br>//        int len=aFileInputStream.read(bys);<br>//        System.out.println(len);<br>//        System.out.println(new String(bys, 0, len));<br>//        //第二次读取<br>//        len=aFileInputStream.read(bys);<br>//        System.out.println(len);<br>//        System.out.println(new String(bys, 0, len));<br>//        aFileInputStream.close();<br>//        //第三次读取<br>//        len=aFileInputStream.read(bys);<br>//        System.out.println(len);<br>//        System.out.println(new String(bys, 0, len));<br>//        aFileInputStream.close();<br>        FileInputStream aFileInputStream=new FileInputStream(“java.txt”);<br>        byte []bys=new byte[1024];<br>        int len;<br>        while((len=aFileInputStream.read(bys))!=-1) {<br>            System.out.print(new String(bys, 0, len));<br>        }</p><h3 id="字节流复制图片"><a href="#字节流复制图片" class="headerlink" title="字节流复制图片"></a>字节流复制图片</h3><pre><code>FileInputStream aFileInputStream=new                    FileInputStream(&quot;C:\\Users\\22603\\Pictures\\Saved Pictures\\2.png&quot;);//实例化源文件路径FileOutputStream aFileOutputStream=new FileOutputStream(&quot;DLA.png&quot;);//实例化目标文件路径    int len;//定义字节长度    byte[]bys=new byte[1024];//定义字节数组    while((len=aFileInputStream.read())!=-1) &#123;//判断条件，当字节长度为-1说明到达文件结尾        aFileOutputStream.write(bys,0,len);    &#125;    aFileInputStream.close();    aFileOutputStream.close();//关闭文件</code></pre><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>BufferOutputStream：该类实现缓冲输出流。通过设置这样的缓冲输出流，应用程序可以向底层输出流写入字节，而不必为写的的每一个字节导致底层系统的调用</p><p>BufferInputStream：创建该类将创造一个内部缓冲区数组，当从流中读取或跳过字节时，内部缓冲区，将根据所需要从包含的输入流中重新填充，一次很多字节。</p><pre><code>BufferedOutputStream aBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;text1.txt&quot;));    aBufferedOutputStream.write(&quot;nihaoa&quot;.getBytes());    // Input读文件    BufferedInputStream aBufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;text1.txt&quot;));    int len;    byte[] a = new byte[1024];    while ((len = aBufferedInputStream.read(a)) != -1) &#123;        System.out.println(new String(a, 0, len));    &#125;    aBufferedOutputStream.close();    aBufferedInputStream.close();</code></pre><p><strong>字节文件（读入，写出）</strong></p><h3 id="字节流读写视频"><a href="#字节流读写视频" class="headerlink" title="字节流读写视频"></a>字节流读写视频</h3><pre><code>import java.io.*;import javax.imageio.stream.FileImageInputStream;public class DemoMain7 &#123;    public static void main(String[] args) throws IOException &#123;        // TODO 自动生成的方法存根        long start=System.currentTimeMillis();        method1();  4//        method2();  2 //        method3();  3//        method4();//耗时最少  1        long endTime=System.currentTimeMillis();        System.out.println(&quot;共用时:&quot;+(endTime-start)+&quot;毫秒&quot;);    &#125;    public static void method1() throws IOException &#123;        //基本字节流一次写一个字节        FileInputStream aFileInputStream=new FileInputStream(&quot;C:\\Users\\22603\\Music\\MV\\1.mp4&quot;);        FileOutputStream aFileOutputStream=new FileOutputStream(&quot;音乐.mp4&quot;);        int by;        while ((by=aFileInputStream.read())!=-1) &#123;            aFileOutputStream.write(by);        &#125;    aFileInputStream.close();    aFileOutputStream.close();&#125;public static void method2() throws IOException &#123;    //基本字节流一次读一个字节数组    FileInputStream aFileInputStream=new FileInputStream(&quot;C:\\Users\\22603\\Music\\MV\\1.mp4&quot;);    FileOutputStream aFileOutputStream=new FileOutputStream(&quot;音乐.mp4&quot;);    byte []a=new byte[1024];    int len;    while ((len=aFileInputStream.read(a))!=-1) &#123;        aFileOutputStream.write(a,0,len);    &#125;    aFileInputStream.close();    aFileOutputStream.close();&#125;public static void method3() throws IOException &#123;    //字节缓冲流一次读一个字节    BufferedInputStream aBufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;C:\\\\Users\\\\22603\\\\Music\\\\MV\\\\1.mp4&quot;));    // Input读文件    BufferedOutputStream aBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;音乐.mp4&quot;));    int by;    while ((by=aBufferedInputStream.read())!=-1) &#123;        aBufferedOutputStream.write(by);    &#125;    aBufferedInputStream.close();    aBufferedOutputStream.close();&#125;public static void method4() throws IOException &#123;    //字节缓冲流一次读一个字节数组    BufferedInputStream aBufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;C:\\\\Users\\\\22603\\\\Music\\\\MV\\\\1.mp4&quot;));    // Input读文件    BufferedOutputStream aBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;音乐.mp4&quot;));    int len;    byte[] a = new byte[1024];    while ((len = aBufferedInputStream.read(a)) != -1) &#123;        System.out.println(new String(a, 0, len));    &#125;    aBufferedOutputStream.close();    aBufferedInputStream.close();    &#125;&#125;</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符流写数据、读数据（读写编码需要对应）"><a href="#字符流写数据、读数据（读写编码需要对应）" class="headerlink" title="字符流写数据、读数据（读写编码需要对应）"></a>字符流写数据、读数据（读写编码需要对应）</h3><ul><li><ul><li>| <code>OutputStreamWriter(OutputStream out)</code>  创建一个使用默认字符编码的OutputStreamWriter。 |<br>| —————————————————————————————— |<br>| <code>OutputStreamWriter(OutputStream out, Charset cs)</code>  创建一个使用给定字符集的OutputStreamWriter。 |</li></ul></li><li><ul><li><p>| <code>InputStreamReader(InputStream in)</code>  创建一个使用默认字符集的InputStreamReader。 |<br>| —————————————————————————————— |<br>| <code>InputStreamReader(InputStream in, Charset cs)</code>  创建一个使用给定字符集的InputStreamReader。 |<br>| <code>InputStreamReader(InputStream in, CharsetDecoder dec)</code>  创建一个使用给定字符集解码器的InputStreamReader。 |<br>| <code>InputStreamReader(InputStream in, String charsetName)</code>  创建一个使用命名字符集的InputStreamReader。 |</p><p>//        OutputStreamWriter(OutputStream out)<br>//        创建一个使用默认字符编码的OutputStreamWriter。<br>//        OutputStreamWriter(OutputStream out, Charset cs)<br>//        创建一个使用给定字符集的OutputStreamWriter。  </p><pre><code>    OutputStreamWriter aFileOutputStream=new OutputStreamWriter(            new FileOutputStream(&quot;test.txt&quot;),&quot;utf-8&quot;);    aFileOutputStream.write(&quot;测试文件&quot;);    aFileOutputStream.close();</code></pre><p>//        InputStreamReader(InputStream in)<br>//        创建一个使用默认字符集的InputStreamReader。<br>//        InputStreamReader(InputStream in, String charsetName)<br>//        创建一个使用命名字符集的InputStreamReader。  </p><pre><code>    InputStreamReader aInputStreamReader=new             InputStreamReader(new FileInputStream(&quot;test.txt&quot;),&quot;utf-8&quot;);    int by;    while ((by=aInputStreamReader.read())!=-1) &#123;        System.out.print((char)by);    &#125;    aInputStreamReader.close();</code></pre></li></ul></li></ul><p>字符流写数据、读数据</p><h3 id="close和flush区别"><a href="#close和flush区别" class="headerlink" title="close和flush区别"></a>close和flush区别</h3><ul><li><ul><li>| <code>void</code> | <code>close()</code>  关闭流，先刷新。 |<br>| ——— | —————————————- |<br>| <code>void</code> | <code>flush()</code>  刷新流。         |</li></ul></li></ul><p>使用close后无法写数据，使用flush后还可以写数据。</p><p>OutputStreamWriter aFileOutputStream=new OutputStreamWriter(<br>                new FileOutputStream(“test1.txt”),”utf-8”);<br>        aFileOutputStream.write(97);<br>        //aFileOutputStream.flush();<br>        aFileOutputStream.write(97);<br>        //aFileOutputStream.flush();<br>        aFileOutputStream.close();</p><h3 id="字符流写数据的五种方法"><a href="#字符流写数据的五种方法" class="headerlink" title="字符流写数据的五种方法"></a>字符流写数据的五种方法</h3><p>OutputStreamWriter aFileOutputStream=new OutputStreamWriter(<br>                new FileOutputStream(“test1.txt”),”utf-8”);</p><p>1、一次写一个字符    </p><p>​        aFileOutputStream.write(97);<br>​        //aFileOutputStream.flush();<br>​        aFileOutputStream.write(97);<br>​        //aFileOutputStream.flush();<br>​        aFileOutputStream.close();</p><p>2、一次写一个字符数组</p><p>​        char a[]={‘f’,’f’,’f’,’f’,’f’,’f’,’f’,’f’};<br>​        aFileOutputStream.write(a);<br>​        aFileOutputStream.close();</p><p>3、一次写一字符数组部分数据</p><p> 调用的是 void write(cbuf, off, len);  </p><pre><code>    char a[]=&#123;&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;&#125;;        aFileOutputStream.write(a, 1, 3);        aFileOutputStream.close();</code></pre><p>4、一次写一个字符串</p><p>​        aFileOutputStream.write(“acdac”);<br>​        aFileOutputStream.close();</p><p>5、一次写字符串的一部分</p><pre><code>    aFileOutputStream.write(&quot;acdac&quot;, 1, 3);    aFileOutputStream.close();</code></pre><p>aFileOutputStream.close();</p><h3 id="字符流读数据的两种方法"><a href="#字符流读数据的两种方法" class="headerlink" title="字符流读数据的两种方法"></a>字符流读数据的两种方法</h3><p>InputStreamReader aStreamReader=new<br>InputStreamReader(new FileInputStream(“test1.txt”));</p><p>1、一次读一个字符</p><p>​    int by;<br>​        while ((by=aStreamReader.read())!=-1) {<br>​            System.out.println((char)by);<br>​        }</p><p>2、一次读一个字符数组</p><p>​    char []a=new char[1024];<br>​        int len;<br>​        while ((len=aStreamReader.read(a))!=-1) {<br>​            System.out.print(new String(a,0,len));<br>​        }</p><p>aStreamReader.close();</p><h2 id="读写文件最简单的方法"><a href="#读写文件最简单的方法" class="headerlink" title="读写文件最简单的方法"></a>读写文件最简单的方法</h2><p>​        FileWriter aFileWriter=new FileWriter(“test1.txt”);<br>​        FileReader aFileReader=new FileReader(“test1.txt”);</p><p><strong>FileWriter 和 FileReader 分别是OutputStreamWriter 和 InputStreamReader 的子类。但不可以转换编码，如需转换编码仍需要用父类</strong></p><h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p>BufferedReader aaReader=new BufferedReader(new FileReader(“test1.txt”));<br>BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(“test1.txt”));</p><p>特有方法：</p><p>1、 BufferedReader aaReader=new BufferedReader(new FileReader(“test1.txt”));<br>        String line;<br>        while ((line=aaReader.readLine())!=null) {//readLine读取一行的数据，不读取换行符<br>            System.out.println(line);<br>        }<br>        aaReader.close();</p><p>2、  BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(“test1.txt”));<br>        aBufferedWriter.write(“nihao”);<br>        aBufferedWriter.newLine();//换行符<br>        aBufferedWriter.close();</p><h3 id="字符缓冲流特有功能复制文件（最常用）"><a href="#字符缓冲流特有功能复制文件（最常用）" class="headerlink" title="字符缓冲流特有功能复制文件（最常用）"></a>字符缓冲流特有功能复制文件（最常用）</h3><p>​        BufferedReader aBufferedReader=new BufferedReader(new FileReader(“test1.txt”));<br>​        BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(“test2.txt”));<br>​        String line;<br>​        while ((line=aBufferedReader.readLine())!=null) {<br>​            aBufferedWriter.write(line);<br>​            aBufferedWriter.newLine();<br>​            aBufferedWriter.flush();<br>​        }<br>​        aBufferedReader.close();<br>​        aBufferedWriter.close();</p><h3 id="io流小结"><a href="#io流小结" class="headerlink" title="io流小结"></a>io流小结</h3><p><img src="E:\sql学习资料\~8RDVBOGIK7N8S4IUX8E_P2.png" alt="img"></p><p><img src="E:\sql学习资料\1.png" alt="img"></p><h3 id="集合到文件"><a href="#集合到文件" class="headerlink" title="集合到文件"></a>集合到文件</h3><p>​        ArrayList<String> arrayList = new ArrayList<String>();<br>​        arrayList.add(“nihao”);<br>​        arrayList.add(“wohao”);<br>​        arrayList.add(“dajiahao”);<br>​        BufferedWriter aBufferedWriter = new BufferedWriter(new FileWriter(“test3.txt”));<br>​        for (String string : arrayList) {<br>​            aBufferedWriter.write(string);<br>​            aBufferedWriter.newLine();<br>​            aBufferedWriter.flush();<br>​        }<br>​        aBufferedWriter.close();</p><h3 id="文件到集合"><a href="#文件到集合" class="headerlink" title="文件到集合"></a>文件到集合</h3><p>​        BufferedReader aBufferedReader = new BufferedReader(new FileReader(“test3.txt”));<br>​        ArrayList<String> arrayList = new ArrayList&lt;&gt;();<br>​        String line;<br>​        while ((line = aBufferedReader.readLine()) != null) {<br>​            arrayList.add(line);<br>​        }<br>​        aBufferedReader.close();<br>​        for (String string : arrayList) {<br>​            System.out.println(string);<br>​        }</p><h3 id="点名器"><a href="#点名器" class="headerlink" title="点名器"></a>点名器</h3><pre><code>    ArrayList&lt;Student&gt;arrayList=new ArrayList&lt;&gt;();        BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(&quot;test4.txt&quot;));        Student a1=new Student(&quot;1001&quot;,&quot;zxq&quot;,&quot;18&quot;,&quot;xians&quot;);        Student a2=new Student(&quot;1002&quot;,&quot;sss&quot;,&quot;18&quot;,&quot;xianan&quot;);        Student a3=new Student(&quot;1003&quot;,&quot;sff&quot;,&quot;18&quot;,&quot;xianss&quot;);        Student a4=new Student(&quot;1004&quot;,&quot;www&quot;,&quot;18&quot;,&quot;xiandf&quot;);        arrayList.add(a1);        arrayList.add(a2);        arrayList.add(a3);        arrayList.add(a4);        for (Student student : arrayList) &#123;            StringBuffer stringBuffer=new StringBuffer();            stringBuffer.append(student.getName()).append(&quot;,&quot;).append(student.getAge()).append(&quot;,&quot;).            append(student.getAddress());            aBufferedWriter.write(stringBuffer.toString());            aBufferedWriter.newLine();            aBufferedWriter.flush();        &#125;    aBufferedWriter.close();</code></pre><h3 id="复制单级文件夹"><a href="#复制单级文件夹" class="headerlink" title="复制单级文件夹"></a>复制单级文件夹</h3><pre><code>package Demo3;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import javax.swing.text.DefaultEditorKit.CopyAction;//TODO 自动生成的方法存根        //1、创建数据源目录File对象 ，路径为C:\Users\22603\Pictures\Saved Pictures        //2、获取数据源目录File对象的名称，即文件所保存的外层文件夹，Saved Pictures        //3、创建目的地目录File对象，路径名是File+Saved Pictures        //4、判断目的地目录对应的File是否存在，如果不存在，就创建        //5、获得数据源目录下所有文件的File数组        //6、遍历File数组，得到每一个File对象，其实就是数据源文件        //7、获得数据源文件File对象的，名称        //8、创建目的地文件File对象，路径名是目的地目录File\\Saved Pictures\\+.png        //9、复制文件，采用字节流public class DemoMain1 &#123;public static void main(String[] args) throws IOException &#123;    //1、创建数据源目录File对象 ，路径为C:\\pecsa    File srcFind=new File(&quot;C:\\pecsa&quot;);    //2、获取数据源目录File对象的名称，即文件所保存的外层文件夹，pecsa    String aString=srcFind.getName();    //3、创建目的地目录File对象，路径名是File+Saved Pictures    File Creade=new File(&quot;File&quot;,aString);    //4、判断目的地目录对应的File是否存在，如果不存在，就创建    if (!Creade.exists()) &#123;        Creade.mkdir();    &#125;    //5、获得数据源目录下所有文件的File数组    File[]list=srcFind.listFiles();    //6、遍历File数组，得到每一个File对象，其实就是数据源文件    for (File file : list) &#123;    //7、获得目录下的每个文件名    String srcFileName=file.getName();    //8、创建目的地文件File对象，路径名是目的地目录File\\Saved Pictures\\+.png    File destFile=new File(Creade,srcFileName);    //9、复制文件，采用字节流，这里的File是源文件名，destFile是新创建的文件对象    CopyFile(file,destFile);    &#125;    &#125;private static void CopyFile(File file, File destFile) throws IOException &#123;    // TODO 自动生成的方法存根    BufferedOutputStream aBufferedOutputStream=new BufferedOutputStream(new FileOutputStream(destFile));    BufferedInputStream aBufferedInputStream=new BufferedInputStream(new FileInputStream(file));    byte a[]=new byte[1024];    int len;    while((len=aBufferedInputStream.read(a))!=-1) &#123;        aBufferedOutputStream.write(a,0,len);    &#125;    aBufferedOutputStream.close();    aBufferedInputStream.close();    &#125;    &#125;</code></pre><h2 id="复制多级文件（用到时回头看）"><a href="#复制多级文件（用到时回头看）" class="headerlink" title="复制多级文件（用到时回头看）"></a>复制多级文件（用到时回头看）</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><p>​    进程是正在运行的程序，是系统进行资源分配和调用的独立单位</p><p>​    每个进程都有他自己的内存空间和系统资源</p><h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>​    线程是进程的单个顺序控制流，是一条执行路径</p><p>单线程：一个进程如果只有一条执行路径，则称为单线程程序</p><p>多线程：一个进程如果有多个执行路径，则成为多线程程序</p><p>举例：记事本程序（单线程）</p><p>​            扫雷程序（多线程）</p><h3 id="3、多线程的实现方式"><a href="#3、多线程的实现方式" class="headerlink" title="3、多线程的实现方式"></a>3、多线程的实现方式</h3><p>（方式1）：继承Thread类</p><p>​                定义一个类继承Thread类，并重写该类中的run方法，创建多个对象，调用start方法执行多线程44</p><h3 id="4、设置和获取线程名称"><a href="#4、设置和获取线程名称" class="headerlink" title="4、设置和获取线程名称"></a>4、设置和获取线程名称</h3><p>底层远吗中默认有getName和setName方法，为了简化我们可以在创建子类对象时传进去name，即有参构造方法</p><p>Thread(String name) 分配一个新的 Thread对象。 </p><p>static Thread currentThread() 返回对当前正在执行的线程对象的引用。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MyThread a1=new MyThread(&quot;线程1&quot;);</span><br><span class="line">MyThread a2=new MyThread(&quot;线程2&quot;);</span><br><span class="line">a1.setName(&quot;线程1&quot;);</span><br><span class="line">a2.setName(&quot;线程2&quot;);</span><br><span class="line">a1.start();</span><br><span class="line">a2.start();</span><br><span class="line">System.out.println(Thread.currentThread().getName());//获取正在执行的线程对象的引用</span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">public MyThread(String name) &#123;</span><br><span class="line">// TODO 自动生成的构造函数存根</span><br><span class="line">super(name);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">for (int i = 0; i &lt; 600; i++) &#123;</span><br><span class="line">System.out.println(getName()+&quot;：&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、线程调度"><a href="#5、线程调度" class="headerlink" title="5、线程调度"></a>5、线程调度</h3><p><strong>分配调度模型</strong>：所有线程轮流使用cpu的权，平均分配每个线程占用cpu的时间片</p><p><strong>抢占式调度模型</strong>：优先让优先级搞得线程使用cpu，如果线程优先级相同，随机选择一个，优先级高的线程获取cpu的时间相对多一点</p><p>java使用的是抢占式调度模型</p><p>//int getPriority() 返回此线程的优先级。 （线程优先级最高为10,最低为1，默认为5）<br>//void setPriority(int newPriority) 更改此线程的优先级。  </p><pre><code>    MyThread a1=new MyThread(&quot;线程1&quot;);    MyThread a2=new MyThread(&quot;线程2&quot;);    a1.setPriority(10);    a2.setPriority(1);</code></pre><p>改变线程优先级是优先级高的表示获取cpu时间片的几率高一点，并不是彻底改变优先级次序</p><h3 id="6、线程控制"><a href="#6、线程控制" class="headerlink" title="6、线程控制"></a>6、线程控制</h3><p>（1）<strong>//static void sleep(long millis)</strong> 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。  </p><p>public void run() {<br>        // TODO 自动生成的方法存根<br>        for (int i = 0; i &lt; 600; i++) {<br>            System.out.println(getName()+”：”+i);<br>        }<br>        try {<br>            //static void sleep(long millis) 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）<br>            //，具体取决于系统定时器和调度程序的精度和准确性。<br>            Thread.sleep(10);<br>        } catch (InterruptedException e) {<br>            // TODO 自动生成的 catch 块<br>            e.printStackTrace();<br>        }<br>    }</p><p>（2）<strong>//void join() 等待这个线程死亡。</strong>  </p><p>​        Test a1=new Test(“刘备”);<br>​        Test a2=new Test(“孙权”);<br>​        Test a3=new Test(“曹操”);<br>​        //void join() 等待这个线程死亡。<br>​        a1.start();<br>​        //这里的意思是等刘备死后孙权和曹操抢占cup时间<br>​        a1.join();<br>​        a2.start();<br>​        a3.start();</p><p><strong>（3）//void setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。</strong>  </p><pre><code>Test a1=new Test(&quot;刘备&quot;);    Test a2=new Test(&quot;张飞&quot;);    Thread.currentThread().setName(&quot;关羽&quot;);//为当前main线程重新命名    //void setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。即主线程死亡后守卫线程也灭亡    //设置守护线程    a1.setDaemon(true);    a2.setDaemon(true);    a1.start();    a2.start();    for (int i = 0; i &lt; 100; i++) &#123;        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);    &#125;    **ps：主线程灭亡后，守卫不会立马死亡，会挣扎运行一段时间**</code></pre><p><strong>ps：主线程灭亡后，守卫不会立马死亡，会挣扎运行一段时间</strong></p><h3 id="7、另一种多线程实现方式-实现Runnable接口"><a href="#7、另一种多线程实现方式-实现Runnable接口" class="headerlink" title="7、另一种多线程实现方式(实现Runnable接口)"></a>7、另一种多线程实现方式(实现Runnable接口)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package bb;</span><br><span class="line"></span><br><span class="line">public class Test implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(i);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">// TODO 自动生成的 catch 块</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread aThread=new Thread(new Test(),&quot;zxq&quot;);</span><br><span class="line">Thread bThread=new Thread(new Test());</span><br><span class="line">//aThread.setName(&quot;zxq&quot;);</span><br><span class="line">bThread.setName(&quot;sss&quot;);</span><br><span class="line">aThread.setPriority(10);</span><br><span class="line">bThread.setPriority(1);</span><br><span class="line">aThread.start();</span><br><span class="line">//aThread.join();</span><br><span class="line">bThread.start();</span><br></pre></td></tr></table></figure><p>相比继承Thread类，实现Runnable接口的好处:</p><p>1、避免了java单继承的局限性</p><p>2、适合多个相同程序的代码去处理同一个资源的情况，吧线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p><h3 id="8、数据安全问题"><a href="#8、数据安全问题" class="headerlink" title="8、数据安全问题"></a>8、数据安全问题</h3><p><strong>是否是多线程环境</strong></p><p><strong>是否有共享数据</strong></p><p><strong>是否有多条语句操作共享数据</strong></p><h3 id="9、线程同步代码块"><a href="#9、线程同步代码块" class="headerlink" title="9、线程同步代码块"></a>9、线程同步代码块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package Sell;</span><br><span class="line"></span><br><span class="line">public class SellTacket implements Runnable &#123;</span><br><span class="line">private static int tacket = 1000;</span><br><span class="line">Object obj = new Object();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">while (true) &#123;</span><br><span class="line">synchronized (&quot;&quot;) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (tacket &gt; 0) &#123;</span><br><span class="line">Thread.sleep(20);</span><br><span class="line">System.out.println(&quot;剩余票是为:&quot; + tacket+&quot;购票成功,购票地点为:&quot; + Thread.currentThread().getName());</span><br><span class="line">tacket--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (InterruptedException e) &#123;</span><br><span class="line">// TODO 自动生成的 catch 块</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、同步方法"><a href="#10、同步方法" class="headerlink" title="10、同步方法"></a>10、同步方法</h3><p>把synchronized关键字加到方法上</p><p>修饰符 synchronized 返回值类型 方法名(方法参数){ }</p><p>同步方法的锁对象是什么?</p><p>this</p><p>同步静态方法：就是把synchronized关键字加到静态方法上</p><p>同步静态方法的锁对象是什么?</p><p>类名.class</p><h3 id="11、线程安全的类"><a href="#11、线程安全的类" class="headerlink" title="11、线程安全的类"></a>11、线程安全的类</h3><p>（1）StringBuffer从jdk5开始被stringBuilder替代，通常应使用stringBuilder类</p><p>（2）vector从java2平台V1.2开始，该类改进了list接口，如果不需要线程安全的实现，建议使用arraylist替代vector</p><p>（3）Hashtable</p><p>实现了哈希表，如果不需要线程安全的实现，建议使用Hashmap替代Hashtable</p><p>12、</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>1、枚举是一种特殊的类，一般用来表示常量。</p><p>2、Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p><p>3、每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。</p><p>4、枚举既可以单独写一个类，也可以在已经定义的类中写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DemoMain1 &#123;</span><br><span class="line">enum color&#123;</span><br><span class="line">Red,Green,Blue;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">color aColor=color.Red;</span><br><span class="line">System.out.println(aColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等同于:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DemoMain1 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO 自动生成的方法存根</span><br><span class="line">color aColor=color.Red;</span><br><span class="line">System.out.println(aColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">enum color&#123;</span><br><span class="line">Red,Green,Blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、迭代枚举元素</p><p>for (color c : color.values()) {<br>            System.out.println(c);<br>        }</p><p>6、values(), ordinal() 和 valueOf() 方法</p><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p><p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p><ul><li><p>values() 返回枚举类中所有的值。</p></li><li><p>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</p></li><li><p>valueOf()方法返回指定字符串值的枚举常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">color aColor=color.Red;</span><br><span class="line">System.out.println(aColor);</span><br><span class="line">for (color c : color.values()) &#123;</span><br><span class="line">System.out.println(c+&quot; &quot;+c.ordinal());//ordinal返回索引下标</span><br><span class="line">System.out.println(c.valueOf(&quot;Red&quot;));//返回指定字符串值的枚举常量</span><br><span class="line">&#125;</span><br><span class="line">enum&#123;</span><br><span class="line">Red,Green,Blue;</span><br><span class="line">private color()&#123;</span><br><span class="line">System.out.println(this.toString());</span><br><span class="line">&#125;</span><br><span class="line"> public void colorInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Universal Color&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>7、枚举类成员</p><p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。</p><p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p><p>构造函数时，创建对象就会调用，遍历枚举类中的所有常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">    RED&#123;</span><br><span class="line">        public String getColor()&#123;//枚举对象实现抽象方法</span><br><span class="line">            return &quot;红色&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GREEN&#123;</span><br><span class="line">        public String getColor()&#123;//枚举对象实现抽象方法</span><br><span class="line">            return &quot;绿色&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLUE&#123;</span><br><span class="line">        public String getColor()&#123;//枚举对象实现抽象方法</span><br><span class="line">            return &quot;蓝色&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public abstract String getColor();//定义抽象方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color c:Color.values())&#123;</span><br><span class="line">            System.out.print(c.getColor() + &quot;、&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
