<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>java基础知识 | keep Study</title><meta name="author" content="小张,2260391948@qq.com"><meta name="copyright" content="小张"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="java基础知识">
<meta property="og:type" content="article">
<meta property="og:title" content="java基础知识">
<meta property="og:url" content="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2021/09/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="keep Study">
<meta property="og:description" content="java基础知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/img/cover.png">
<meta property="article:published_time" content="2021-09-17T02:29:58.000Z">
<meta property="article:modified_time" content="2023-10-12T12:04:21.732Z">
<meta property="article:author" content="小张">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/img/cover.png"><link rel="shortcut icon" href="/./img/favicon.png"><link rel="canonical" href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2021/09/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"该文章创建于","messageNext":"天前,请以最新的文章为准"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java基础知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-12 20:04:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><link href="https://cdn.bootcdn.net/ajax/libs/toastr.js/2.1.4/toastr.min.css" rel="stylesheet"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4185042_s9i9e08l3w.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/global.css"><link rel="stylesheet" href="/css/style.css"><span id="fps"></span><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/xlenco/JS-X@main/pace.js/pace.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-iconzhengli-"></i><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-LINKS"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-aixin"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./img/cover.png')"><nav id="nav"><span id="blog-info"><a href="/" title="keep Study"><span class="site-name">keep Study</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="iconfont icon-sousuo"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:randomPost();"><i class="fa-fw iconfont icon-iconzhengli-"></i><span> 随机访问</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-guidang"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-LINKS"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-aixin"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-17T02:29:58.000Z" title="发表于 2021-09-17 10:29:58">2021-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-12T12:04:21.732Z" title="更新于 2023-10-12 20:04:21">2023-10-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>73分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h1><h2 id="java转义字符"><a href="#java转义字符" class="headerlink" title="java转义字符"></a>java转义字符</h2><p>\t制表位;</p>
<p>\n换行；</p>
<p>\\:一个斜杠</p>
<p>\r：一个回车</p>
<h2 id="java常见错误"><a href="#java常见错误" class="headerlink" title="java常见错误"></a>java常见错误</h2><p><strong>1、找不到文件</strong></p>
<p><strong>2、文件名或类错误</strong></p>
<p><strong>3、缺少分号</strong></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>1、单行注释：//</p>
<p>2、多行注释：/<em>    </em>/</p>
<p>快捷注释：ctrl+shift+c</p>
<h2 id="文档注释："><a href="#文档注释：" class="headerlink" title="文档注释："></a><strong>文档注释：</strong></h2><p>/**</p>
<ul>
<li><p>@author 人名</p>
</li>
<li><p>@version 你好</p>
<p>**/</p>
</li>
</ul>
<h2 id="java代码规范"><a href="#java代码规范" class="headerlink" title="java代码规范"></a>java代码规范</h2><p>1、类，方法的注释，要以javadoc的方式来写</p>
<p>2、非javadoc的注释，往往是给代码的维护者看的</p>
<h2 id="DOS原理："><a href="#DOS原理：" class="headerlink" title="DOS原理："></a>DOS原理：</h2><p>控制台输入指令—&gt;发送给dos系统—&gt;</p>
<p>1、接受指令2、解析指令3、执行指令</p>
<p>—&gt;windows进行执行</p>
<h2 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h2><p>1、查看当前目录下有什么内容：dir    dir d:abc2\test200</p>
<p>2、cd ..\..\ABC\test200 或者  cd  D：abc2\test200</p>
<p>3、cd \  直接跳转到当前最起始目录</p>
<p>4、查看目录下所有内容  ：tree d:</p>
<p>5、清屏：cls</p>
<p>6、创建目录：md marry100</p>
<p>7、删除目录：rd marry100</p>
<p>8、创建文件：echo 填写内容 &gt; 文件名</p>
<p>9、删除文件：del 文件名</p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>double num1=1.1f;<br>    float num=1.1f;<br>    double num2=.52;<br>    System.out.println(num2);<br>    System.out.println(num);</p>
<p><strong>*</strong>2.7近似相等与8.1/3</p>
<p>double c=2.7;<br>    double b=8.1/3;<br>    System.out.println(c);<br>    System.out.println(b);</p>
<p>结果：</p>
<p>2.7<br>2.6999999999999997</p>
<p>解决方案：</p>
<p>if(Math.abs(c-b)&lt;0.001)<br>        System.out.println(“两个数近似相等”);<br>    }</p>
<p>使用Math函数下的abs 进行判断两个数的差值</p>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p>1、字符常量用单引号（’ ‘）括起来的单个字符，例如：char c1=’a‘</p>
<p>2、java中允许使用转义字符’\n’来将其后的字符转变为特殊字符性常量，例如： char c3=’\n’;//‘\n’表示换行符</p>
<p>3、char的本质是一个整数，在输出时，是对应的unicode吗对应的字符</p>
<p>4、、可以直接给char赋一个整数，然后输出时，会按照对应的unicode字符输出</p>
<p>5、char类型是可以i进行运算的，相当于一个整数，因为它都对应有unicode码</p>
<h2 id="字符型本质"><a href="#字符型本质" class="headerlink" title="字符型本质"></a>字符型本质</h2><p>存储：char a-&gt;97-&gt;(二进制)1100001-&gt;进行存储</p>
<p>读取：二进制-&gt;97====-&gt;”a”=-&gt;显示</p>
<h2 id="ASCLL表"><a href="#ASCLL表" class="headerlink" title="ASCLL表"></a>ASCLL表</h2><p>ASCLL表一个字节表示，一共有128个字符，实际上一个字节可以表示256个字符，只有了128个</p>
<h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><p>unicode编码表使用两个字节表示字符，字母和汉字统一都是占两个字节，这样浪费空间（广泛，容易造成资源浪费）</p>
<p><strong>unicode兼容ascll</strong></p>
<h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><p>字母用一个字节，汉字用三个字节（范围大）</p>
<h2 id="gbk"><a href="#gbk" class="headerlink" title="gbk"></a>gbk</h2><p>字母用一个字节，汉字用两个字节（范围小）</p>
<p>gb2312《gbk</p>
<p>49</p>
<h2 id="boolean（布尔类型）"><a href="#boolean（布尔类型）" class="headerlink" title="boolean（布尔类型）"></a>boolean（布尔类型）</h2><p>boolean ispass=true;<br>    if(ispass==true)<br>    {<br>        System.out.println(“两个数近似相等”);</p>
<pre><code>&#125;
else &#123;
    System.out.println(&quot;两个数不相等&quot;);
&#125;
</code></pre><p>结果：两个数近似相等</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>数据类型按精度容量大小排序为：</p>
<p>char-&gt;int-&gt;long-&gt;float-&gt;double-</p>
<p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p>
<p>int a=’c‘   double d=80  都是正确的</p>
<p>​        int n1 = 10;<br>​        float d1 = n1 + 1.1;<br>​        System.out.println(d1);（x）</p>
<p><strong>byte ：-128—127（byte和short、char之间不会像相互转换）</strong></p>
<p>​    byte b1=10;<br>​    int n2=1;<br>​    byte b2=n2;            （X）</p>
<p>如果是变量赋值，判断类型</p>
<p><strong>1、多种类型的数据混合运算时，系统首先自动将所有数据转换成容量大的那种数据，然后再进行计算</strong></p>
<p>2、<strong>byte short char三者不会相互转换</strong></p>
<p>3、<strong>byte 1个字节，1属于  -128-127之间，n2为4个字节，把n2赋值给一个字节的byte类型就会报错</strong> </p>
<p>4、<strong>byte short char他们三者可以计算，在计算时首先转换为int类型</strong></p>
<p>5、<strong>Boolean类型不参与转换</strong></p>
<p> 6、<strong>自动提升原则：表达式结果的类型自动提升为操作数种最大的类型</strong></p>
<p>  7、<strong>强制类型转换过程可能会会造成精度降低或溢出，要格外注意！</strong></p>
<p>​       double q = 2.9;<br>​        System.out.println((int) q);(精度溢出)<br>​        byte w = (byte) n1;<br>​        System.out.println(w);（溢出）</p>
<p>结果:</p>
<p>2<br>-24</p>
<h2 id="基本数据类型和string类型转换"><a href="#基本数据类型和string类型转换" class="headerlink" title="基本数据类型和string类型转换"></a>基本数据类型和string类型转换</h2><p><strong>基本类型转string：</strong></p>
<p>语法：1、将基本类型的值+“ ”即可</p>
<p>​        2、String s2=String.valueOf(100);//对于所有数据类型都适用<br>​                System.out.println(s2);</p>
<p><strong>string类型转基本数据类型：</strong></p>
<p>通过基本类型的包装类调用parseXX方法即可</p>
<p>​       String s5 = “123”;<br>​        int num1 = Integer.parseInt(s5);<br>​        double num2 = Double.parseDouble(s5);<br>​        float num3 = Float.parseFloat(s5);<br>​        long num4 = Long.parseLong(s5);<br>​        byte num5 = Byte.parseByte(s5);<br>​        boolean num6 = Boolean.parseBoolean(s5);<br>​        short num7 = Short.parseShort(s5);<br>​        System.out.println(num1);<br>​        System.out.println(num2);<br>​        System.out.println(num3);<br>​        System.out.println(num4);<br>​        System.out.println(num5);<br>​        System.out.println(num6);</p>
<p>结果：</p>
<p>123<br>123.0<br>123.0<br>123<br>123<br>false<br>123</p>
<h2 id="算术运算符难点"><a href="#算术运算符难点" class="headerlink" title="算术运算符难点"></a>算术运算符难点</h2><p><strong>先加后增：</strong></p>
<p>​       int i = 1;<br>​        i = i++;<br>​        System.out.println(i);</p>
<p>结果：1</p>
<p>先用再加实质：temp=i;i=i+1;i=temp;采用临时变量最后将temp的值重新赋给i；</p>
<p><strong>先增后加：</strong></p>
<pre><code>    int i = 1;
    i = ++i;
    System.out.println(i);
</code></pre><p>结果：2</p>
<p>先加后用实质：i=i++;temp=i;i=temp;</p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>a&amp;b  和 a&amp;&amp;b  a|b 和 a||b意思相同</p>
<p>a^b叫逻辑异或，当ab 不同时，结果为true  ，否则为false</p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>a++      byte  b=2; b+=i -&gt;b=b+i   实质为：b=(byte)(b+i)</p>
<p>java中会有一个类型的强制转换</p>
<h2 id="数组使用注意事项和细节"><a href="#数组使用注意事项和细节" class="headerlink" title="数组使用注意事项和细节"></a>数组使用注意事项和细节</h2><p>1、数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用</p>
<p>2、数组创建后，不进行赋值，有默认值，int 0,shrot 0,byte 0,long 0,float 0,double 0.0,char \u000,boolean false,String null</p>
<p>3、使用数组步骤：1、声明数组并开辟空间，2、给数组各个元素赋值3、使用数组。</p>
<p>4、数组下标从0开始</p>
<p>5、数组下标必须在指定范围内使用，否则会报错</p>
<p><strong>6、数组属于引用类型，数组类型是对象（object）</strong></p>
<p><strong>7、数组在默认情况下是引用传递，赋的值 是地址，赋值方式为引用</strong></p>
<p><strong>ps：int []arr1={1,2,3}; int []arr2=arr1;</strong></p>
<p><strong>是把arr1的地址赋给arr2，arr2的变化会影响arr1</strong></p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>1、<strong>引用传递</strong></p>
<p>对象和数组传递属于引用传递，</p>
<p><strong>main函数中：</strong></p>
<p>​    B b=new B();</p>
<p>​    int []arr={1,2,3};//arr在栈区，数据123在堆区有存放地址</p>
<p>​    b.test(arr);</p>
<p><code>属于栈区部分，调用test()函数后，会重新在栈区新开辟一部分空间</code></p>
<p><code>在新开辟的栈区中，新的数组同样指向arr的地址，在其中修改arr中的数据，会影响main函数中arr数组中的数据</code></p>
<p><strong>代码示例：</strong></p>
<p>public class yinyongchaundi {</p>
<pre><code>public static void main(String[] args) &#123;
    // TODO 自动生成的方法存根
    B b = new B();
    int[] arr = &#123; 1, 2, 3 &#125;;
    b.test100(arr);
    for (int i = 0; i &lt; arr.length; i++) &#123;
        System.out.println(arr[i] + &quot;\t&quot;);
    &#125;
    System.out.println();
&#125;
</code></pre><p>}<br>class B {<br>    public void test100(int[] a) {<br>        a[0] = 200;<br>        for (int i = 0; i &lt; a.length; i++) {<br>            System.out.println(a[i] + “\t”);<br>        }<br>        System.out.println();<br>    }</p>
<p>}</p>
<p>结果：</p>
<p>200<br>2<br>3    </p>
<p>200<br>2<br>3    </p>
<p><strong>示例代码2：</strong></p>
<p>public class yinyongchaundi {</p>
<pre><code>public static void main(String[] args) &#123;

    nihao P=new nihao();
    P.age=18;
    P.name=&quot;zhangxinqi&quot;;
    B b = new B();
    b.print(P);
    System.out.println(&quot;main:p.age=&quot;+P.age+&quot;,p.name=&quot;+P.name);
&#125;
</code></pre><p>}<br>class B {<br>    public void print(nihao a) {<br>        a.age=20;//改变对象P对应的数据<br>        a=null;//将新在栈区开辟的空间中的对象a（实际就是指向P）指向的数据地址置为空，<br>        //但并不影响main原始空间中对象P指向的数据<br>        a =new nihao();<br>        a.name=”lizhihui”;<br>        //同理，new一个新的对象，在堆区新开一个空间用来存储新初始化的值，对象a指向新地址<br>        //与原地址毫无任何关系，初始化后不再使用就会自动回收该新在堆区开辟的空间</p>
<pre><code>&#125;
</code></pre><p>}<br>class nihao{<br>    int age;<br>    String name;<br>}</p>
<p>结果：main:p.age=20,p.name=zhangxinqi</p>
<h2 id="递归调用（迷宫问题，罗汉塔，八个皇后）-p222-p227-老韩java"><a href="#递归调用（迷宫问题，罗汉塔，八个皇后）-p222-p227-老韩java" class="headerlink" title="递归调用（迷宫问题，罗汉塔，八个皇后）(p222-p227)老韩java"></a><u>递归调用</u>（迷宫问题，罗汉塔，八个皇后）(p222-p227)老韩java</h2><p><strong>1、执行一个方法，会创建一个新的受保护的独立空间（栈空间）2、方法的局部变量是独立的，不会互相影响，比如n变量（即形参）</strong></p>
<p><strong>3、如果方法中使用的是引用类型变量（比如数组，对象），就会共享该引用类型的数据</strong></p>
<p><strong>4、递归必须向退出递归的条件逼近，否则就无限递归</strong></p>
<p><strong>5、当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</strong></p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h2><p>1、函数名相同</p>
<p>2、参数个数、类型、顺序不同</p>
<p>3、对函数返回值无要求</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>1、在java中，主要的变量就是属性（方法变量）和局部变量</p>
<p>2、局部变量一般是指在成员方法中定义的变量</p>
<p>3、java中的作用域分类：</p>
<p>全局变量：也就是属性，作用域为整个类体 cat类cry eat等方法使用属性</p>
<p>4、全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值，因为没有默认值（main函数中属于局部变量，类中属性和代码块属于相对全局变量，注意类中方法定义属于局部变量）</p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h3><p>1、属性和局部变量可以重名，访问遵循就近原则</p>
<p>ps：class cat{</p>
<pre><code>    int age=10;

       public static void test()&#123;

     int age=20;
</code></pre><p>​         System.out.println(age);//20  就近原则</p>
<p>​    }</p>
<p>}</p>
<p>2、在同一个作用域中，比如在同一个成员方法中，两个局部变量不能重名//即不能定义两个一样的变量</p>
<p>3、属性生命周期较长，盘随着对象的创建而创建，伴随着对象的销毁而销毁，局部变量，生命周期较短，伴随着他的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。</p>
<p>4、作用域范围不同</p>
<p>​    全局变量/属性：可以被本类使用，或被其他类使用</p>
<p>​    局部变量：只能在本类中对应的方法中使用</p>
<p>5、修饰符不同</p>
<p>​    全局变量/属性可以加修饰符</p>
<p>​    局部变量不可以加修饰符</p>
<p><strong>6、内存位置不同，成员变量是在堆内存，局部变量是在栈内存</strong></p>
<p><strong>7、成员变量是在类中方法外，局部变量方法内或者方法声明上</strong></p>
<p><strong>8、成员变量有默认的初始化值，局部变量没有初始化值，必须先定义赋值</strong></p>
<h2 id="构造函数-构造器"><a href="#构造函数-构造器" class="headerlink" title="构造函数/构造器"></a>构造函数/构造器</h2><p>【修饰符】方法名（形参列表）{</p>
<pre><code>         方法体；
</code></pre><p>}</p>
<p>1、构造器的修饰可以是默认的，也可以是 public protected private</p>
<p>2、构造器没有返回值</p>
<p>3、方法名和类名必须要一样</p>
<p>4、参数列表和成员方法一样的规则</p>
<p>5、构造器的调用系统完成 </p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、一个类可以定义多个不同的构造器，即构造器重载</p>
<p>2、构造器必须和类名相同</p>
<p>3、构造器没有返回值</p>
<p>4、构造器是完成对象的初始化，并不是创建对象</p>
<p>5、在创建对象时，系统自动的调用该类的构造方法</p>
<p>6、如果程序猿没有定义构造器，系统会自动生成一个无参构造器，也是默认构造器</p>
<p>7、一旦定义了自己的构造器，默认的构造器就覆盖了，不能再使用默认的无参构造器，除非显式定义一个；</p>
<h2 id="string以及StringBuilder"><a href="#string以及StringBuilder" class="headerlink" title="string以及StringBuilder"></a>string以及StringBuilder</h2><p>1、字符数组转化为字符串</p>
<p>​        char a[]= {‘a’,’b’,’c’};<br>​        String aString=new String(a);<br>​        System.out.println(aString)；</p>
<h2 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">insert(int offset, String str) 将 <code>str</code> 参数的字符串插入此序列中。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody>
</table>
</div>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>在应用程序要求线程安全的情况下，必须要使用stringBuffer类型</p>
<h2 id="string与stringbuilder之间的转换"><a href="#string与stringbuilder之间的转换" class="headerlink" title="string与stringbuilder之间的转换"></a>string与stringbuilder之间的转换</h2><p>1、stringbuilder转换为string</p>
<p>​        StringBuilder A=new StringBuilder();<br>​        A.append(100).append(“nihao”).append(“java”);//                链式编程</p>
<p>​        String a=A.toString();<br>​        System.out.println(a);</p>
<p>2、string转换为stringbuilder</p>
<p>​        构造方法</p>
<pre><code>     StringBuilder B=new StringBuilder(a);
        System.out.println(B);
</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="集合的底层是一个可变数组，ArrayList："><a href="#集合的底层是一个可变数组，ArrayList：" class="headerlink" title="集合的底层是一个可变数组，ArrayList："></a>集合的底层是一个可变数组，ArrayList<E>：</h3><p>1、可调整大小的数组实现</p>
<p>2、<E>:是一种特殊的数据类型，泛型</p>
<p>如何使用：</p>
<p>​                在出现E的地方我们使用引用数据类替换即可</p>
<p>​                举例：ArrayList<String>,ArrayList<Student></p>
<h3 id="ArrayList构造方法和添加方法"><a href="#ArrayList构造方法和添加方法" class="headerlink" title="ArrayList构造方法和添加方法"></a>ArrayList构造方法和添加方法</h3><p>1、public ArrayList()    //创建一个空的集合对象</p>
<p>2、public boolean add(E e) //将制定的数据追加到集合的末尾</p>
<p>3、public void add(int index,E element)//在此集合的指定位置插入指定的元素</p>
<h3 id="ArrayList常用方法"><a href="#ArrayList常用方法" class="headerlink" title="ArrayList常用方法"></a>ArrayList常用方法</h3><p>1、public boolean remove(Object o) //删除指定的元素，返回删除是否成功</p>
<p>2、public E remove(int index)//删除指定索引处的元素,返回被删除的元素，E代表被删除数据的类型</p>
<p>3、public E set(int index,E element)//修改指定索引处的元素，返回被修改的元素</p>
<p>4、public E get(int index)//返回指定索引处的元素</p>
<p>5、public int size()//返回集合中的元素个数 </p>
<p>//System.out.println(arrayList.set(0, “xiugai”));//修改指定索引处的元素，返回被修改的元素<br>   // System.out.println(arrayList.remove(“world”));</p>
<p> //System.out.println(arrayList.remove(0));//没</p>
<p>有就会返回false<br>    //System.out.println(arrayList.get(0));//返回指定索引处的元素<br>    //System.out.println(arrayList.size());//返回集合中的元素个数 </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="1、在子类方法中访问一个变量"><a href="#1、在子类方法中访问一个变量" class="headerlink" title="1、在子类方法中访问一个变量"></a>1、在子类方法中访问一个变量</h3><p>（1）在子类方法中找（2）在子类成员属性中找（3）在父类成员属性中找</p>
<h3 id="2、super关键字"><a href="#2、super关键字" class="headerlink" title="2、super关键字"></a>2、super关键字</h3><p>this 代表本类对象的引用</p>
<p>super 代表父类对象的引用</p>
<p>1、调用父类中的成员方法super.test();</p>
<p>2、调用父类中的成员属性super.nums</p>
<p>3、调用父类中的构造函数</p>
<p>public  guanjianzi_super() {<br>        super();//必须写在第一行<br>    }</p>
<h3 id="3、继承中构造方法的访问特点"><a href="#3、继承中构造方法的访问特点" class="headerlink" title="3、继承中构造方法的访问特点"></a>3、继承中构造方法的访问特点</h3><p>1、子类中所有的构造方法默认都会访问父类中无参的构造方法</p>
<p>2、调用有参构造方法需要在子类构造函数中super(参数);</p>
<p>传进去一个参数即可调用父类的有参构造函数</p>
<h3 id="4、继承中成员方法的访问特点"><a href="#4、继承中成员方法的访问特点" class="headerlink" title="4、继承中成员方法的访问特点"></a>4、继承中成员方法的访问特点</h3><p>（1）在子类成员范围中找</p>
<p>（2）在父类成员范围中找</p>
<p>（3）如果都没有就报错</p>
<h3 id="5、方法重写注意事项"><a href="#5、方法重写注意事项" class="headerlink" title="5、方法重写注意事项"></a>5、方法重写注意事项</h3><p>1、父类中的私有方法，子类无法继承和重写</p>
<p>2、子类重写父类方法时只要不比父类低即可</p>
<p>即：父类如果是public  子类必须为 public</p>
<p>​        父类若是默认的，子类可以是默认，也可以是public</p>
<h3 id="6、继承注意事项"><a href="#6、继承注意事项" class="headerlink" title="6、继承注意事项"></a>6、继承注意事项</h3><p>1、单一继承，不支持多继承，但支持继承体系、多层继承，例如:父亲继承爷爷，孙子继承父亲。</p>
<h2 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h2><p>1、同一个项目中使用别的包需要引入</p>
<p>例如：import 包名称.类名；</p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>1、private 只能在本类中访问，默认和保护和公共可以被其他无关的类访问</p>
<p>2、不同类中，另一个类不可以访问该类的私有方法</p>
<p>3、不同包中，只能访问另一个包的一个中类中的公共的方法</p>
<p>4、final 关键字是最终的意思，可以修饰成员方法，成员变量，类</p>
<p>​        最终方法不可以被重写</p>
<p>​        最终类不可以被继承</p>
<p>​        最终修饰基本类型变量不可以被重新赋值，引用类型可以被重新赋值，原理是final修饰引用类型是地址不可以被改变，但是里面的值是可以改变的.</p>
<pre><code>        final Cat aCat=new Cat();
        aCat =new Cat();//会报错

        final Cat aCat=new Cat();
        aCat.age=5;//不报错
        aCat.name=&quot;加菲猫&quot;;//不报错
</code></pre><p>5、static    </p>
<p>（1）、被所有对象共享的成员用static修饰，建议通过类名进行访问（2）、被类的所有成员共享，这也是我们判断是否使用静态关键字的条件</p>
<p>访问特点：</p>
<p>（1）、非静态成员方法可以访问所有静态成员和非静态成员变量</p>
<p>（2）、静态成员方法只能访问静态成员变量和静态成员方法，main方法也是静态的，所以可以调用。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的前提和体现"><a href="#多态的前提和体现" class="headerlink" title="多态的前提和体现"></a>多态的前提和体现</h3><p>1、有继承/实现关系2、有方法重写3、有父类引用指向子类对象</p>
<h3 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h3><p>1、成员变量：编译和执行都看父类</p>
<p>2、成员方法：编译看父类中有没有，执行是执行子类中重写的此方法</p>
<p>原因：成员方法有重些，成员变量无重写</p>
<p>例如：</p>
<p>​        Animal animal=new Cat();<br>​        System.out.println(animal.age);//父类中的成员变量<br>​        animal.TextStyle();//子类中的成员方法</p>
<h3 id="多态的好处和弊端"><a href="#多态的好处和弊端" class="headerlink" title="多态的好处和弊端"></a>多态的好处和弊端</h3><p> 好处：多个类继承同一个父类时，可以写一个方法，使用参数为父类型，在使用的时候，使用具体的子类形参与操作，从而调用该子类的成员方法（可以调用的是子类中重写的方法）</p>
<p>例如：</p>
<pre><code>private static void test( Animal a) &#123;
    // 传进来的子类对象
    //原理为：Animal a=new 子类();
    //即父类引用指向子类对象
    a.TextStyle();//此方法多个子类进行重写
&#125;
</code></pre><p>弊端：调用的方法只能是所有继承该父类的子类进行重写</p>
<p>的成员方法，不能调用某个子类中特有的方法</p>
<h3 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a>多态的转型</h3><p>向上转型：即为有父类引用指向子类对象</p>
<p>向下转型：即父类引用转为子类对象</p>
<p>例如：</p>
<p>​        Animal animal=new <strong>Cat</strong>();  //向上转型<br>​        <strong>Cat</strong> bCat=(<strong>Cat</strong>)animal;  //向下转型，注意黑体加粗部分<br>​        bCat.catwork1();</p>
<p>注意：</p>
<p>向下转型中转型的对象必须与new 类型名 相符</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类的特点</strong>：抽象类和抽象方法必须用abstract关键字修饰</p>
<p>​            public abstract class 类名{}</p>
<p>​            public abstract void eat();</p>
<p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p>
<p>抽象类不能实例化对象，可以参照多态的方式，通过子类对象实例化对象</p>
<p>抽象类的子类要么重写抽象类的所有抽象方法，要么他本身就是一个抽象类</p>
<p><strong>抽象类的成员特点</strong></p>
<p>成员变量：可以是变量也可以是常量</p>
<p>构造方法：有构造方法，但是不能实例化，通过子类访问父类的数据</p>
<p>成员方法：可以有抽象的方法来限定子类必须完成某些操作</p>
<p>也可以有非抽象方法提高代码复用性</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h2><p>接口用关键字interface修饰：</p>
<p>​        public interface 接口名 {}</p>
<p>类实现接口用implements 表示</p>
<p>​        public class 类名  implements  接口名{}</p>
<p>接口不能实例化，参照多态的方式，通过实现类对象实例化，这叫接口多态（具体类多态，抽象类多态，接口多态）</p>
<p><strong>多态的前提：有继承或者实现关系，有方法重写，有父类引用指向子类对象</strong></p>
<p>接口的实现类：</p>
<p>​            要么重写接口中的所有抽象方法</p>
<p>​            要么是抽象类</p>
<p><strong>接口的成员特点</strong>        </p>
<p>变量默认是公共、静态、最终的，静态即可以通过接口名访问，最终即值无法改变</p>
<p>接口中无构造方法，因为接口主要是对行为进行抽象，是没有具体存在，一个类如果没有父类，默认继承Object类</p>
<p>成员方法</p>
<p>​        只能是抽象方法，默认修饰符：public abstract</p>
<p><strong>接口和类的区别:</strong></p>
<p>​        接口不能被实例化对象，类可以；</p>
<p>​        接口没有构造方法；</p>
<p>​        接口中所有方法是抽象的；</p>
<p>​        接口中不能有变量，除了final和static修饰的变量；</p>
<p>​        接口不是被继承了，而是被实现了；</p>
<p>​        多个类可以同时实现同一个接口；</p>
<h2 id="类和接口的关系"><a href="#类和接口的关系" class="headerlink" title="类和接口的关系"></a>类和接口的关系</h2><p>类和类的关系：只能单继承，但是可以多层继承</p>
<p>类和接口的关系：可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p>
<p>接口与接口的关系：可以单继承，也可以多继承</p>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><p>成员区别：</p>
<p>​                抽象类：常量，变量，有构造方法，也有抽象方法，也有非抽象方法</p>
<p>​                接口：   常量，抽象方法</p>
<p>关系区别：</p>
<p>​                类和类：单继承</p>
<p>​                类和接口：单实现、多实现</p>
<p>​                接口与接口：单继承、多继承</p>
<p><strong>设计理念区别：</strong></p>
<p>​                <strong>抽象类：对象抽象，包括属性、行为</strong></p>
<p>​                <strong>接口：对行为抽象，主要是行为</strong></p>
<ul>
<li><ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
</ol>
</li>
<li><ol>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
</ol>
</li>
<li><ol>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
</ol>
</li>
<li><ol>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
<p><strong>注</strong>：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。更多内容可参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java8-default-methods.html">Java 8 默认方法</a>。</p>
<p><strong>注</strong>：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java9-private-interface-methods.html">Java 9 私有接口方法</a>。</p>
</blockquote>
<h2 id="接口名作为形参和返回值"><a href="#接口名作为形参和返回值" class="headerlink" title="接口名作为形参和返回值"></a>接口名作为形参和返回值</h2><p>方法的形参是接口名，其实需要的是该接口的实现类对象</p>
<p>方法的返回值是接口名，其实是返回的是该接口的实现类对象</p>
<p><strong>其实类似于抽象类，需要通过父类引用指向子类对象，创建一个子类，重写接口中的方法，通过实例化一个子类对象调用接口中的方法。</strong></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>定义：在一个类中定义一个类</p>
<h3 id="内部类的访问特点："><a href="#内部类的访问特点：" class="headerlink" title="内部类的访问特点："></a><strong>内部类的访问特点：</strong></h3><p><strong>内部类可以直接访问外部类的成员，包括私有</strong></p>
<p><strong>外部类要访问内部类的成员，必须创建对象</strong></p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>1、在类的成员位置：成员内部类</p>
<p>2、在类的局部位置：局部内部类</p>
<p>一般格式：Player.nihao a=new Player(). new nihao();（不推荐）</p>
<p>常用方法：通过在外部类中写一个方法实例化一个内部类对象，访问内部类方法，再通过实例化外部类对象访问该方法，间接访问内部类</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义：在外部类的一个成员方法内定义一个类</p>
<p>调用方法：在外部类内的方法内部定义内部类并且实例化该内部类，通过实例化外部类对象，调用外部类方法进而调用内部类</p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>前提：存在一个类或者是接口，这里的类可以是具体类，也可以是抽象类</p>
<p>本质：是一个继承了该类或者实现了该接口的子类匿名对象</p>
<p>创建格式：</p>
<pre><code>public class neibulei &#123;
    public void method() &#123;
        new SpeakEnglish() &#123;
        @Override
        public void speak() &#123;
            // TODO 自动生成的方法存根
            System.out.println(&quot;说英语&quot;);
        &#125;
       &#125;;
    &#125;
&#125;
</code></pre><p>调用方法：</p>
<pre><code>new SpeakEnglish() &#123;
        @Override
        public void speak() &#123;
            // TODO 自动生成的方法存根
            System.out.println(&quot;说英语&quot;);
        &#125;
    &#125;.speak();
</code></pre><p>完善方法：</p>
<p>public class neibulei {   </p>
<p>​     public void method() {    </p>
<p>​            SpeakEnglish as=new SpeakEnglish() {          </p>
<p>​                     public void speak() {                </p>
<p>​                                System.out.println(“说英语”);    </p>
<p>​                                    }   </p>
<pre><code>                             &#125;;        
</code></pre><p>​            as.speak();    }</p>
<script type="math/tex; mode=display">
public class neibulei {
    public void method() {
    SpeakEnglish as=new SpeakEnglish() {
            @Override
            public void speak() {
                // TODO 自动生成的方法存根
                System.out.println("说英语");
            }
        };
        as.speak();
    }
}常用APIMath</script><div class="table-container">
<table>
<thead>
<tr>
<th><code>static double</code></th>
<th><code>abs(double a)</code>返回值为 <code>double</code>绝对值。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static float</code></td>
<td><code>abs(float a)</code>返回 <code>float</code>值的绝对值。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>abs(int a)</code>返回值为 <code>int</code>绝对值。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>abs(long a)</code>返回值为 <code>long</code>绝对值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>acos(double a)</code>返回值的反余弦值; 返回的角度在0.0到<em>pi</em>的范围内。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>addExact(int x, int y)</code>返回其参数的总和，如果结果溢出int，则抛出 <code>int</code> 。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>addExact(long x, long y)</code>返回其参数的总和，如果结果溢出long，则抛出 <code>long</code> 。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>asin(double a)</code>返回值的正弦值; 返回角度在<em>pi</em> / 2到<em>pi</em> / 2的范围内。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>atan(double a)</code>返回值的反正切值; 返回角度在<em>pi</em> / 2到<em>pi</em> / 2的范围内。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>atan2(double y, double x)</code>返回从直角坐标（转换角度 <em>theta</em> <code>x</code> ， <code>y</code> ）为极坐标 <em>（R，θ-）。</em></td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>cbrt(double a)</code>返回 <code>double</code>值的多维数据集根。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>ceil(double a)</code>返回大于或等于参数的最小（最接近负无穷大） <code>double</code>值，等于一个数学整数。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>copySign(double magnitude, double sign)</code>使用第二个浮点参数的符号返回第一个浮点参数。</td>
</tr>
<tr>
<td><code>static float</code></td>
<td><code>copySign(float magnitude, float sign)</code>使用第二个浮点参数的符号返回第一个浮点参数。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>cos(double a)</code>返回角度的三角余弦。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>cosh(double x)</code>返回的双曲余弦 <code>double</code>值。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>decrementExact(int a)</code>返回一个递减1的参数，如果结果溢出int，则 <code>int</code> 。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>decrementExact(long a)</code>将返回的参数递减1，如果结果溢出long，则 <code>long</code> 。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>exp(double a)</code>返回欧拉的数字 <em>e</em>提高到一个 <code>double</code>价值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>expm1(double x)</code>返回 <em>e</em> x -1。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>floor(double a)</code>返回小于或等于参数的最大（最接近正无穷大） <code>double</code>值，等于一个数学整数。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>floorDiv(int x, int y)</code>返回小于或等于代数商的最大（最接近正无穷大） <code>int</code>值。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>floorDiv(long x, long y)</code>返回小于或等于代数商的最大（最接近正无穷大） <code>long</code>值。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>floorMod(int x, int y)</code>返回 <code>int</code>参数的底部模数。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>floorMod(long x, long y)</code>返回 <code>long</code>参数的底模数。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>getExponent(double d)</code>返回a的表示中使用的无偏指数 <code>double</code> 。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>getExponent(float f)</code>返回a的表示中使用的无偏指数 <code>float</code> 。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>hypot(double x, double y)</code>返回sqrt（ <em>x</em> 2 + <em>y</em> 2 ），没有中间溢出或下溢。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>IEEEremainder(double f1, double f2)</code>根据IEEE 754标准计算两个参数的余数运算。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>incrementExact(int a)</code>返回自变量1，如果结果溢出int，则 <code>int</code> 。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>incrementExact(long a)</code>返回一个增加1的参数，如果结果溢出long，则 <code>long</code> 。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>log(double a)</code>返回的自然对数（以 <em>e</em>为底） <code>double</code>值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>log10(double a)</code>返回一个 <code>double</code>的基数10对数值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>log1p(double x)</code>返回参数和1的和的自然对数。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>max(double a, double b)</code>返回两个 <code>double</code>值中的较大值。</td>
</tr>
<tr>
<td><code>static float</code></td>
<td><code>max(float a, float b)</code>返回两个 <code>float</code>的较大值。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>max(int a, int b)</code>返回两个 <code>int</code>值中的较大值。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>max(long a, long b)</code>返回两个 <code>long</code>的较大值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>min(double a, double b)</code>返回两个 <code>double</code>的较小值。</td>
</tr>
<tr>
<td><code>static float</code></td>
<td><code>min(float a, float b)</code>返回两个 <code>float</code>的较小值。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>min(int a, int b)</code>返回两个 <code>int</code>的较小值。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>min(long a, long b)</code>返回两个 <code>long</code>的较小值。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>multiplyExact(int x, int y)</code>返回参数的乘积，如果结果溢出int，则抛出 <code>int</code> 。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>multiplyExact(long x, long y)</code>返回参数的乘积，如果结果溢出long，则抛出 <code>long</code> 。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>negateExact(int a)</code>返回参数的否定，如果结果溢出int，则 <code>int</code> 。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>negateExact(long a)</code>返回参数的否定，如果结果溢出long，则 <code>long</code> 。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>nextAfter(double start, double direction)</code>返回与第二个参数方向相邻的第一个参数的浮点数。</td>
</tr>
<tr>
<td><code>static float</code></td>
<td><code>nextAfter(float start, double direction)</code>返回与第二个参数方向相邻的第一个参数的浮点数。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>nextDown(double d)</code>返回与负无穷大方向相邻的 <code>d</code>的浮点值。</td>
</tr>
<tr>
<td><code>static float</code></td>
<td><code>nextDown(float f)</code>返回与负无穷大方向相邻的 <code>f</code>的浮点值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>nextUp(double d)</code>返回与正无穷大方向相邻的 <code>d</code>的浮点值。</td>
</tr>
<tr>
<td><code>static float</code></td>
<td><code>nextUp(float f)</code>返回与正无穷大方向相邻的 <code>f</code>的浮点值。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>pow(double a, double b)</code>将第一个参数的值返回到第二个参数的幂。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>random()</code>返回值为 <code>double</code>值为正号，大于等于 <code>0.0</code> ，小于 <code>1.0</code> 。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>rint(double a)</code>返回与参数最接近值的 <code>double</code>值，并且等于数学整数。</td>
</tr>
<tr>
<td><code>static long</code></td>
<td><code>round(double a)</code>返回参数中最接近的 <code>long</code> ，其中 <code>long</code>四舍五入为正无穷大。</td>
</tr>
<tr>
<td><code>static double</code></td>
<td><code>sqrt(double a)</code>返回的正确舍入正平方根 <code>double</code>值。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><div class="table-container">
<table>
<thead>
<tr>
<th><code>static long</code></th>
<th><code>currentTimeMillis()</code>返回当前时间（以毫秒为单位）。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static void</code></td>
<td><code>exit(int status)</code>终止当前运行的Java虚拟机。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong><code>boolean</code></strong></th>
<th><strong><code>equals(Object obj)</code>指示一些其他对象是否等于此。</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>String</code></strong></td>
<td><strong><code>toString()</code>返回对象的字符串表示形式。</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p><strong>arrays.toString(数组名)</strong>   //返回指定数组的内容的字符串表示形式。</p>
<p>arrays.sort（数组）//按升序排列数组的指定范围。</p>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><div class="table-container">
<table>
<thead>
<tr>
<th><code>static int</code></th>
<th><code>MAX_VALUE</code>一个持有最大值一个 <code>int</code>可以有2 31 -1。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>static int</code></td>
<td><code>MIN_VALUE</code>的常量保持的最小值的 <code>int</code>可以具有，-2 31。</td>
</tr>
<tr>
<td><code>static int</code></td>
<td><code>SIZE</code>用于表示二进制补码二进制形式的 <code>int</code>值的位数。</td>
</tr>
<tr>
<td><code>static 类&lt;Integer&gt;</code></td>
<td><code>TYPE``类</code>原始类型 <code>int</code>的 <code>类</code>实例。</td>
</tr>
</tbody>
</table>
</div>
<p>Integer nInteger=new Integer(100);//只能是数字，其他类型会报错<br>        System.out.println(nInteger);</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><p>1、打印当前日期</p>
<p>​        Calendar aCalendar=Calendar.getInstance();<br>​        int year=aCalendar.get(Calendar.YEAR);<br>​        int month=aCalendar.get(Calendar.MONDAY);<br>​        int data=aCalendar.get(Calendar.DATE);<br>​        System.out.println(year+”年”+month+”月”+data+”日”);</p>
<p>2、添加某个数据（年月日）</p>
<p>​        aCalendar.add(aCalendar.MONDAY,5);//添加月份</p>
<p>​    通过add方法可以对日历进行修改</p>
<p>3、获取对应月份的天数</p>
<p>​        Calendar aCalendar=Calendar.getInstance();</p>
<p>​        Scanner aScanner =new Scanner(System.in);<br>​        int year=aScanner.nextInt();<br>​        aCalendar.set(year,1,1);<br>​        aCalendar.add(aCalendar.DATE, -1);<br>​        int data=aCalendar.get(aCalendar.DATE);<br>​        System.out.println(data);</p>
<p>先获取年份，然后月份下标从0开始，1代表第二月，第二月最后一天减去一天就是第一个月最后一天，就可以获取第一个月的天数</p>
<p>4、计算某一天是这一年的第几天</p>
<pre><code>import java.util.Calendar;
import java.util.Scanner;
Calendar aCalendar = Calendar.getInstance();
Scanner aScanner = new Scanner(System.in);
    int year = aScanner.nextInt();
    int month = aScanner.nextInt();
    int data=aScanner.nextInt();
    int nums=0;
for (int i = 1; i &lt; month; i++) &#123;
    aCalendar.set(year,i, 1);
    aCalendar.add(aCalendar.DATE, -1);
nums = nums+aCalendar.get(aCalendar.DATE);    
    &#125;
    System.out.println(nums+data);
</code></pre><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h3><pre><code>                                 Throwable
</code></pre><p>​                    Error                                                Exception</p>
<p>​                                                   RuntimeException        非 RuntimeException </p>
<p>Error：严重问题，不需要处理</p>
<p>Exception：称为异常类，他表示程序本身可以处理的问题</p>
<p> RuntimeException ：在编译期是不需要检查的，出现问题后，需要回来修改代码</p>
<p>非 RuntimeException ：编译期间就必须处理的，否则程序不能通过编译，更不能正常运行。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211028/348470426_1635431780619/6479D7BB01736CCC61B8270D41F00B17" alt="img"></p>
<h2 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h2><p><img src="E:\sql学习资料\集合类体系结构.png" alt="集合类体系结构"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20161014/4552908_1476435955845_3AA2482F152044FA3EC4640FD49DAE02" alt="img"></p>
<h3 id="Collection-集合的常用方法："><a href="#Collection-集合的常用方法：" class="headerlink" title="Collection 集合的常用方法："></a>Collection 集合的常用方法：</h3><ul>
<li><ul>
<li>| <code>boolean</code> | <code>add(E e)</code>  确保此集合包含指定的元素（可选操作）。 |<br>| ————- | ————————————————————————— |<br>| <code>void</code>    | <code>clear()</code>  从此集合中删除所有元素（可选操作）。    |</li>
</ul>
</li>
<li><ul>
<li>| <code>boolean</code> | <code>contains(Object o)</code>  如果此集合包含指定的元素，则返回 <code>true</code> 。 |<br>| ————- | —————————————————————————————— |<br>| <code>boolean</code> | <code>isEmpty()</code>  如果此集合不包含元素，则返回 <code>true</code> 。          |</li>
</ul>
</li>
<li><ul>
<li>| <code>Iterator&lt;E&gt;</code> | <code>iterator()</code>  返回此集合中的元素的迭代器。                   |<br>| ——————- | —————————————————————————————— |<br>| <code>boolean</code>     | <code>remove(Object o)</code>  从该集合中删除指定元素的单个实例（如果存在）（可选操作）。 |</li>
</ul>
</li>
<li><ul>
<li>| <code>int</code> | <code>size()</code>  返回此集合中的元素数。 |<br>| ——- | ———————————————— |<br>|       |                                  |</li>
</ul>
</li>
</ul>
<h3 id="collection集合的遍历"><a href="#collection集合的遍历" class="headerlink" title="collection集合的遍历"></a>collection集合的遍历</h3><pre><code>Collection&lt;String&gt;collection=new ArrayList&lt;String&gt;();
    collection.add(&quot;你好&quot;);
    collection.add(&quot;wode&quot;);
    //collection.remove(&quot;wode&quot;);
    //    System.out.println(collection);
    Iterator&lt;String&gt;aIterator=collection.iterator();
    while(aIterator.hasNext()) &#123;
        System.out.println(aIterator.next());
    &#125;
</code></pre><h3 id="集合的使用步骤"><a href="#集合的使用步骤" class="headerlink" title="集合的使用步骤"></a>集合的使用步骤</h3><p>1、创建集合对象</p>
<p>2、添加元素</p>
<p>3、遍历集合</p>
<pre><code>    Student aStudent = new Student(&quot;12&quot;, &quot;zxq&quot;, &quot;10&quot;, &quot;henan&quot;);
    Student aStudent1 = new Student(&quot;11&quot;, &quot;zhangxinqi&quot;, &quot;9&quot;, &quot;han&quot;);
    Collection&lt;Student&gt; aCollection = new ArrayList&lt;Student&gt;();
    aCollection.add(aStudent);
    aCollection.add(aStudent1);
    Iterator&lt;Student&gt; iterator = aCollection.iterator();
    while (iterator.hasNext()) &#123;
        Student aStudent2 = iterator.next();
        System.out.println(aStudent2.getName() + &quot;,&quot; + aStudent2.getSid() + &quot;,&quot; +         aStudent2.getAge() + &quot;,&quot;
                + aStudent2.getAddress());
    &#125;
</code></pre><h2 id="list集合概述和特点"><a href="#list集合概述和特点" class="headerlink" title="list集合概述和特点"></a>list集合概述和特点</h2><p>List集合概述：</p>
<p>​        有序集合，可以精准控制列表中每个元素的插入位置，通过整数索引访问</p>
<p>​        与set集合不同，列表通常允许重复的元素</p>
<p>特点：</p>
<p>​        有序：存储和取出的元素顺序一致</p>
<p>​        可重复：存储的元素可以重复</p>
<p>​        List<String> strList = new ArrayList&lt;&gt;();<br>​        strList.add(“nihao”);<br>​        Iterator<String>aIterable=strList.iterator();<br>​        while (aIterable.hasNext()) {<br>​            System.out.println(aIterable.next());<br>​            }</p>
<h3 id="使用List集合存储学生类对象信息"><a href="#使用List集合存储学生类对象信息" class="headerlink" title="使用List集合存储学生类对象信息"></a>使用List集合存储学生类对象信息</h3><pre><code>Student aStudent = new Student(&quot;12&quot;, &quot;zxq&quot;, &quot;10&quot;, &quot;henan&quot;);
Student aStudent1 = new Student(&quot;11&quot;, &quot;zhangxinqi&quot;, &quot;9&quot;, &quot;han&quot;);

List&lt;Student&gt; strList = new ArrayList&lt;&gt;();
    strList.add(aStudent);
    strList.add(aStudent1);
    //迭代器输出
Iterator&lt;Student&gt;aIterable=strList.iterator();
    while (aIterable.hasNext()) &#123;
        Student aStudent2=aIterable.next();
System.out.println(aStudent2.getAge()+aStudent2.getName());
    &#125;
    //for循环遍历输出
    for (int i = 0; i &lt; strList.size(); i++) &#123;
        Student aStudent2=strList.get(i);
System.out.println(aStudent2.getAge()+aStudent2.getName());
    &#125;
</code></pre><h3 id="List并发修改异常"><a href="#List并发修改异常" class="headerlink" title="List并发修改异常"></a>List并发修改异常</h3><p>在Java开发中Exception in thread “main” java.util.ConcurrentModificationException, 这是一个并发修改异常，迭代器是依赖于集合而存在的，在判断成功后，集合的中新添加了元素，而迭代器却不知道，所以就报错了，这个错叫并发修改异常。<br><strong>简单描述就是：迭代器遍历元素的时候，通过集合是不能修改元素的。</strong></p>
<pre><code>   ArrayList&lt;String&gt; array = new     ArrayList&lt;String&gt;();
      // 创建并添加元素
    array.add(&quot;hello&quot;);
    array.add(&quot;world&quot;);
    array.add(&quot;java&quot;);
    // 方式1：迭代器迭代元素，迭代器修改元素
// 而Iterator迭代器却没有添加功能，所以我们使用其子接口ListIterator，本质是每次修改后会把实际修改值赋值给预期修改值
    // ListIterator lit = array.listIterator();
    // while (lit.hasNext()) &#123;
    // String s = (String) lit.next();
    // if (&quot;world&quot;.equals(s)) &#123;
    // lit.add(&quot;javaee&quot;);
    // &#125;
    // &#125;
    // System.out.println(&quot;list1:&quot; + array);
    // 方式2：集合遍历元素，集合修改元素(普通for)
     for (int x = 0; x &lt; array.size(); x++) &#123;
     String s = (String) array.get(x);
     if (&quot;world&quot;.equals(s)) &#123;
     array.add(&quot;javaee&quot;);
     &#125;
     &#125;

     System.out.println(&quot;list2:&quot; + array);
    &#125;
&#125;
</code></pre><p>提示：集合有个属性modCount，每当对集合修改一次，modCount的值就会自增，，迭代器在遍历的时候，底层会new一个Itr的内部类，初始化了一个变量记录了集合的实际修改次数modCount，变量名expectedModCount是预期修改次数。迭代器在调用next()方法时候会去比较这两个值是否相等，不相等则抛出异常</p>
<p>final void checkForComodification()</p>
<p> {</p>
<p>​         if (modCount != expectedModCount) throw new          ConcurrentModificationException();</p>
<p> }</p>
<h2 id="ListIterator列表迭代器-用的不多-多用Iterator"><a href="#ListIterator列表迭代器-用的不多-多用Iterator" class="headerlink" title="ListIterator列表迭代器(用的不多,多用Iterator)"></a>ListIterator列表迭代器(用的不多,多用Iterator)</h2><p>1、通过list集合的listlterator()方法得到，所以说他是List集合特有的迭代器</p>
<p>2、用于允许程序猿沿任意方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表迭代器的当前位置</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><ul>
<li><p>| <code>void</code>    | <code>add(E e)</code>  将指定的元素插入列表（可选操作）。               |<br>| ————- | —————————————————————————————— |<br>| <code>boolean</code> | <code>hasNext()</code>  返回 <code>true</code>如果遍历正向列表，列表迭代器有多个元素。 |<br>| <code>boolean</code> | <code>hasPrevious()</code>  返回 <code>true</code>如果遍历反向列表，列表迭代器有多个元素。 |<br>| <code>E</code>       | <code>next()</code>  返回列表中的下一个元素，并且前进光标位置。         |<br>| <code>int</code>     | <code>nextIndex()</code>  返回随后调用 <a href="../../java/util/ListIterator.html#next--"><code>next()</code></a>返回的元素的索引。 |<br>| <code>E</code>       | <code>previous()</code>  返回列表中的上一个元素，并向后移动光标位置。   |<br>| <code>int</code>     | <code>previousIndex()</code>  返回由后续调用 <a href="../../java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的元素的索引。 |<br>| <code>void</code>    | <code>remove()</code>  从列表中删除由 <a href="../../java/util/ListIterator.html#next--"><code>next()</code></a>或 <a href="../../java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）。 |<br>| <code>void</code>    | <code>set(E e)</code>  用 <a href="../../java/util/ListIterator.html#next--">指定的</a>元素替换由 <a href="../../java/util/ListIterator.html#next--"><code>next()</code></a>或 <a href="../../java/util/ListIterator.html#previous--"><code>previous()</code></a>返回的最后一个元素（可选操作）。 |</p>
<p>while (lit.hasPrevious()) {</p>
<pre><code>        String string = (String) lit.previous();
        System.out.println(&quot;list1:&quot; + string);
    &#125;
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>其底层是一个迭代器</p>
<p>格式：</p>
<pre><code>// 增强for循环写的话会报同样的错误，因为它本身就是用来替代迭代器的
 // for (String s : array) &#123;
    // if (&quot;world&quot;.equals(s)) &#123;
    // array.add(&quot;javaee&quot;);
    // &#125;
    // &#125;
    // System.out.println(&quot;list3:&quot; + array);
    for (String s : strList) &#123;    
           System.out.println(s);
         &#125;
</code></pre><h2 id="三种遍历集合的方法"><a href="#三种遍历集合的方法" class="headerlink" title="三种遍历集合的方法"></a>三种遍历集合的方法</h2><pre><code>        Student aStudent = new Student(&quot;12&quot;, &quot;zxq&quot;, &quot;10&quot;, &quot;henan&quot;);
         Student aStudent1 = new Student(&quot;11&quot;, &quot;zhangxinqi&quot;, &quot;9&quot;, &quot;han&quot;);
        List&lt;Student&gt; strList = new ArrayList&lt;&gt;();
         strList.add(aStudent);
         strList.add(aStudent1);
         Iterator&lt;Student&gt; aIterable=strList.iterator();
         while (aIterable.hasNext()) &#123;
             Student aStudent2=aIterable.next();
             System.out.println(aStudent2.getAge());
         &#125;
         for (int i = 0; i &lt; strList.size(); i++) &#123;
             Student aStudent2=strList.get(i);
             System.out.println(aStudent2.getAge());
        &#125;
         for (Student aStudent2:strList) &#123;
             System.out.println(aStudent2.getAge());
        &#125;
</code></pre><h2 id="List集合子类特点"><a href="#List集合子类特点" class="headerlink" title="List集合子类特点"></a>List集合子类特点</h2><p>ArrayList：底层数据结构是数组，查询快，增删慢</p>
<p>LinkedList：底层数据结构式链表，查询慢，增删快</p>
<h2 id="LinkedList集合的特有功能"><a href="#LinkedList集合的特有功能" class="headerlink" title="LinkedList集合的特有功能"></a>LinkedList集合的特有功能</h2><ul>
<li><ul>
<li>| <code>E</code>  | <code>get(int index)</code>  返回此列表中指定位置的元素。 |<br>| —— | ——————————————————————— |<br>| <code>E</code>  | <code>getFirst()</code>  返回此列表中的第一个元素。       |<br>| <code>E</code>  | <code>getLast()</code>  返回此列表中的最后一个元素。      |</li>
</ul>
</li>
<li><ul>
<li>| <code>E</code>  | <code>removeFirst()</code>  从此列表中删除并返回第一个元素。  |<br>| —— | ————————————————————————— |<br>|      |                                                    |<br>| <code>E</code>  | <code>removeLast()</code>  从此列表中删除并返回最后一个元素。 |</li>
</ul>
</li>
<li><ul>
<li>| <code>void</code> | <code>addFirst(E e)</code>  在该列表开头插入指定的元素。    |<br>| ——— | ———————————————————————— |<br>| <code>void</code> | <code>addLast(E e)</code>  将指定的元素追加到此列表的末尾。 |<br>| <code>void</code> | <code>clear()</code>  从列表中删除所有元素。                |</li>
</ul>
</li>
</ul>
<h2 id="Set集合的概述和特点"><a href="#Set集合的概述和特点" class="headerlink" title="Set集合的概述和特点"></a>Set集合的概述和特点</h2><p>set集合特点</p>
<p>1、不包含重复元素的集合</p>
<p>2、没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>set集合练习</p>
<p>1、存储字符串遍历</p>
<h2 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h2><p>哈希值：是jdk根据对象的地址或者字符串或者数字计算出来的int类型的数值</p>
<p>Object类中有一个方法可以获取对象的哈希值</p>
<p>System.out.println(aStudent.hashCode());</p>
<p>1、同一个对象的哈希值在默认情况下是相同的，即默认Object方法</p>
<p>2、通过对Object方法重写可以实现不同对象有相同的哈希值</p>
<p> System.out.println(“重地”.hashCode());<br> System.out.println(“通话”.hashCode());</p>
<p>输出：</p>
<p>1179395<br>1179395</p>
<p>原因：string肯定会有一个上限，当字符长时产生的数值过大string放不下时会进行截取，一旦截取HashCode的正确性就无法保证了，所以这点可以推断出HashCode存在不相同字符拥有相同HashCode。</p>
<h2 id="HashSet集合的概述特点"><a href="#HashSet集合的概述特点" class="headerlink" title="HashSet集合的概述特点"></a>HashSet集合的概述特点</h2><p>1、HashSet这个类是set接口的实现类，</p>
<p>2、HashSet底层结构是hash表</p>
<p>3、不保证存储和取出的元素顺序一致</p>
<p>4、没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>5、不包含重复元素的集合</p>
<p><strong>注意：要实现存储元素的唯一性需要重写哈希code和equals方法，自动生成即可</strong></p>
<h2 id="哈希表存储元素原理"><a href="#哈希表存储元素原理" class="headerlink" title="哈希表存储元素原理"></a><strong>哈希表存储元素原理</strong></h2><p>1、先对哈希值对16取余，取余的结果存储到0-15对应的位置</p>
<p>2、依次存储对应位置，当对应位置无元素直接存储，有元素先比较哈希值，不一样存储进去</p>
<p>3、哈希值一样，对元素进行比较，一样就不存储</p>
<h2 id="LinkerHashSet集合"><a href="#LinkerHashSet集合" class="headerlink" title="LinkerHashSet集合"></a>LinkerHashSet集合</h2><p>1、哈希表和链表实现的set接口，具有可预测的迭代次序</p>
<p>2、由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</p>
<p>3、LinkerHashSet继承于HashSet，实现于set接口</p>
<p>4、HashSe表保证元素的唯一性</p>
<h2 id="TreeSet集合（比较器）"><a href="#TreeSet集合（比较器）" class="headerlink" title="TreeSet集合（比较器）"></a>TreeSet集合（比较器）</h2><ul>
<li>```<br>public class TreeSet<E><br>extends AbstractSet<E><br>implements NavigableSet<E>, Cloneable, Serializable<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TreeSet间接继承于set接口，TreeSet集合可以自然排序，也可以使用比较器排序（使用什么比较方法取决于使用哪种构造器）</span><br><span class="line"></span><br><span class="line">- - | Constructor and Description                                  |</span><br><span class="line">    | ------------------------------------------------------------ |</span><br><span class="line">    | `TreeSet()`  构造一个新的，空的树组，根据其元素的自然排序进行排序。 |</span><br><span class="line">    | `TreeSet(Collection&lt;? extends E&gt; c)`  构造一个包含指定集合中的元素的新树集，根据其元素的 *自然排序进行排序* 。 |</span><br><span class="line">    | `TreeSet(Comparator&lt;? super E&gt; comparator)`  构造一个新的，空的树集，根据指定的比较器进行排序。 |</span><br><span class="line">    | `TreeSet(SortedSet&lt;E&gt; s)`  构造一个包含相同元素的新树，并使用与指定排序集相同的顺序。 |</span><br><span class="line"></span><br><span class="line">    TreeSet&lt;Integer&gt;aSet=new TreeSet&lt;&gt;();</span><br><span class="line">    		aSet.add(10);</span><br><span class="line">    		aSet.add(20);</span><br><span class="line">    		aSet.add(100);</span><br><span class="line">    		aSet.add(625);</span><br><span class="line">    		aSet.add(666);</span><br><span class="line">    		aSet.add(30);</span><br><span class="line">    		Iterator&lt;Integer&gt;aIterator=aSet.iterator();</span><br><span class="line">    		while (aIterator.hasNext()) &#123;</span><br><span class="line">    			Integer student =aIterator.next();</span><br><span class="line">    			System.out.println(student);</span><br><span class="line">    		&#125;</span><br><span class="line"></span><br><span class="line">注意：使用TreeSet集合存储时使用的是引用类型（基本类型的包装类类型）</span><br><span class="line"></span><br><span class="line">**测试类：**</span><br><span class="line"></span><br><span class="line">	TreeSet&lt;Student&gt; aHashSet = new TreeSet&lt;Student&gt;();</span><br><span class="line">		Student aStudent = new Student(&quot;1001&quot;, &quot;10&quot;, &quot;zxq&quot;, &quot;henan&quot;);</span><br><span class="line">		Student bStudent = new Student(&quot;1002&quot;, &quot;11&quot;, &quot;axq&quot;, &quot;henan&quot;);</span><br><span class="line">		Student cStudent = new Student(&quot;1003&quot;, &quot;12&quot;, &quot;bxq&quot;, &quot;henan&quot;);</span><br><span class="line">		Student dStudent = new Student(&quot;1004&quot;, &quot;10&quot;, &quot;cxq&quot;, &quot;henan&quot;);</span><br><span class="line">	</span><br><span class="line">		aHashSet.add(aStudent);</span><br><span class="line">		aHashSet.add(bStudent);</span><br><span class="line">		aHashSet.add(cStudent);</span><br><span class="line">		aHashSet.add(dStudent);</span><br><span class="line">	</span><br><span class="line">		Iterator&lt;Student&gt; aIterator = aHashSet.iterator();</span><br><span class="line">		while (aIterator.hasNext()) &#123;</span><br><span class="line">			Student student = aIterator.next();</span><br><span class="line">			System.out.println(</span><br><span class="line">					student.getSid() + &quot;,&quot; + student.getAge() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAddress());</span><br><span class="line">	</span><br><span class="line">		&#125;</span><br><span class="line">**学生类：**</span><br><span class="line"></span><br><span class="line">若TreeSet集合中数据类型为自定义的类型（类），需要继承Comparable接口，并且需要重写compareTo方法</span><br><span class="line"></span><br><span class="line">，返回值为0，默认相同，不比较，返回值为负数，降序排列，返回值为正数，默认升序排列，比较的是存储时的第一个元素,若想按照自己的意愿按照其他方式排序，int 类型就做减法，string类型就直接调用compareTo方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Student implements Comparable&lt;Student&gt; &#123;</span><br><span class="line">	String sid;</span><br><span class="line">	String name;</span><br><span class="line">	String age;</span><br><span class="line">	String address;</span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Student o) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		</span><br><span class="line">		int num2=this.getAge().compareTo(o.getAge());</span><br><span class="line">		int num=num2==0?this.getSid().compareTo(o.getSid()):num2;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getSid() &#123;</span><br><span class="line">	return sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line"></span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getAge() &#123;</span><br><span class="line">	return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getAddress() &#123;</span><br><span class="line">	return address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSid(String sid) &#123;</span><br><span class="line">	this.sid = sid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(String age) &#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAddress(String address) &#123;</span><br><span class="line">	this.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(String sid, String age, String name, String address) &#123;</span><br><span class="line">	// TODO 自动生成的方法存根</span><br><span class="line">	this.age = age;</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.sid = sid;</span><br><span class="line">	this.address = address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int hashCode() &#123;</span><br><span class="line">	final int prime = 31;</span><br><span class="line">	int result = 1;</span><br><span class="line">	result = prime * result + ((address == null) ? 0 : address.hashCode());</span><br><span class="line">	result = prime * result + ((age == null) ? 0 : age.hashCode());</span><br><span class="line">	result = prime * result + ((name == null) ? 0 : name.hashCode());</span><br><span class="line">	result = prime * result + ((sid == null) ? 0 : sid.hashCode());</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">	if (this == obj)</span><br><span class="line">		return true;</span><br><span class="line">	if (obj == null)</span><br><span class="line">		return false;</span><br><span class="line">	if (getClass() != obj.getClass())</span><br><span class="line">		return false;</span><br><span class="line">	Student other = (Student) obj;</span><br><span class="line">	if (address == null) &#123;</span><br><span class="line">		if (other.address != null)</span><br><span class="line">			return false;</span><br><span class="line">	&#125; else if (!address.equals(other.address))</span><br><span class="line">		return false;</span><br><span class="line">	if (age == null) &#123;</span><br><span class="line">		if (other.age != null)</span><br><span class="line">			return false;</span><br><span class="line">	&#125; else if (!age.equals(other.age))</span><br><span class="line">		return false;</span><br><span class="line">	if (name == null) &#123;</span><br><span class="line">		if (other.name != null)</span><br><span class="line">			return false;</span><br><span class="line">	&#125; else if (!name.equals(other.name))</span><br><span class="line">		return false;</span><br><span class="line">	if (sid == null) &#123;</span><br><span class="line">		if (other.sid != null)</span><br><span class="line">			return false;</span><br><span class="line">	&#125; else if (!sid.equals(other.sid))</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：</p>
<p>1001,10,zxq,henan<br>1004,10,cxq,henan<br>1002,11,axq,henan<br>1003,12,bxq,henan</p>
<h2 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h2><p>Comparator 比较器和TreeSet构造器中重写Comparable方法本质一样,Comparator 本质是一个内部类</p>
<pre><code>TreeSet&lt;Student&gt; aSet = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
    @Override
        public int compare(Student o1, Student o2) &#123;
            // TODO 自动生成的方法存根
            int num2 = o1.getAge().compareTo(o2.getAge());//比较年龄
            int num = num2 == 0 ? o1.getSid().compareTo(o2.getSid()) : num2;//年龄相同比学号
            return num;

        &#125;

    &#125;);

    Student aStudent = new Student(&quot;1001&quot;, &quot;10&quot;, &quot;zxq&quot;, &quot;henan&quot;);
    Student bStudent = new Student(&quot;1002&quot;, &quot;11&quot;, &quot;axq&quot;, &quot;henan&quot;);
    Student cStudent = new Student(&quot;1003&quot;, &quot;12&quot;, &quot;bxq&quot;, &quot;henan&quot;);
    Student dStudent = new Student(&quot;1004&quot;, &quot;10&quot;, &quot;cxq&quot;, &quot;henan&quot;);

    aSet.add(aStudent);
    aSet.add(bStudent);
    aSet.add(cStudent);
    aSet.add(dStudent);

    Iterator&lt;Student&gt; aIterator = aSet.iterator();
    while (aIterator.hasNext()) &#123;
        Student student = aIterator.next();
        System.out.println(
                student.getSid() + &quot;,&quot; + student.getAge() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAddress());

    &#125;
</code></pre><h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><p>注意：学生类中成绩需要使用int类型</p>
<pre><code>    TreeSet&lt;Student&gt; aSet = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
        @Override
        public int compare(Student o1, Student o2) &#123;
            // TODO 自动生成的方法存根
            int num2=o1.getAge()+o1.getSid()-o2.getAge()-o2.getSid();
            int num = num2 == 0 ? o1.getSid()-o2.getSid() : num2;
            int num3=num==0?o1.getName().compareTo(o2.getName()):num;
            return num;

        &#125;

    &#125;);
    Student aStudent = new Student(99, 99, &quot;zxq&quot;, &quot;henan&quot;);
    Student bStudent = new Student(98, 99, &quot;axq&quot;, &quot;henan&quot;);
    Student cStudent = new Student(98, 95, &quot;bxq&quot;, &quot;henan&quot;);
    Student dStudent = new Student(96, 97, &quot;cxq&quot;, &quot;henan&quot;);
    aSet.add(aStudent);
    aSet.add(bStudent);
    aSet.add(cStudent);
    aSet.add(dStudent);

    Iterator&lt;Student&gt; aIterator = aSet.iterator();
    while (aIterator.hasNext()) &#123;
        Student student = aIterator.next();
        System.out.println(
                student.getSid() + &quot;,&quot; + student.getAge() + &quot;,&quot; + student.getName() + &quot;,&quot; + student.getAddress());

    &#125;
</code></pre><h2 id="随机数排序"><a href="#随机数排序" class="headerlink" title="随机数排序"></a>随机数排序</h2><pre><code>Set&lt;Integer&gt; aSet=new TreeSet&lt;Integer&gt;();
    Random aRandom=new Random();
    while (aSet.size()&lt;10) &#123;

        int num=aRandom.nextInt(20)+1;
        aSet.add(num);
    &#125;
    System.out.println(aSet);
</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型格式：</p>
<p>&lt;类型&gt;：指定一种数据类型，看成是形参</p>
<p>&lt;类型1，类型2&gt;：指定多种类型的格式，多个类型之间用逗号隔开</p>
<p>好处：</p>
<p>1、把运行时候的问题提前到编译期间</p>
<p>2、避免了强制类型转换</p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>测试类：</p>
<pre><code>    public static void main(String[] args) &#123;
    // TODO 自动生成的方法存根
    Teach1 &lt;String&gt;bTeach=new Teach1();
    bTeach.setName(&quot;zxq&quot;);
    Teach1 aTeach1=new Teach1();//未指定类型，不规范
    aTeach1.setAge(30);
    aTeach1.setAge(&quot;60&quot;);
    System.out.println(bTeach.getName());
    System.out.println(aTeach1.getAge());
//    Teach1 &lt;Integer&gt;aTeach=new Teach1();
//    aTeach.setAge(&quot;10&quot;);//实例化对象时指定类型，调用方法不按照指定类型就会报错

&#125;
</code></pre><p>老师类：</p>
<pre><code>public class Teach1&lt;T&gt; &#123;
    private T name;
    private T age;
    public T getName() &#123;
        return name;
    &#125;

    public void setName(T name) &#123;
        this.name = name;
    &#125;
    public T getAge() &#123;
        return age;
    &#125;

    public void setAge(T age) &#123;
        this.age = age;
    &#125;

&#125;
</code></pre><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>优点：</p>
<p>一个对象可以多次调用同一个方法，传入的类型不同</p>
<p>测试类：</p>
<p>​        Teach1 aTeach1=new Teach1&lt;&gt;();<br>​        aTeach1.TexR(“zxq”);<br>​        aTeach1.TexR(13);<br>​        aTeach1.TexR(12.63);</p>
<p>泛型方法：</p>
<pre><code>public &lt;T&gt; void TexR(T t)&#123;

    System.out.println(t);
&#125;
</code></pre><p><strong>注意：泛型方法不一定要写在泛型类中</strong></p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>泛型接口示例：</p>
<p>public interface teach<T> {<br>     void show(T t);<br>}</p>
<p>泛型类示例：</p>
<pre><code>public class Teach1&lt;T&gt; implements teach&lt;T&gt; &#123;
    private T name;
    private T age;
    public T getName() &#123;
        return name;
    &#125;
public void setName(T name) &#123;
    this.name = name;
&#125;
public T getAge() &#123;
    return age;
&#125;

public void setAge(T age) &#123;
    this.age = age;
&#125;
@Override
public void show(T t) &#123;
    // TODO 自动生成的方法存根
    System.out.println(t);
    &#125;
&#125;
</code></pre><h3 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h3><p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<p>类型通配符：&lt;?&gt;</p>
<p>List&lt;?&gt;:表示元素类型未知的List，他的元素可以匹配任何的类型</p>
<p>这种带有通配符的List仅表示他是各种泛型List的父类，并不能把元素添加进去</p>
<p>类型通配符：&lt;?&gt;</p>
<p>类型通配符上限:&lt;? extends 类型&gt;  List最高的类型不能超过该类型</p>
<p>类型通配符下限：&lt;? super 类型&gt;List最低的类型不能超过该类型</p>
<p>​        List&lt;?&gt; aList = new ArrayList<Object>();<br>​        List&lt;?&gt; bList = new ArrayList<Number>();<br>​        List&lt;?&gt; cList = new ArrayList<Integer>();<br>​        System.out.println(“——————————-“);<br>​        List&lt;? extends Number&gt; aList2 = new ArrayList<Number>();<br>​        List&lt;? extends Number&gt; cList2 = new ArrayList<Integer>();<br>​        // List&lt;? extends Number&gt;fList2=new ArrayList<Object>();//超过Number类型，报错<br>​        System.out.println(“——————————-“);<br>​        List&lt;? super Number&gt; dList2 = new ArrayList<Number>();<br>​        List&lt;? super Number&gt; eList2 = new ArrayList<Object>();<br>​        // List&lt;? super Number&gt;gList2=new ArrayList<Integer>();//低于Number类型，报错</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>注意事项：</p>
<p>1、可变参数的实参可以为0个或者任意多个</p>
<p>2、克变参数的实参可以为数组</p>
<p>3、可变参数本质就是数组</p>
<p>4、可变参数可以与普通类型的参数放在形参列表，但必须保证可变参数放在最后</p>
<p>5、一个形参列表只能出现一个可变参数</p>
<pre><code>public static void main(String[] args) &#123;
        System.out.println(sum(1, 2, 5, 630));
        System.out.println(sum(1, 2, 3, 5, 8, 4));
    &#125;
public static int sum(int b, int... a) &#123;
    int sum = 0;
    for (int i : a) &#123;
        sum += i;
    &#125;
    return sum;
&#125;
</code></pre><p><strong>Arrays的一个静态方法:</strong></p>
<ul>
<li><ul>
<li>| <code>static &lt;T&gt; List&lt;T&gt;</code> | <code>asList(T... a)</code>  返回由指定数组支持的固定大小的列表。 |<br>| —————————— | ——————————————————————————— |<br>|                      |                                                        |</li>
</ul>
</li>
</ul>
<p>​        List<String> aList3 = Arrays.asList(“nihao”, “我好”, “大家好”);<br>​        // 不允许改变长度,但是可以修改元素<br>​        // aList3.add(“JAVA”);<br>​        // aList3.remove(0);<br>​        aList3.set(0, “javaee”);<br>​        System.out.println(aList3);</p>
<p><strong>List接口中的一个静态方法(JDK9以及以上)：</strong></p>
<p>//返回包含任意数量元素的不可变列表，不能添加修改删除</p>
<p>List<String>bList2=List.of(“nihao”, “我好”, “大家好”，“nihao”);</p>
<p><strong>Set集合中一个静态方法返回集合中任意数量元素的不可变列表</strong>（JKD9以及以上）</p>
<p>//返回包含任意数量元素的不可变列表，不能添加删除</p>
<p>Set<String>aSet=Set.of(“nihao”, “我好”, “大家好”);//set集合不能添加重复元素</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>1、Map<K, V>   k：键的类型，V：值得类型（一个键对应一个值）</p>
<p>2、put可以将映射的键和值相对性，即添加方法，当第一次添加一个键时是添加操作，同一个键再次赋值即为修改操作</p>
<h3 id="基本功能方法"><a href="#基本功能方法" class="headerlink" title="基本功能方法"></a>基本功能方法</h3><p>1、put方法添加元素</p>
<p>2、remove方法删除元素//（指定的key键），返回对应的V值</p>
<p>3、clear移除所有键值对元素</p>
<p>4、containsKey判断集合是否包含所指定的键</p>
<p>5、containsVaiue判断集合是否包含指定的值</p>
<p>6、isEmpty判断集合是否为空</p>
<p>7、size集合长度，也就是集合中键值对应的个数</p>
<h3 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h3><p>1、V get 根据键获取返回值</p>
<p>2、Set <K>keySet()  获取所有键的集合//Set<String> aMap2=aMap.keySet();</p>
<p>3、Collection<V>values<K,V>enterSet()获取所有键值对象的集合</p>
<p>//Collection<String>aCollection=aMap.values();</p>
<ul>
<li><ul>
<li>| <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code> | <code>entrySet()</code>  返回此地图中包含的映射的<a href="../../java/util/Set.html"><code>Set</code></a>视图。 |<br>| ——————————- | —————————————————————————————— |<br>|                       |                                                              |</li>
</ul>
</li>
</ul>
<h3 id="Map集合的遍历"><a href="#Map集合的遍历" class="headerlink" title="Map集合的遍历"></a>Map集合的遍历</h3><p>1、方法一(获取所有的键集合，遍历键集合中每个键对应的值)</p>
<pre><code>Map&lt;String, String&gt; aMap = new HashMap&lt;String, String&gt;();
    //创建Map集合
    aMap.put(&quot;zxq&quot;, &quot;180&quot;);
    aMap.put(&quot;zwq&quot;, &quot;125&quot;);
    aMap.put(&quot;z6q&quot;, &quot;198&quot;);
    aMap.put(&quot;zxsdq&quot;, &quot;1870&quot;);
    //添加元素
    Set&lt;String&gt; aMap2 = aMap.keySet();
    //获取所有键的集合
    for (String string : aMap2) &#123;
        //增强for根据键去找值，用get（object key）方法实现
        String value = aMap.get(string);
        System.out.println(string+&quot;=&quot;+value);
    &#125;
</code></pre><p>结果：</p>
<p>zxq=180<br>z6q=198<br>zwq=125<br>zxsdq=1870</p>
<p>2、方法二（依次获取一对键值对象，分别获取键和值）</p>
<pre><code>Map&lt;String, String&gt; aMap = new HashMap&lt;String, String&gt;();
    //创建Map集合
    aMap.put(&quot;zxq&quot;, &quot;180&quot;);
    aMap.put(&quot;zwq&quot;, &quot;125&quot;);
    aMap.put(&quot;z6q&quot;, &quot;198&quot;);
    aMap.put(&quot;zxsdq&quot;, &quot;1870&quot;);
    //添加元素
    Set&lt;Map.Entry&lt;String, String&gt;&gt;aSet=aMap.entrySet();
    //遍历键值对对象的集合，得到每一个键值对对象
    for (Map.Entry&lt;String, String&gt; map : aSet) &#123;
        //根据键值对对象获取键和值
        String key=map.getKey();
        String value=map.getValue();
        System.out.println(key+&quot;=&quot;+value);
    &#125;
</code></pre><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="File类的概述和构造方法"><a href="#File类的概述和构造方法" class="headerlink" title="File类的概述和构造方法"></a>File类的概述和构造方法</h3><p>File：它是文件和目录路径名的抽象表示</p>
<p>1、文件和目录是可以通过file封装成对象的</p>
<p>2、对于File而言，器封装的 并不一定是一个真正存在的文件，仅仅是一个路径名而已，可以是存在的，也可以是不存在的</p>
<p>将来是要通过具体的操作把这个路径的内容转换为具体存在的</p>
<p>File  af1=new File(“C:\java.txt”);//将指定的路径名字转换为抽象路径名来创建新的File实现</p>
<h3 id="File类的创建"><a href="#File类的创建" class="headerlink" title="File类的创建"></a>File类的创建</h3><ul>
<li><ul>
<li>| <code>boolean</code> | <code>createNewFile()</code>  当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件。 |<br>| ————- | —————————————————————————————— |<br>|           |                                                              |</li>
</ul>
</li>
<li><ul>
<li><p>| <code>boolean</code> | <code>mkdir()</code>  创建由此抽象路径名命名的目录。                    |<br>| ————- | —————————————————————————————— |<br>| <code>boolean</code> | <code>mkdirs()</code>  创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。 |</p>
<p>​        File  af1=new File(“D:\itcast\java.txt”);<br>​        System.out.println(af1.createNewFile());//创建空文件<br>​        File aFile=new File(“D:\\itcast\\javaSE”);<br>​        System.out.println(aFile.mkdir());//创建目录<br>​        File bFile=new File(“D:\\itcast\\javaSE\HTML”);<br>​        System.out.println(bFile.mkdir());//<br>​        File cFile=new File(“D:\\itcast\\javaWeb\HTML”);<br>​        System.out.println(cFile.mkdirs());//创建多级目录</p>
</li>
</ul>
</li>
</ul>
<p>注意：不能根据文件名称判断创建的是文件还是目录，需要根据调用方法来判断</p>
<h3 id="File类的删除功能"><a href="#File类的删除功能" class="headerlink" title="File类的删除功能"></a>File类的删除功能</h3><ul>
<li><ul>
<li>| <code>boolean</code> | <code>delete()</code>  删除由此抽象路径名表示的文件或目录。 |<br>| ————- | ———————————————————————— |<br>|           |                                                  |</li>
</ul>
</li>
</ul>
<p>删除目录需要先删除当前目录下的文件</p>
<h3 id="File类的判断和获取功能"><a href="#File类的判断和获取功能" class="headerlink" title="File类的判断和获取功能"></a>File类的判断和获取功能</h3><p>​        File file=new File(“D:\itcast\java.txt”);<br>​        //isDirectory()判断是否为目录<br>​        System.out.println(file.isDirectory());<br>​        //isFile()判断是否为文件<br>​        System.out.println(file.isFile());<br>​        //exists()判断是否存在<br>​        System.out.println(file.exists());<br>​        //获取文件的绝对路径<br>​        System.out.println(file.getAbsolutePath());<br>​        //将此抽象类的路径名转换为字符串<br>​        System.out.println(file.getPath());<br>​        //返回次抽象路径名表示的文件或者名称<br>​        System.out.println(file.getName());</p>
<hr>
<p>​        File aFile = new File(“D:\itcast”);<br>​        // String [] list();此方法有局限，获取目录中的文件和目录名称<br>​        String[] aStrings = aFile.list();<br>​        for (String string : aStrings) {<br>​            System.out.println(string);<br>​        }<br>​        // 创建一个File文件对象，在for循环中可以对file进行文件操作，例如判断文件是否存在，输出文件等等<br>​        File[] a = aFile.listFiles();<br>​        for (File file : a) {<br>​            System.out.println(file.getName());<br>​        }</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="1、字节流写数据"><a href="#1、字节流写数据" class="headerlink" title="1、字节流写数据"></a>1、字节流写数据</h3><p>字节流抽象基类：</p>
<p>inputStream：这个抽象类是表示字节输入流的所有类的超类</p>
<p>outputStream：这个抽象类是表示字节输出流的所有类的超类</p>
<p>子类名特点：子类名称都是以其父类作为子类名的后缀</p>
<p>​            1、创建字节流对象</p>
<p>​            2、写数据</p>
<p>​            3、释放资源</p>
<p>​        FileOutputStream aFileOutputStream = new FileOutputStream(“java.txt”);<br>​        aFileOutputStream.write(97);<br>​        aFileOutputStream.close();</p>
<ul>
<li><ul>
<li><p>| <code>void</code>           | <code>close()</code>  关闭此文件输出流并释放与此流相关联的任何系统资源。 |<br>| ———————— | —————————————————————————————— |<br>| <code>protected void</code> | <code>finalize()</code>  清理与文件的连接，并确保当没有更多的引用此流时，将调用此文件输出流的 <code>close</code>方法。 |<br>| <code>FileChannel</code>    | <code>getChannel()</code>  返回与此文件输出流相关联的唯一的<a href="../../java/nio/channels/FileChannel.html"><code>FileChannel</code></a>对象。 |<br>| <code>FileDescriptor</code> | <code>getFD()</code>  返回与此流相关联的文件描述符。                    |<br>| <code>void</code>           | <code>write(byte[] b)</code>  将 <code>b.length</code>个字节从指定的字节数组写入此文件输出流。 |<br>| <code>void</code>           | <code>write(byte[] b,  int off, int len)</code>  将 <code>len</code>字节从位于偏移量 <code>off</code>的指定字节数组写入此文件输出流。 |<br>| <code>void</code>           | <code>write(int b)</code>  将指定的字节写入此文件输出流。               |</p>
<pre><code>FileOutputStream aFileOutputStream = new FileOutputStream(&quot;java.txt&quot;);
    aFileOutputStream.write(97);
    byte []a=&#123;1,2,3&#125;;
    aFileOutputStream.write(a);
    byte []bs=&quot;12345679&quot;.getBytes();
</code></pre><p>//<code>write(byte[] b)</code>  将 <code>b.length</code>个字节从指定的字节数组写入此文件输出流。 </p>
<pre><code>    aFileOutputStream.write(bs);
</code></pre><p>//write(byte[] b,  int off, int len) 将 <code>len</code>字节从位于偏移量 <code>off</code>的指定字节数组写入此文件输出流。</p>
<pre><code>    aFileOutputStream.write(bs, 0, 5);
    aFileOutputStream.close();
</code></pre><h3 id="2、字節流写数据存在的问题"><a href="#2、字節流写数据存在的问题" class="headerlink" title="2、字節流写数据存在的问题"></a>2、字節流写数据存在的问题</h3></li>
</ul>
</li>
</ul>
<p>字节流写数据如何实现换行：</p>
<p>换行使用  :\n</p>
<p>字节流写数据如何追加写入：</p>
<p>追加在创建对象时对append属性：true</p>
<p>​    FileOutputStream aFileOutputStream = new FileOutputStream(“java.txt”, true);<br>​        for (int i = 0; i &lt; 10; i++) {<br>​            aFileOutputStream.write(“i”.getBytes());<br>​            aFileOutputStream.write(“\n”.getBytes());<br>​        }</p>
<h3 id="3、字节流写数据加异常处理"><a href="#3、字节流写数据加异常处理" class="headerlink" title="3、字节流写数据加异常处理"></a>3、字节流写数据加异常处理</h3><p>FileOutputStream aFileOutputStream = null;<br>        try {<br>            aFileOutputStream = new FileOutputStream(“java.txt”, true);<br>            aFileOutputStream.write(“i”.getBytes());<br>            aFileOutputStream.write(“\n”.getBytes());<br>        } catch (IOException e1) {<br>            // TODO 自动生成的 catch 块<br>            e1.printStackTrace();<br>        } finally {<br>            try {<br>                aFileOutputStream.close();<br>            } catch (IOException e) {<br>                // TODO 自动生成的 catch 块<br>                e.printStackTrace();<br>            }</p>
<h3 id="4、字节流读数据（一个一个读）"><a href="#4、字节流读数据（一个一个读）" class="headerlink" title="4、字节流读数据（一个一个读）"></a>4、字节流读数据（一个一个读）</h3><p>FileInputStream aFileInputStream=new FileInputStream(“java.txt”);<br>//一个一个读<br>//        int by=    aFileInputStream.read();<br>//        System.out.println(by);<br>//        System.out.println((char)by);<br>//        aFileInputStream.close();<br>            int by;<br>            while((by=aFileInputStream.read())!=-1){<br>            System.out.print((char)by);<br>        }</p>
<p>采用的是 int read()方法，当没有元素时返回的是-1，所以-1作为判断条件。</p>
<h3 id="从一个文本读数据写到另一个文本案例"><a href="#从一个文本读数据写到另一个文本案例" class="headerlink" title="从一个文本读数据写到另一个文本案例"></a>从一个文本读数据写到另一个文本案例</h3><p>1、打开源文件</p>
<p>2、遍历源文件</p>
<p>3、打开目标文件，将原文件中的数据写到目标文件中</p>
<p>4、关闭目标文件</p>
<p>5、关闭源文件</p>
<p>FileInputStream aFileInputStream=new FileInputStream(“D:\txt.txt”);<br>        int by;<br>        while ((by=aFileInputStream.read())!=-1) {<br>            FileOutputStream aFileOutputStream=new FileOutputStream(“java.txt”,true);<br>            System.out.print((char)by);<br>            aFileOutputStream.write(by);<br>            aFileOutputStream.close();<br>        }<br>        aFileInputStream.close();</p>
<h3 id="字节流读数据一次都一个数组"><a href="#字节流读数据一次都一个数组" class="headerlink" title="字节流读数据一次都一个数组"></a>字节流读数据一次都一个数组</h3><p>//        FileInputStream aFileInputStream=new FileInputStream(“java.txt”);<br>//        byte []bys=new byte[10];<br>//        //第一次读取<br>//        int len=aFileInputStream.read(bys);<br>//        System.out.println(len);<br>//        System.out.println(new String(bys, 0, len));<br>//        //第二次读取<br>//        len=aFileInputStream.read(bys);<br>//        System.out.println(len);<br>//        System.out.println(new String(bys, 0, len));<br>//        aFileInputStream.close();<br>//        //第三次读取<br>//        len=aFileInputStream.read(bys);<br>//        System.out.println(len);<br>//        System.out.println(new String(bys, 0, len));<br>//        aFileInputStream.close();<br>        FileInputStream aFileInputStream=new FileInputStream(“java.txt”);<br>        byte []bys=new byte[1024];<br>        int len;<br>        while((len=aFileInputStream.read(bys))!=-1) {<br>            System.out.print(new String(bys, 0, len));<br>        }</p>
<h3 id="字节流复制图片"><a href="#字节流复制图片" class="headerlink" title="字节流复制图片"></a>字节流复制图片</h3><pre><code>FileInputStream aFileInputStream=new                    FileInputStream(&quot;C:\\Users\\22603\\Pictures\\Saved Pictures\\2.png&quot;);//实例化源文件路径
FileOutputStream aFileOutputStream=new FileOutputStream(&quot;DLA.png&quot;);//实例化目标文件路径
    int len;//定义字节长度
    byte[]bys=new byte[1024];//定义字节数组
    while((len=aFileInputStream.read())!=-1) &#123;//判断条件，当字节长度为-1说明到达文件结尾
        aFileOutputStream.write(bys,0,len);
    &#125;

    aFileInputStream.close();
    aFileOutputStream.close();//关闭文件
</code></pre><h3 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h3><p>BufferOutputStream：该类实现缓冲输出流。通过设置这样的缓冲输出流，应用程序可以向底层输出流写入字节，而不必为写的的每一个字节导致底层系统的调用</p>
<p>BufferInputStream：创建该类将创造一个内部缓冲区数组，当从流中读取或跳过字节时，内部缓冲区，将根据所需要从包含的输入流中重新填充，一次很多字节。</p>
<pre><code>BufferedOutputStream aBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;text1.txt&quot;));
    aBufferedOutputStream.write(&quot;nihaoa&quot;.getBytes());
    // Input读文件
    BufferedInputStream aBufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;text1.txt&quot;));
    int len;
    byte[] a = new byte[1024];
    while ((len = aBufferedInputStream.read(a)) != -1) &#123;

        System.out.println(new String(a, 0, len));
    &#125;
    aBufferedOutputStream.close();
    aBufferedInputStream.close();
</code></pre><p><strong>字节文件（读入，写出）</strong></p>
<h3 id="字节流读写视频"><a href="#字节流读写视频" class="headerlink" title="字节流读写视频"></a>字节流读写视频</h3><pre><code>import java.io.*;

import javax.imageio.stream.FileImageInputStream;

public class DemoMain7 &#123;

    public static void main(String[] args) throws IOException &#123;
        // TODO 自动生成的方法存根
        long start=System.currentTimeMillis();

        method1();  4

//        method2();  2 
//        method3();  3
//        method4();//耗时最少  1
        long endTime=System.currentTimeMillis();
        System.out.println(&quot;共用时:&quot;+(endTime-start)+&quot;毫秒&quot;);
    &#125;
    public static void method1() throws IOException &#123;
        //基本字节流一次写一个字节
        FileInputStream aFileInputStream=new FileInputStream(&quot;C:\\Users\\22603\\Music\\MV\\1.mp4&quot;);
        FileOutputStream aFileOutputStream=new FileOutputStream(&quot;音乐.mp4&quot;);
        int by;
        while ((by=aFileInputStream.read())!=-1) &#123;
            aFileOutputStream.write(by);
        &#125;
    aFileInputStream.close();
    aFileOutputStream.close();
&#125;
public static void method2() throws IOException &#123;
    //基本字节流一次读一个字节数组
    FileInputStream aFileInputStream=new FileInputStream(&quot;C:\\Users\\22603\\Music\\MV\\1.mp4&quot;);
    FileOutputStream aFileOutputStream=new FileOutputStream(&quot;音乐.mp4&quot;);
    byte []a=new byte[1024];
    int len;
    while ((len=aFileInputStream.read(a))!=-1) &#123;
        aFileOutputStream.write(a,0,len);
    &#125;
    aFileInputStream.close();
    aFileOutputStream.close();
&#125;
public static void method3() throws IOException &#123;
    //字节缓冲流一次读一个字节
    BufferedInputStream aBufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;C:\\\\Users\\\\22603\\\\Music\\\\MV\\\\1.mp4&quot;));
    // Input读文件
    BufferedOutputStream aBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;音乐.mp4&quot;));
    int by;
    while ((by=aBufferedInputStream.read())!=-1) &#123;
        aBufferedOutputStream.write(by);
    &#125;

    aBufferedInputStream.close();
    aBufferedOutputStream.close();
&#125;
public static void method4() throws IOException &#123;
    //字节缓冲流一次读一个字节数组
    BufferedInputStream aBufferedInputStream = new BufferedInputStream(new FileInputStream(&quot;C:\\\\Users\\\\22603\\\\Music\\\\MV\\\\1.mp4&quot;));
    // Input读文件
    BufferedOutputStream aBufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;音乐.mp4&quot;));
    int len;
    byte[] a = new byte[1024];
    while ((len = aBufferedInputStream.read(a)) != -1) &#123;

        System.out.println(new String(a, 0, len));
    &#125;
    aBufferedOutputStream.close();
    aBufferedInputStream.close();
    &#125;
&#125;
</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符流写数据、读数据（读写编码需要对应）"><a href="#字符流写数据、读数据（读写编码需要对应）" class="headerlink" title="字符流写数据、读数据（读写编码需要对应）"></a>字符流写数据、读数据（读写编码需要对应）</h3><ul>
<li><ul>
<li>| <code>OutputStreamWriter(OutputStream out)</code>  创建一个使用默认字符编码的OutputStreamWriter。 |<br>| —————————————————————————————— |<br>| <code>OutputStreamWriter(OutputStream out, Charset cs)</code>  创建一个使用给定字符集的OutputStreamWriter。 |</li>
</ul>
</li>
<li><ul>
<li><p>| <code>InputStreamReader(InputStream in)</code>  创建一个使用默认字符集的InputStreamReader。 |<br>| —————————————————————————————— |<br>| <code>InputStreamReader(InputStream in, Charset cs)</code>  创建一个使用给定字符集的InputStreamReader。 |<br>| <code>InputStreamReader(InputStream in, CharsetDecoder dec)</code>  创建一个使用给定字符集解码器的InputStreamReader。 |<br>| <code>InputStreamReader(InputStream in, String charsetName)</code>  创建一个使用命名字符集的InputStreamReader。 |</p>
<p>//        OutputStreamWriter(OutputStream out)<br>//        创建一个使用默认字符编码的OutputStreamWriter。<br>//        OutputStreamWriter(OutputStream out, Charset cs)<br>//        创建一个使用给定字符集的OutputStreamWriter。  </p>
<pre><code>    OutputStreamWriter aFileOutputStream=new OutputStreamWriter(
            new FileOutputStream(&quot;test.txt&quot;),&quot;utf-8&quot;);
    aFileOutputStream.write(&quot;测试文件&quot;);
    aFileOutputStream.close();
</code></pre><p>//        InputStreamReader(InputStream in)<br>//        创建一个使用默认字符集的InputStreamReader。<br>//        InputStreamReader(InputStream in, String charsetName)<br>//        创建一个使用命名字符集的InputStreamReader。  </p>
<pre><code>    InputStreamReader aInputStreamReader=new 
            InputStreamReader(new FileInputStream(&quot;test.txt&quot;),&quot;utf-8&quot;);
    int by;
    while ((by=aInputStreamReader.read())!=-1) &#123;
        System.out.print((char)by);
    &#125;
    aInputStreamReader.close();
</code></pre></li>
</ul>
</li>
</ul>
<p>字符流写数据、读数据</p>
<h3 id="close和flush区别"><a href="#close和flush区别" class="headerlink" title="close和flush区别"></a>close和flush区别</h3><ul>
<li><ul>
<li>| <code>void</code> | <code>close()</code>  关闭流，先刷新。 |<br>| ——— | —————————————- |<br>| <code>void</code> | <code>flush()</code>  刷新流。         |</li>
</ul>
</li>
</ul>
<p>使用close后无法写数据，使用flush后还可以写数据。</p>
<p>OutputStreamWriter aFileOutputStream=new OutputStreamWriter(<br>                new FileOutputStream(“test1.txt”),”utf-8”);<br>        aFileOutputStream.write(97);<br>        //aFileOutputStream.flush();<br>        aFileOutputStream.write(97);<br>        //aFileOutputStream.flush();<br>        aFileOutputStream.close();</p>
<h3 id="字符流写数据的五种方法"><a href="#字符流写数据的五种方法" class="headerlink" title="字符流写数据的五种方法"></a>字符流写数据的五种方法</h3><p>OutputStreamWriter aFileOutputStream=new OutputStreamWriter(<br>                new FileOutputStream(“test1.txt”),”utf-8”);</p>
<p>1、一次写一个字符    </p>
<p>​        aFileOutputStream.write(97);<br>​        //aFileOutputStream.flush();<br>​        aFileOutputStream.write(97);<br>​        //aFileOutputStream.flush();<br>​        aFileOutputStream.close();</p>
<p>2、一次写一个字符数组</p>
<p>​        char a[]={‘f’,’f’,’f’,’f’,’f’,’f’,’f’,’f’};<br>​        aFileOutputStream.write(a);<br>​        aFileOutputStream.close();</p>
<p>3、一次写一字符数组部分数据</p>
<p> 调用的是 void write(cbuf, off, len);  </p>
<pre><code>    char a[]=&#123;&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;,&#39;f&#39;&#125;;
        aFileOutputStream.write(a, 1, 3);
        aFileOutputStream.close();
</code></pre><p>4、一次写一个字符串</p>
<p>​        aFileOutputStream.write(“acdac”);<br>​        aFileOutputStream.close();</p>
<p>5、一次写字符串的一部分</p>
<pre><code>    aFileOutputStream.write(&quot;acdac&quot;, 1, 3);
    aFileOutputStream.close();
</code></pre><p>aFileOutputStream.close();</p>
<h3 id="字符流读数据的两种方法"><a href="#字符流读数据的两种方法" class="headerlink" title="字符流读数据的两种方法"></a>字符流读数据的两种方法</h3><p>InputStreamReader aStreamReader=new<br>InputStreamReader(new FileInputStream(“test1.txt”));</p>
<p>1、一次读一个字符</p>
<p>​    int by;<br>​        while ((by=aStreamReader.read())!=-1) {<br>​            System.out.println((char)by);<br>​        }</p>
<p>2、一次读一个字符数组</p>
<p>​    char []a=new char[1024];<br>​        int len;<br>​        while ((len=aStreamReader.read(a))!=-1) {<br>​            System.out.print(new String(a,0,len));<br>​        }</p>
<p>aStreamReader.close();</p>
<h2 id="读写文件最简单的方法"><a href="#读写文件最简单的方法" class="headerlink" title="读写文件最简单的方法"></a>读写文件最简单的方法</h2><p>​        FileWriter aFileWriter=new FileWriter(“test1.txt”);<br>​        FileReader aFileReader=new FileReader(“test1.txt”);</p>
<p><strong>FileWriter 和 FileReader 分别是OutputStreamWriter 和 InputStreamReader 的子类。但不可以转换编码，如需转换编码仍需要用父类</strong></p>
<h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><p>BufferedReader aaReader=new BufferedReader(new FileReader(“test1.txt”));<br>BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(“test1.txt”));</p>
<p>特有方法：</p>
<p>1、 BufferedReader aaReader=new BufferedReader(new FileReader(“test1.txt”));<br>        String line;<br>        while ((line=aaReader.readLine())!=null) {//readLine读取一行的数据，不读取换行符<br>            System.out.println(line);<br>        }<br>        aaReader.close();</p>
<p>2、  BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(“test1.txt”));<br>        aBufferedWriter.write(“nihao”);<br>        aBufferedWriter.newLine();//换行符<br>        aBufferedWriter.close();</p>
<h3 id="字符缓冲流特有功能复制文件（最常用）"><a href="#字符缓冲流特有功能复制文件（最常用）" class="headerlink" title="字符缓冲流特有功能复制文件（最常用）"></a>字符缓冲流特有功能复制文件（最常用）</h3><p>​        BufferedReader aBufferedReader=new BufferedReader(new FileReader(“test1.txt”));<br>​        BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(“test2.txt”));<br>​        String line;<br>​        while ((line=aBufferedReader.readLine())!=null) {<br>​            aBufferedWriter.write(line);<br>​            aBufferedWriter.newLine();<br>​            aBufferedWriter.flush();<br>​        }<br>​        aBufferedReader.close();<br>​        aBufferedWriter.close();</p>
<h3 id="io流小结"><a href="#io流小结" class="headerlink" title="io流小结"></a>io流小结</h3><p><img src="E:\sql学习资料\~8RDVBOGIK7N8S4IUX8E_P2.png" alt="img"></p>
<p><img src="E:\sql学习资料\1.png" alt="img"></p>
<h3 id="集合到文件"><a href="#集合到文件" class="headerlink" title="集合到文件"></a>集合到文件</h3><p>​        ArrayList<String> arrayList = new ArrayList<String>();<br>​        arrayList.add(“nihao”);<br>​        arrayList.add(“wohao”);<br>​        arrayList.add(“dajiahao”);<br>​        BufferedWriter aBufferedWriter = new BufferedWriter(new FileWriter(“test3.txt”));<br>​        for (String string : arrayList) {<br>​            aBufferedWriter.write(string);<br>​            aBufferedWriter.newLine();<br>​            aBufferedWriter.flush();<br>​        }<br>​        aBufferedWriter.close();</p>
<h3 id="文件到集合"><a href="#文件到集合" class="headerlink" title="文件到集合"></a>文件到集合</h3><p>​        BufferedReader aBufferedReader = new BufferedReader(new FileReader(“test3.txt”));<br>​        ArrayList<String> arrayList = new ArrayList&lt;&gt;();<br>​        String line;<br>​        while ((line = aBufferedReader.readLine()) != null) {<br>​            arrayList.add(line);<br>​        }<br>​        aBufferedReader.close();<br>​        for (String string : arrayList) {<br>​            System.out.println(string);<br>​        }</p>
<h3 id="点名器"><a href="#点名器" class="headerlink" title="点名器"></a>点名器</h3><pre><code>    ArrayList&lt;Student&gt;arrayList=new ArrayList&lt;&gt;();
        BufferedWriter aBufferedWriter=new BufferedWriter(new FileWriter(&quot;test4.txt&quot;));
        Student a1=new Student(&quot;1001&quot;,&quot;zxq&quot;,&quot;18&quot;,&quot;xians&quot;);
        Student a2=new Student(&quot;1002&quot;,&quot;sss&quot;,&quot;18&quot;,&quot;xianan&quot;);
        Student a3=new Student(&quot;1003&quot;,&quot;sff&quot;,&quot;18&quot;,&quot;xianss&quot;);
        Student a4=new Student(&quot;1004&quot;,&quot;www&quot;,&quot;18&quot;,&quot;xiandf&quot;);
        arrayList.add(a1);
        arrayList.add(a2);
        arrayList.add(a3);
        arrayList.add(a4);
        for (Student student : arrayList) &#123;
            StringBuffer stringBuffer=new StringBuffer();
            stringBuffer.append(student.getName()).append(&quot;,&quot;).append(student.getAge()).append(&quot;,&quot;).
            append(student.getAddress());
            aBufferedWriter.write(stringBuffer.toString());
            aBufferedWriter.newLine();
            aBufferedWriter.flush();
        &#125;
    aBufferedWriter.close();
</code></pre><h3 id="复制单级文件夹"><a href="#复制单级文件夹" class="headerlink" title="复制单级文件夹"></a>复制单级文件夹</h3><pre><code>package Demo3;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import javax.swing.text.DefaultEditorKit.CopyAction;

//TODO 自动生成的方法存根
        //1、创建数据源目录File对象 ，路径为C:\Users\22603\Pictures\Saved Pictures
        //2、获取数据源目录File对象的名称，即文件所保存的外层文件夹，Saved Pictures
        //3、创建目的地目录File对象，路径名是File+Saved Pictures
        //4、判断目的地目录对应的File是否存在，如果不存在，就创建
        //5、获得数据源目录下所有文件的File数组
        //6、遍历File数组，得到每一个File对象，其实就是数据源文件
        //7、获得数据源文件File对象的，名称
        //8、创建目的地文件File对象，路径名是目的地目录File\\Saved Pictures\\+.png
        //9、复制文件，采用字节流
public class DemoMain1 &#123;
public static void main(String[] args) throws IOException &#123;

    //1、创建数据源目录File对象 ，路径为C:\\pecsa
    File srcFind=new File(&quot;C:\\pecsa&quot;);
    //2、获取数据源目录File对象的名称，即文件所保存的外层文件夹，pecsa
    String aString=srcFind.getName();
    //3、创建目的地目录File对象，路径名是File+Saved Pictures
    File Creade=new File(&quot;File&quot;,aString);
    //4、判断目的地目录对应的File是否存在，如果不存在，就创建
    if (!Creade.exists()) &#123;
        Creade.mkdir();
    &#125;
    //5、获得数据源目录下所有文件的File数组
    File[]list=srcFind.listFiles();
    //6、遍历File数组，得到每一个File对象，其实就是数据源文件
    for (File file : list) &#123;
    //7、获得目录下的每个文件名
    String srcFileName=file.getName();
    //8、创建目的地文件File对象，路径名是目的地目录File\\Saved Pictures\\+.png
    File destFile=new File(Creade,srcFileName);
    //9、复制文件，采用字节流，这里的File是源文件名，destFile是新创建的文件对象
    CopyFile(file,destFile);
    &#125;    
&#125;

private static void CopyFile(File file, File destFile) throws IOException &#123;
    // TODO 自动生成的方法存根
    BufferedOutputStream aBufferedOutputStream=new BufferedOutputStream(new FileOutputStream(destFile));
    BufferedInputStream aBufferedInputStream=new BufferedInputStream(new FileInputStream(file));
    byte a[]=new byte[1024];
    int len;
    while((len=aBufferedInputStream.read(a))!=-1) &#123;
        aBufferedOutputStream.write(a,0,len);
    &#125;
    aBufferedOutputStream.close();
    aBufferedInputStream.close();
    &#125;    
&#125;
</code></pre><h2 id="复制多级文件（用到时回头看）"><a href="#复制多级文件（用到时回头看）" class="headerlink" title="复制多级文件（用到时回头看）"></a>复制多级文件（用到时回头看）</h2><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1、进程"><a href="#1、进程" class="headerlink" title="1、进程"></a>1、进程</h3><p>​    进程是正在运行的程序，是系统进行资源分配和调用的独立单位</p>
<p>​    每个进程都有他自己的内存空间和系统资源</p>
<h3 id="2、线程"><a href="#2、线程" class="headerlink" title="2、线程"></a>2、线程</h3><p>​    线程是进程的单个顺序控制流，是一条执行路径</p>
<p>单线程：一个进程如果只有一条执行路径，则称为单线程程序</p>
<p>多线程：一个进程如果有多个执行路径，则成为多线程程序</p>
<p>举例：记事本程序（单线程）</p>
<p>​            扫雷程序（多线程）</p>
<h3 id="3、多线程的实现方式"><a href="#3、多线程的实现方式" class="headerlink" title="3、多线程的实现方式"></a>3、多线程的实现方式</h3><p>（方式1）：继承Thread类</p>
<p>​                定义一个类继承Thread类，并重写该类中的run方法，创建多个对象，调用start方法执行多线程44</p>
<h3 id="4、设置和获取线程名称"><a href="#4、设置和获取线程名称" class="headerlink" title="4、设置和获取线程名称"></a>4、设置和获取线程名称</h3><p>底层远吗中默认有getName和setName方法，为了简化我们可以在创建子类对象时传进去name，即有参构造方法</p>
<p>Thread(String name) 分配一个新的 Thread对象。 </p>
<p>static Thread currentThread() 返回对当前正在执行的线程对象的引用。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">		MyThread a1=new MyThread(&quot;线程1&quot;);</span><br><span class="line">		MyThread a2=new MyThread(&quot;线程2&quot;);</span><br><span class="line">		a1.setName(&quot;线程1&quot;);</span><br><span class="line">		a2.setName(&quot;线程2&quot;);</span><br><span class="line">		a1.start();</span><br><span class="line">		a2.start();</span><br><span class="line">		System.out.println(Thread.currentThread().getName());//获取正在执行的线程对象的引用</span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">	public MyThread(String name) &#123;</span><br><span class="line">		// TODO 自动生成的构造函数存根</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		for (int i = 0; i &lt; 600; i++) &#123;</span><br><span class="line">			System.out.println(getName()+&quot;：&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、线程调度"><a href="#5、线程调度" class="headerlink" title="5、线程调度"></a>5、线程调度</h3><p><strong>分配调度模型</strong>：所有线程轮流使用cpu的权，平均分配每个线程占用cpu的时间片</p>
<p><strong>抢占式调度模型</strong>：优先让优先级搞得线程使用cpu，如果线程优先级相同，随机选择一个，优先级高的线程获取cpu的时间相对多一点</p>
<p>java使用的是抢占式调度模型</p>
<p>//int getPriority() 返回此线程的优先级。 （线程优先级最高为10,最低为1，默认为5）<br>//void setPriority(int newPriority) 更改此线程的优先级。  </p>
<pre><code>    MyThread a1=new MyThread(&quot;线程1&quot;);
    MyThread a2=new MyThread(&quot;线程2&quot;);
    a1.setPriority(10);
    a2.setPriority(1);
</code></pre><p>改变线程优先级是优先级高的表示获取cpu时间片的几率高一点，并不是彻底改变优先级次序</p>
<h3 id="6、线程控制"><a href="#6、线程控制" class="headerlink" title="6、线程控制"></a>6、线程控制</h3><p>（1）<strong>//static void sleep(long millis)</strong> 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。  </p>
<p>public void run() {<br>        // TODO 自动生成的方法存根<br>        for (int i = 0; i &lt; 600; i++) {<br>            System.out.println(getName()+”：”+i);<br>        }<br>        try {<br>            //static void sleep(long millis) 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）<br>            //，具体取决于系统定时器和调度程序的精度和准确性。<br>            Thread.sleep(10);<br>        } catch (InterruptedException e) {<br>            // TODO 自动生成的 catch 块<br>            e.printStackTrace();<br>        }<br>    }</p>
<p>（2）<strong>//void join() 等待这个线程死亡。</strong>  </p>
<p>​        Test a1=new Test(“刘备”);<br>​        Test a2=new Test(“孙权”);<br>​        Test a3=new Test(“曹操”);<br>​        //void join() 等待这个线程死亡。<br>​        a1.start();<br>​        //这里的意思是等刘备死后孙权和曹操抢占cup时间<br>​        a1.join();<br>​        a2.start();<br>​        a3.start();</p>
<p><strong>（3）//void setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。</strong>  </p>
<pre><code>Test a1=new Test(&quot;刘备&quot;);
    Test a2=new Test(&quot;张飞&quot;);
    Thread.currentThread().setName(&quot;关羽&quot;);//为当前main线程重新命名
    //void setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。即主线程死亡后守卫线程也灭亡
    //设置守护线程
    a1.setDaemon(true);
    a2.setDaemon(true);
    a1.start();
    a2.start();
    for (int i = 0; i &lt; 100; i++) &#123;
        System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
    &#125;
    **ps：主线程灭亡后，守卫不会立马死亡，会挣扎运行一段时间**
</code></pre><p><strong>ps：主线程灭亡后，守卫不会立马死亡，会挣扎运行一段时间</strong></p>
<h3 id="7、另一种多线程实现方式-实现Runnable接口"><a href="#7、另一种多线程实现方式-实现Runnable接口" class="headerlink" title="7、另一种多线程实现方式(实现Runnable接口)"></a>7、另一种多线程实现方式(实现Runnable接口)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package bb;</span><br><span class="line"></span><br><span class="line">public class Test implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(i);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO 自动生成的 catch 块</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread aThread=new Thread(new Test(),&quot;zxq&quot;);</span><br><span class="line">		Thread bThread=new Thread(new Test());</span><br><span class="line">		//aThread.setName(&quot;zxq&quot;);</span><br><span class="line">		bThread.setName(&quot;sss&quot;);</span><br><span class="line">		aThread.setPriority(10);</span><br><span class="line">		bThread.setPriority(1);</span><br><span class="line">		aThread.start();</span><br><span class="line">		//aThread.join();</span><br><span class="line">		bThread.start();</span><br></pre></td></tr></table></figure>
<p>相比继承Thread类，实现Runnable接口的好处:</p>
<p>1、避免了java单继承的局限性</p>
<p>2、适合多个相同程序的代码去处理同一个资源的情况，吧线程和程序的代码、数据有效分离，较好的体现了面向对象的设计思想</p>
<h3 id="8、数据安全问题"><a href="#8、数据安全问题" class="headerlink" title="8、数据安全问题"></a>8、数据安全问题</h3><p><strong>是否是多线程环境</strong></p>
<p><strong>是否有共享数据</strong></p>
<p><strong>是否有多条语句操作共享数据</strong></p>
<h3 id="9、线程同步代码块"><a href="#9、线程同步代码块" class="headerlink" title="9、线程同步代码块"></a>9、线程同步代码块</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package Sell;</span><br><span class="line"></span><br><span class="line">public class SellTacket implements Runnable &#123;</span><br><span class="line">	private static int tacket = 1000;</span><br><span class="line">	Object obj = new Object();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			synchronized (&quot;&quot;) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">				if (tacket &gt; 0) &#123;</span><br><span class="line">					Thread.sleep(20);</span><br><span class="line">					System.out.println(&quot;剩余票是为:&quot; + tacket+&quot;购票成功,购票地点为:&quot; + Thread.currentThread().getName());</span><br><span class="line">					tacket--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				catch (InterruptedException e) &#123;</span><br><span class="line">					// TODO 自动生成的 catch 块</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10、同步方法"><a href="#10、同步方法" class="headerlink" title="10、同步方法"></a>10、同步方法</h3><p>把synchronized关键字加到方法上</p>
<p>修饰符 synchronized 返回值类型 方法名(方法参数){ }</p>
<p>同步方法的锁对象是什么?</p>
<p>this</p>
<p>同步静态方法：就是把synchronized关键字加到静态方法上</p>
<p>同步静态方法的锁对象是什么?</p>
<p>类名.class</p>
<h3 id="11、线程安全的类"><a href="#11、线程安全的类" class="headerlink" title="11、线程安全的类"></a>11、线程安全的类</h3><p>（1）StringBuffer从jdk5开始被stringBuilder替代，通常应使用stringBuilder类</p>
<p>（2）vector从java2平台V1.2开始，该类改进了list接口，如果不需要线程安全的实现，建议使用arraylist替代vector</p>
<p>（3）Hashtable</p>
<p>实现了哈希表，如果不需要线程安全的实现，建议使用Hashmap替代Hashtable</p>
<p>12、</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>1、枚举是一种特殊的类，一般用来表示常量。</p>
<p>2、Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p>
<p>3、每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。</p>
<p>4、枚举既可以单独写一个类，也可以在已经定义的类中写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DemoMain1 &#123;</span><br><span class="line">	enum color&#123;</span><br><span class="line">		Red,Green,Blue;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		color aColor=color.Red;</span><br><span class="line">		System.out.println(aColor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等同于:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DemoMain1 &#123;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// TODO 自动生成的方法存根</span><br><span class="line">		color aColor=color.Red;</span><br><span class="line">		System.out.println(aColor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">enum color&#123;</span><br><span class="line">	Red,Green,Blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、迭代枚举元素</p>
<p>for (color c : color.values()) {<br>            System.out.println(c);<br>        }</p>
<p>6、values(), ordinal() 和 valueOf() 方法</p>
<p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li><p>values() 返回枚举类中所有的值。</p>
</li>
<li><p>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</p>
</li>
<li><p>valueOf()方法返回指定字符串值的枚举常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	color aColor=color.Red;</span><br><span class="line">	System.out.println(aColor);</span><br><span class="line">	for (color c : color.values()) &#123;</span><br><span class="line">		System.out.println(c+&quot; &quot;+c.ordinal());//ordinal返回索引下标</span><br><span class="line">		System.out.println(c.valueOf(&quot;Red&quot;));//返回指定字符串值的枚举常量</span><br><span class="line">	&#125;</span><br><span class="line">enum&#123;</span><br><span class="line">Red,Green,Blue;	</span><br><span class="line">	private color()&#123;</span><br><span class="line">	System.out.println(this.toString());</span><br><span class="line">&#125;</span><br><span class="line"> public void colorInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Universal Color&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>7、枚举类成员</p>
<p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。</p>
<p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p>
<p>构造函数时，创建对象就会调用，遍历枚举类中的所有常量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum Color&#123;</span><br><span class="line">    RED&#123;</span><br><span class="line">        public String getColor()&#123;//枚举对象实现抽象方法</span><br><span class="line">            return &quot;红色&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GREEN&#123;</span><br><span class="line">        public String getColor()&#123;//枚举对象实现抽象方法</span><br><span class="line">            return &quot;绿色&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLUE&#123;</span><br><span class="line">        public String getColor()&#123;//枚举对象实现抽象方法</span><br><span class="line">            return &quot;蓝色&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public abstract String getColor();//定义抽象方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test&#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (Color c:Color.values())&#123;</span><br><span class="line">            System.out.print(c.getColor() + &quot;、&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com">小张</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2021/09/17/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/2021/09/17/java基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com" target="_blank">keep Study</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/./img/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/09/24/Mysql/" title="Mysql笔记"><img class="cover" src="/./img/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mysql笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/24/Mysql/" title="Mysql笔记"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-24</div><div class="title">Mysql笔记</div></div></a></div><div><a href="/2023/09/12/SpringCloud01/" title="SpringCloudDay1"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-12</div><div class="title">SpringCloudDay1</div></div></a></div><div><a href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/" title="SpringCloudDay2"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-14</div><div class="title">SpringCloudDay2</div></div></a></div><div><a href="/2022/12/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-24</div><div class="title">Redis笔记</div></div></a></div><div><a href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记"><img class="cover" src="/./img/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-24</div><div class="title">RabbitMQ笔记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODc3NS8zNTIzNw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小张</div><div class="author-info__description">记录代码日常</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://keepcheerful.github.io/" target="_blank" title="Github"><i class="iconfont icon-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">java基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.1.</span> <span class="toc-text">java转义字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-number">1.2.</span> <span class="toc-text">java常见错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">文档注释：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.5.</span> <span class="toc-text">java代码规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOS%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">DOS原理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOS%E5%91%BD%E4%BB%A4"><span class="toc-number">1.7.</span> <span class="toc-text">DOS命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">1.8.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">1.9.</span> <span class="toc-text">字符型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.10.</span> <span class="toc-text">字符型本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCLL%E8%A1%A8"><span class="toc-number">1.11.</span> <span class="toc-text">ASCLL表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unicode"><span class="toc-number">1.12.</span> <span class="toc-text">unicode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#utf-8"><span class="toc-number">1.13.</span> <span class="toc-text">utf-8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gbk"><span class="toc-number">1.14.</span> <span class="toc-text">gbk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean%EF%BC%88%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">1.15.</span> <span class="toc-text">boolean（布尔类型）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.16.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Cstring%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.17.</span> <span class="toc-text">基本数据类型和string类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E9%9A%BE%E7%82%B9"><span class="toc-number">1.18.</span> <span class="toc-text">算术运算符难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.19.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.20.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%92%8C%E7%BB%86%E8%8A%82"><span class="toc-number">1.21.</span> <span class="toc-text">数组使用注意事项和细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.22.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%EF%BC%88%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%8C%E7%BD%97%E6%B1%89%E5%A1%94%EF%BC%8C%E5%85%AB%E4%B8%AA%E7%9A%87%E5%90%8E%EF%BC%89-p222-p227-%E8%80%81%E9%9F%A9java"><span class="toc-number">1.23.</span> <span class="toc-text">递归调用（迷宫问题，罗汉塔，八个皇后）(p222-p227)老韩java</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">1.24.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.25.</span> <span class="toc-text">变量作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.25.1.</span> <span class="toc-text">注意事项：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">1.26.</span> <span class="toc-text">构造函数&#x2F;构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.26.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E4%BB%A5%E5%8F%8AStringBuilder"><span class="toc-number">1.27.</span> <span class="toc-text">string以及StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E6%96%B9%E6%B3%95"><span class="toc-number">1.28.</span> <span class="toc-text">StringBuffer 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string%E4%B8%8Estringbuilder%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.29.</span> <span class="toc-text">string与stringbuilder之间的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.30.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%EF%BC%8CArrayList%EF%BC%9A"><span class="toc-number">1.30.1.</span> <span class="toc-text">集合的底层是一个可变数组，ArrayList：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.30.2.</span> <span class="toc-text">ArrayList构造方法和添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.30.3.</span> <span class="toc-text">ArrayList常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.31.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9C%A8%E5%AD%90%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B8%AD%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><span class="toc-number">1.31.1.</span> <span class="toc-text">1、在子类方法中访问一个变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.31.2.</span> <span class="toc-text">2、super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.31.3.</span> <span class="toc-text">3、继承中构造方法的访问特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.31.4.</span> <span class="toc-text">4、继承中成员方法的访问特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.31.5.</span> <span class="toc-text">5、方法重写注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BB%A7%E6%89%BF%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.31.6.</span> <span class="toc-text">6、继承注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.32.</span> <span class="toc-text">包的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.33.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.34.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%89%8D%E6%8F%90%E5%92%8C%E4%BD%93%E7%8E%B0"><span class="toc-number">1.34.1.</span> <span class="toc-text">多态的前提和体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">1.34.2.</span> <span class="toc-text">访问特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">1.34.3.</span> <span class="toc-text">多态的好处和弊端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="toc-number">1.34.4.</span> <span class="toc-text">多态的转型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">1.35.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.36.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.37.</span> <span class="toc-text">类和接口的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.38.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.39.</span> <span class="toc-text">接口名作为形参和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.40.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.40.1.</span> <span class="toc-text">内部类的访问特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.40.2.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.40.3.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.40.4.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system"><span class="toc-number">1.40.5.</span> <span class="toc-text">system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object"><span class="toc-number">1.40.6.</span> <span class="toc-text">Object</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays"><span class="toc-number">1.41.</span> <span class="toc-text">Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-number">1.42.</span> <span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">1.43.</span> <span class="toc-text">日期类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">1.44.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="toc-number">1.44.1.</span> <span class="toc-text">异常体系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection"><span class="toc-number">1.45.</span> <span class="toc-text">collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">1.45.1.</span> <span class="toc-text">Collection 集合的常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collection%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.45.2.</span> <span class="toc-text">collection集合的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.45.3.</span> <span class="toc-text">集合的使用步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.46.</span> <span class="toc-text">list集合概述和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8List%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF"><span class="toc-number">1.46.1.</span> <span class="toc-text">使用List集合存储学生类对象信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">1.46.2.</span> <span class="toc-text">List并发修改异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ListIterator%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%A8%E7%9A%84%E4%B8%8D%E5%A4%9A-%E5%A4%9A%E7%94%A8Iterator"><span class="toc-number">1.47.</span> <span class="toc-text">ListIterator列表迭代器(用的不多,多用Iterator)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.47.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.48.</span> <span class="toc-text">增强for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.49.</span> <span class="toc-text">三种遍历集合的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E9%9B%86%E5%90%88%E5%AD%90%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="toc-number">1.50.</span> <span class="toc-text">List集合子类特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD"><span class="toc-number">1.51.</span> <span class="toc-text">LinkedList集合的特有功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.52.</span> <span class="toc-text">Set集合的概述和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">1.53.</span> <span class="toc-text">哈希值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E9%9B%86%E5%90%88%E7%9A%84%E6%A6%82%E8%BF%B0%E7%89%B9%E7%82%B9"><span class="toc-number">1.54.</span> <span class="toc-text">HashSet集合的概述特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0%E5%8E%9F%E7%90%86"><span class="toc-number">1.55.</span> <span class="toc-text">哈希表存储元素原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkerHashSet%E9%9B%86%E5%90%88"><span class="toc-number">1.56.</span> <span class="toc-text">LinkerHashSet集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeSet%E9%9B%86%E5%90%88%EF%BC%88%E6%AF%94%E8%BE%83%E5%99%A8%EF%BC%89"><span class="toc-number">1.57.</span> <span class="toc-text">TreeSet集合（比较器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparator"><span class="toc-number">1.58.</span> <span class="toc-text">Comparator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E7%BB%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.59.</span> <span class="toc-text">成绩排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.60.</span> <span class="toc-text">随机数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.61.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">1.61.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.61.2.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.61.3.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">1.61.4.</span> <span class="toc-text">类型通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.61.5.</span> <span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map"><span class="toc-number">1.62.</span> <span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">1.62.1.</span> <span class="toc-text">基本功能方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">1.62.2.</span> <span class="toc-text">获取功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.62.3.</span> <span class="toc-text">Map集合的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File"><span class="toc-number">1.63.</span> <span class="toc-text">File</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.63.1.</span> <span class="toc-text">File类的概述和构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.63.2.</span> <span class="toc-text">File类的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">1.63.3.</span> <span class="toc-text">File类的删除功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB%E7%9A%84%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">1.63.4.</span> <span class="toc-text">File类的判断和获取功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">1.64.</span> <span class="toc-text">字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">1.64.1.</span> <span class="toc-text">1、字节流写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AD%97%E7%AF%80%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.64.2.</span> <span class="toc-text">2、字節流写数据存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.64.3.</span> <span class="toc-text">3、字节流写数据加异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%E4%B8%AA%E4%B8%80%E4%B8%AA%E8%AF%BB%EF%BC%89"><span class="toc-number">1.64.4.</span> <span class="toc-text">4、字节流读数据（一个一个读）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E8%AF%BB%E6%95%B0%E6%8D%AE%E5%86%99%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%96%87%E6%9C%AC%E6%A1%88%E4%BE%8B"><span class="toc-number">1.64.5.</span> <span class="toc-text">从一个文本读数据写到另一个文本案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E4%B8%80%E6%AC%A1%E9%83%BD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">1.64.6.</span> <span class="toc-text">字节流读数据一次都一个数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87"><span class="toc-number">1.64.7.</span> <span class="toc-text">字节流复制图片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">1.64.8.</span> <span class="toc-text">字节缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%86%99%E8%A7%86%E9%A2%91"><span class="toc-number">1.64.9.</span> <span class="toc-text">字节流读写视频</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.65.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E3%80%81%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%88%E8%AF%BB%E5%86%99%E7%BC%96%E7%A0%81%E9%9C%80%E8%A6%81%E5%AF%B9%E5%BA%94%EF%BC%89"><span class="toc-number">1.65.1.</span> <span class="toc-text">字符流写数据、读数据（读写编码需要对应）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close%E5%92%8Cflush%E5%8C%BA%E5%88%AB"><span class="toc-number">1.65.2.</span> <span class="toc-text">close和flush区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.65.3.</span> <span class="toc-text">字符流写数据的五种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.65.4.</span> <span class="toc-text">字符流读数据的两种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.66.</span> <span class="toc-text">读写文件最简单的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">1.67.</span> <span class="toc-text">字符缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">1.67.1.</span> <span class="toc-text">字符缓冲流特有功能复制文件（最常用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%B5%81%E5%B0%8F%E7%BB%93"><span class="toc-number">1.67.2.</span> <span class="toc-text">io流小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-number">1.67.3.</span> <span class="toc-text">集合到文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%B0%E9%9B%86%E5%90%88"><span class="toc-number">1.67.4.</span> <span class="toc-text">文件到集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%90%8D%E5%99%A8"><span class="toc-number">1.67.5.</span> <span class="toc-text">点名器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8D%95%E7%BA%A7%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">1.67.6.</span> <span class="toc-text">复制单级文件夹</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%A4%9A%E7%BA%A7%E6%96%87%E4%BB%B6%EF%BC%88%E7%94%A8%E5%88%B0%E6%97%B6%E5%9B%9E%E5%A4%B4%E7%9C%8B%EF%BC%89"><span class="toc-number">1.68.</span> <span class="toc-text">复制多级文件（用到时回头看）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.69.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.69.1.</span> <span class="toc-text">1、进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.69.2.</span> <span class="toc-text">2、线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.69.3.</span> <span class="toc-text">3、多线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="toc-number">1.69.4.</span> <span class="toc-text">4、设置和获取线程名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.69.5.</span> <span class="toc-text">5、线程调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.69.6.</span> <span class="toc-text">6、线程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.69.7.</span> <span class="toc-text">7、另一种多线程实现方式(实现Runnable接口)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">1.69.8.</span> <span class="toc-text">8、数据安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">1.69.9.</span> <span class="toc-text">9、线程同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.69.10.</span> <span class="toc-text">10、同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">1.69.11.</span> <span class="toc-text">11、线程安全的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.70.</span> <span class="toc-text">枚举</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/" title="SpringCloudDay2"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloudDay2"/></a><div class="content"><a class="title" href="/2023/09/14/SpringCloud%E5%AE%9E%E7%94%A8%E7%AF%8702/" title="SpringCloudDay2">SpringCloudDay2</a><time datetime="2023-09-14T02:29:58.000Z" title="发表于 2023-09-14 10:29:58">2023-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/12/hello-world/" title="Hello World"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2023/09/12/hello-world/" title="Hello World">Hello World</a><time datetime="2023-09-12T09:32:40.000Z" title="发表于 2023-09-12 17:32:40">2023-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/12/SpringCloud01/" title="SpringCloudDay1"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloudDay1"/></a><div class="content"><a class="title" href="/2023/09/12/SpringCloud01/" title="SpringCloudDay1">SpringCloudDay1</a><time datetime="2023-09-12T02:29:58.000Z" title="发表于 2023-09-12 10:29:58">2023-09-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RabbitMQ笔记"/></a><div class="content"><a class="title" href="/2023/07/24/RabbitMq/" title="RabbitMQ笔记">RabbitMQ笔记</a><time datetime="2023-07-24T02:29:58.000Z" title="发表于 2023-07-24 10:29:58">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记"><img src="/./img/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis笔记"/></a><div class="content"><a class="title" href="/2022/12/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记">Redis笔记</a><time datetime="2022-12-24T02:29:58.000Z" title="发表于 2022-12-24 10:29:58">2022-12-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By 小张</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div>本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img class="cdn" src="./img/youpaiyun.png" /></a>提供CDN加速/云储存服务<div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="/js/debounce.js" async></script><script src="/js/sun_moon.js" async></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script src="/js/footer.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><div id="music-player" class="aplayer no-destroy" data-id="8418044320" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="false"> </div><script async src="/js/snow.js"></script><script src="/js/star.js"></script><script src="/js/copy.js"></script><script async src="/js/fps.js"></script><script src="/js/random.js"></script><script async src="//at.alicdn.com/t/c/font_4185042_s9i9e08l3w.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.1/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://my-bucket-pv30eln-1315165253.cos-website.ap-guangzhou.myqcloud.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '982e2f357e344923beb3175e4b012b6d';
  var gaud_map_key = '2c2137f367e0748bc2e4317025f9ad38';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>